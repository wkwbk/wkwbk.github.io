<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>算法分析与设计</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
        },
      };
    </script>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
      /* Basic reset and page background */
      body {
        background: #f0f0f0;
        margin: 0;
        padding: 0;
      }

      /* A4 page container styles */
      .page {
        background: white;
        width: 210mm;
        min-height: 297mm;
        margin: 10mm auto;
        padding: 8mm;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        box-sizing: border-box;
      }

      /* Main content container styles */
      .page-content {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size: 10px;
        line-height: 1.4;
        color: #333;
        column-count: 3;
        column-gap: 5mm;
        column-rule: 1px solid #eee;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 4px 0;
        padding: 0;
        break-after: avoid;
        font-weight: bold;
      }

      h1 {
        column-span: all;
        text-align: center;
        font-size: 18px;
        border-bottom: 2px solid black;
        padding-bottom: 4px;
        margin-bottom: 5px;
      }

      .header-info {
        column-span: all;
        display: flex;
        justify-content: space-around;
        font-size: 11px;
        margin-bottom: 10px;
      }

      h2 {
        font-size: 14px;
        border-bottom: 1px solid #ccc;
        padding-bottom: 2px;
        margin-top: 5mm;
        column-span: all;
      }
      h2:first-child {
        margin-top: 0;
      }
      h3 {
        font-size: 12px;
        margin-top: 4px;
      }

      p,
      ul,
      ol,
      table,
      blockquote {
        margin: 3px 0;
      }
      ul,
      ol {
        padding-left: 15px;
      }
      li {
        margin-bottom: 2px;
      }
      strong {
        font-weight: bold;
      }

      table,
      img,
      pre {
        break-inside: avoid;
      }

      img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 4px 0;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 9px;
        margin: 5px 0;
      }
      th,
      td {
        border: 1px solid #ccc;
        padding: 2px 4px;
        text-align: left;
        vertical-align: top;
      }
      th {
        background-color: #f2f2f2 !important;
        font-weight: bold;
      }

      pre {
        background-color: #f4f4f4;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        font-family: "Courier New", Courier, monospace;
        font-size: 9px;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 5px 0;
      }

      code {
        font-family: "Courier New", Courier, monospace;
        background-color: #eee;
        padding: 1px 3px;
        border-radius: 3px;
      }
      pre code {
        background-color: transparent;
        padding: 0;
        border-radius: 0;
      }

      blockquote {
        border-left: 3px solid #ddd;
        padding-left: 10px;
        color: #555;
        font-style: italic;
      }

      hr {
        column-span: all;
        border: 0;
        border-top: 1px solid #ccc;
        margin: 10px 0;
      }

      iframe {
        column-span: all;
      }

      /* Button container styles */
      .button-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* General button styles */
      .action-button {
        display: block;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: background-color 0.3s;
        text-decoration: none;
        text-align: center;
      }

      /* Button colors */
      #print-button {
        background-color: #007bff;
      }
      #print-button:hover {
        background-color: #0056b3;
      }

      #download-source-button {
        background-color: #ffc107;
        color: #212529;
      }
      #download-source-button:hover {
        background-color: #e0a800;
      }

      /* Print-specific styles */
      @page {
        size: A4;
        margin: 0;
      }

      @media print {
        body {
          background: none;
        }
        .page {
          margin: 0;
          padding: 5mm;
          box-shadow: none;
          width: 100%;
          min-height: 0;
        }
        .button-container {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="button-container">
      <button id="download-source-button" class="action-button" onclick="downloadSource()">💾 下载源码</button>
      <button id="print-button" class="action-button" onclick="window.print()">🖨️ 打印</button>
    </div>

    <div class="page" id="page-content-to-download">
      <div class="page-content">
        <h2>第一大题</h2>

        <h3>1.1</h3>
        <blockquote>
          <p>分支限界法和回溯法的区别及相同点？</p>
        </blockquote>
        <p><strong>求解目标不同：</strong></p>
        <ul>
          <li>回溯法的求解目标是找出解空间树中满足约束条件的所有解</li>
          <li>分支限界法的求解目标是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解</li>
        </ul>
        <p><strong>搜索方式不同：</strong></p>
        <ul>
          <li>回溯法以深度优先的方式搜索解空间树</li>
          <li>分支限界法以广度优先或以最小耗费优先的方式搜索解空间树</li>
        </ul>
        <p><strong>相同点：</strong></p>
        <ul>
          <li>均基于解空间树搜索；采用剪枝优化搜索效率。</li>
        </ul>

        <h3>1.2</h3>
        <blockquote>
          <p>数学建模。</p>
        </blockquote>
        <ol>
          <li><strong>问题转化</strong>：将环保投资问题建模为 0-1 背包问题模型。</li>
          <li><strong>变量定义</strong>：$x_i \in \{0,1\}$ 表示是否投资第 $i$ 个方案（1=投资，0=不投资）。</li>
          <li><strong>目标函数</strong>：最大化总减碳量 $\max \sum_{i=1}^{3} v_i x_i$（$v_i$ 为减碳量）。</li>
          <li><strong>约束条件</strong>：总成本 $\sum_{i=1}^{3} w_i x_i \leq 30$（$w_i$ 为成本）。</li>
          <li><strong>结论</strong>：减碳量等效为背包"价值"，成本等效为"重量"，投资上限 30 等效为背包容量。</li>
        </ol>
        <blockquote>
          <p>队列式分支限界法求解过程？最大减碳量？最优方案组合？</p>
        </blockquote>
        <ol>
          <li><strong>构造解空间树</strong>：三层二叉树（左分支=选方案，右分支=不选方案）。</li>
          <li>
            <strong>搜索过程</strong>：
            <pre><code>[A] B, C      =&gt; B, C
[B, C] D, E    =&gt; E
[C, E] F, G    =&gt; F, G
[E, F, G] J, K  =&gt; K(45)[1,0,0]
[F, G] L, M    =&gt; L(50)[0,1,1], M(25)[0,1,0]
[G] N, O      =&gt; N(25)[0,0,1], O(0)[0,0,0]</code></pre>
          </li>
          <li><strong>最优值（最大减碳量）</strong>：50 万吨</li>
          <li><strong>最优解（最优方案组合）</strong>：选方案 2 和方案 3，即 $x = [0,1,1]$</li>
        </ol>
        <img src="./assets/009.png" alt="解空间树" />

        <h3>1.3</h3>
        <blockquote>
          <p>回溯法编程实现，找这个方案的最大减碳量以及最优方案组合。</p>
        </blockquote>
        <p><strong>[回溯函数]</strong></p>
        <pre><code class="language-cpp">void Backtrack(int i) {
    // 如果到达叶子节点
    if (i > n) { 
        bestp = cp; 
        return; 
    }

    // 进入左子树
    if (cw + w[i] <= c) {
        cw += w[i];
        cp += p[i];
        Backtrack(i + 1);
        cw -= w[i];
        cp -= p[i];
    }

    // 进入右子树
    if (Bound(i + 1) > bestp) {
        Backtrack(i + 1);
    }
}</code></pre>
        <p><strong>[限界函数]</strong></p>
        <pre><code class="language-cpp">private static double Bound(int i) {
    // 计算剩余容量
    double cleft = c - cw;  

    double bound = cp;

    // 以物品单位重量价值递减序装入物品
    while (i <= n && w[i] <= cleft) {
        cleft -= w[i];
        bound += p[i];
        i++;
    }

    // 装满背包
    if (i <= n) {
        bound += p[i] / w[i] * cleft; 
    }

    return bound;
}</code></pre>

        <h2>第二大题</h2>

        <h3>2.1</h3>
        <blockquote>
          <p>贪心算法的原理是什么？</p>
        </blockquote>
        <ul>
          <li>贪心算法是一种通过局部最优选择来构建全局最优解的算法。</li>
          <li>它依赖于贪心选择性质和最优子结构，即每一步都选择当前最优，期望最终得到全局最优解，且无需回溯。</li>
        </ul>
        <blockquote>
          <p>哈夫曼编码原理是什么？</p>
        </blockquote>
        <ol>
          <li><strong>变长编码</strong>：哈夫曼编码是一种变长编码方式。出现频率高的字符分配较短的编码，出现频率低的字符分配较长的编码。</li>
          <li><strong>频率排序</strong>：首先将字符按照出现频率从小到大排序。</li>
          <li>
            <strong>构造哈夫曼树</strong>：
            <ul>
              <li>每次选取频率最小的两个节点。</li>
              <li>创建一个父节点，其频率等于这两个子节点频率之和。</li>
              <li>将该父节点按照频率大小重新插入到排序好的节点队列中。</li>
              <li>重复以上步骤，直到队列中只剩下一个节点，这个节点就是哈夫曼树的根节点。</li>
            </ul>
          </li>
          <li>
            <strong>编码</strong>：在哈夫曼树上，左分支编 <code>0</code> 右分支编 <code>1</code>，直到到达叶子节点，路径上的 <code>0</code> 和 <code>1</code> 组成的字符串就是该字符的哈夫曼编码。
          </li>
        </ol>
        <blockquote>
          <p>定长编码的原理是什么？</p>
        </blockquote>
        <p>定长编码也称为等长编码，是一种数据编码方式，其中每个字符或符号都用固定长度的二进制位来表示。</p>
        <p><strong>定长编码计算方式：</strong></p>
        <ol>
          <li>确定字符集大小 $N$（需编码的不同字符总数）。</li>
          <li>
            计算最小编码位长 $L$：$2^L \geqslant N$
            <ul>
              <li>等价对数形式：$L = \lceil \log_2 N \rceil$，其中 $\lceil \cdot \rceil$ 表示向上取整函数。</li>
            </ul>
          </li>
        </ol>

        <h3>2.2</h3>
        <blockquote>
          <p>构造哈夫曼树及编码，写出具体的构造过程，写出每种垃圾名称的具体编码。</p>
        </blockquote>
        <p>垃圾类型由小到大排序：</p>
        <table>
          <thead>
            <tr>
              <th>4</th>
              <th>3</th>
              <th>2</th>
              <th>1</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>其他垃圾</td>
              <td>有害垃圾</td>
              <td>厨余垃圾</td>
              <td>可回收垃圾</td>
            </tr>
            <tr>
              <td>10%</td>
              <td>15%</td>
              <td>30%</td>
              <td>45%</td>
            </tr>
          </tbody>
        </table>
        <p><strong>构造哈夫曼树：</strong></p>
        <img src="./assets/010.png" alt="哈夫曼树" />
        <p><strong>根据哈夫曼树可得：</strong></p>
        <ul>
          <li>可回收物：<code>0</code></li>
          <li>厨余垃圾：<code>11</code></li>
          <li>有害垃圾：<code>101</code></li>
          <li>其他垃圾：<code>100</code></li>
        </ul>

        <h3>2.3</h3>
        <blockquote>
          <p>编码长度与节省比例计算</p>
        </blockquote>
        <ol>
          <li>
            <strong>定长编码</strong>：
            <ul>
              <li>4 种类型需 2 位二进制（$2^2=4$），总码长 = $2 \times 10000 = 20000$ 位（假设处理 1 万次）。</li>
            </ul>
          </li>
          <li>
            <strong>哈夫曼编码</strong>：
            <ul>
              <li>可回收物：1 位 × 4500 次 = 4500 位</li>
              <li>厨余垃圾：2 位 × 3000 次 = 6000 位</li>
              <li>有害垃圾：3 位 × 1500 次 = 4500 位</li>
              <li>其他垃圾：3 位 × 1000 次 = 3000 位</li>
              <li>总码长 = $4500 + 6000 + 4500 + 3000 = 18000$ 位。</li>
            </ul>
          </li>
          <li>
            <strong>节省比例</strong>：
            <ul>
              <li>节省位数 = $20000 - 18000 = 2000$ 位</li>
              <li>节省比例 = $2000 / 20000 = 10\%$。</li>
            </ul>
          </li>
        </ol>

        <h2>第三大题</h2>

        <h3>3.1</h3>
        <blockquote>
          <p>动态规划求解最短路径步骤</p>
        </blockquote>
        <ol>
          <li>找出最优解的性质，并描绘其结构特征。</li>
          <li>递归的定义最优值。</li>
          <li>以自底向上的方式计算出最优值，构造最优解。</li>
        </ol>

        <h3>3.2</h3>
        <blockquote>
          <p>建立状态转移方程</p>
        </blockquote>
        <ol>
          <li>
            <strong>定义</strong>：
            <ul>
              <li>$s$：当前节点</li>
              <li>$x$：节点 $s$ 的前驱节点</li>
              <li>$c(x, s)$：$x$ 到 $s$ 的边</li>
            </ul>
          </li>
          <li>
            <strong>转移方程分段函数</strong>： $$ f(s) = \begin{cases} 0 & \text{若 } s = 1 & \text{(起点)} \\ \min \big\{ f(x) + c(x, s) \big\} & \text{若 } s \neq 1 & \text{(其他节点)} \end{cases}
            $$
          </li>
        </ol>
        <blockquote>
          <p>填表计算最优值</p>
        </blockquote>
        <ul>
          <li>$f[i]$：从节点 1 到节点 $i$ 的最短距离</li>
          <li>$p[i]$：节点 $i$ 的前驱节点</li>
        </ul>
        <table>
          <thead>
            <tr>
              <th></th>
              <th>1</th>
              <th>2</th>
              <th>3</th>
              <th>4</th>
              <th>5</th>
              <th>6</th>
              <th>7</th>
              <th>8</th>
              <th>9</th>
              <th>10</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>f[i]</strong></td>
              <td>0</td>
              <td>4</td>
              <td>2</td>
              <td>3</td>
              <td>8</td>
              <td>6</td>
              <td>11</td>
              <td>12</td>
              <td>12</td>
              <td>16</td>
            </tr>
            <tr>
              <td><strong>p[i]</strong></td>
              <td>0</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td>3</td>
              <td>4</td>
              <td>4</td>
              <td>5</td>
              <td>6</td>
              <td>9</td>
            </tr>
          </tbody>
        </table>
        <blockquote>
          <p>最短路径长度及最优路线</p>
        </blockquote>
        <ol>
          <li><strong>最短路径长度</strong>：$f(10) = 16$。</li>
          <li><strong>路径</strong>：$1 \to 4 \to 6 \to 9 \to 10$。</li>
        </ol>

        <h2>第四大题</h2>

        <h3>4.1</h3>
        <blockquote>
          <p>分治法</p>
        </blockquote>
        <p>将 $X，Y$ 拆分为两半（$k = n/2 = 4$ 位）：</p>
        <p>$A=1234$，$B=5678$，$C=5678$，$D=4321$</p>
        <p>$X = A \times 10^k + B$，$Y = C \times 10^k + D$</p>
        <p>$XY = AC \cdot 10^{2k} + (AD + BC) \cdot 10^k + BD$</p>
        <p><strong>乘法次数：</strong>4 次</p>

        <h3>4.2</h3>
        <blockquote>
          <p>算法优化</p>
        </blockquote>
        <p><strong>优化关键点：</strong></p>
        $$ \begin{align*} (AD + BC) &= (AC + AD + BC + BD) - AC - BD \\ &= A(C+D) + B(C+D) - AC - BD \\ &= (A+B)(C+D) - AC - BD \end{align*} $$
        <p>$XY = AC \cdot 10^{2k} + [(A+B)(C+D) - AC - BD] \cdot 10^k + BD$</p>
        <p><strong>乘法次数：</strong>$AC$、$BD$、$(A+B)(C+D)$</p>

        <h3>4.3</h3>
        <blockquote>
          <p>复杂度对比</p>
        </blockquote>
        <ol>
          <li><strong>优化前</strong>：$T(n) = 4T(n/2) + O(n)$，解得 $T(n) = O(n^2)$。</li>
          <li><strong>优化后</strong>：$T(n) = 3T(n/2) + O(n)$，解得 $T(n) = O(n^{\log_2 3}) \approx O(n^{1.585})$。</li>
          <li><strong>结论</strong>：优化后效率显著提升（指数级降低）。</li>
        </ol>
      </div>
    </div>

    <script>
      // 下载 HTML 源代码功能
      function downloadSource() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], {
          type: "text/html;charset=utf-8",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "算法分析与设计 - 源代码.html";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }
    </script>
  </body>
</html>
