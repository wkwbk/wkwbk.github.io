<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>算法分析与设计</title>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <style>
      /* Basic reset and page background */
      body {
        background: #f0f0f0;
        margin: 0;
        padding: 0;
      }

      /* A4 page container styles */
      .page {
        background: white;
        width: 210mm;
        min-height: 297mm;
        margin: 10mm auto;
        padding: 8mm;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        box-sizing: border-box;
      }

      /* Main content container styles */
      .page-content {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size: 10px;
        line-height: 1.2;
        color: #333;
        column-count: 3;
        column-gap: 5mm;
        column-rule: 1px solid #eee;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 4px 0;
        padding: 0;
        break-after: avoid;
      }

      h2 {
        font-size: 14px;
        border-bottom: 1px solid #ccc;
        padding-bottom: 2px;
        margin-top: 5mm;
        column-span: all;
      }
      h2:first-child {
        margin-top: 0;
      }
      h3 {
        font-size: 12px;
      }

      p,
      ul,
      ol,
      table {
        margin: 3px 0;
      }
      ul,
      ol {
        padding-left: 15px;
      }
      li {
        margin-bottom: 2px;
      }
      strong {
        font-weight: bold;
      }

      table,
      img,
      pre {
        break-inside: avoid;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        font-size: 9px;
        margin: 5px 0;
      }
      th,
      td {
        border: 1px solid #ccc;
        padding: 2px 4px;
        text-align: left;
        vertical-align: top;
      }
      th {
        background-color: #f2f2f2 !important;
        font-weight: bold;
      }

      pre {
        background-color: #f4f4f4;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        font-family: "Courier New", Courier, monospace;
        font-size: 9px;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 5px 0;
      }

      code {
        font-family: "Courier New", Courier, monospace;
        background-color: #eee;
        padding: 1px 3px;
        border-radius: 3px;
      }
      pre code {
        background-color: transparent;
        padding: 0;
        border-radius: 0;
      }

      /* 强制分页的样式 */
      .new-page {
        break-before: page;
      }

      /* Button container styles */
      .button-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* General button styles */
      .action-button {
        display: block;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: bold;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: background-color 0.3s;
        text-decoration: none;
        text-align: center;
      }

      /* Button colors */
      #print-button {
        background-color: #007bff;
      }
      #print-button:hover {
        background-color: #0056b3;
      }

      #download-button {
        background-color: #28a745;
      }
      #download-button:hover {
        background-color: #1e7e34;
      }

      #download-source-button {
        background-color: #ffc107;
        color: #212529;
      }
      #download-source-button:hover {
        background-color: #e0a800;
      }

      #donate-button {
        background-color: #e83e8c;
      }
      #donate-button:hover {
        background-color: #c2185b;
      }

      /* Print-specific styles */
      @page {
        size: A4;
        margin: 0;
      }

      @media print {
        body {
          background: none;
        }
        .page {
          margin: 0;
          padding: 5mm;
          box-shadow: none;
          width: 100%;
          min-height: 0;
        }
        .button-container {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="button-container">
      <a href="/donate/index.html" id="donate-button" class="action-button" target="_blank" rel="noopener noreferrer">❤️ 请作者喝杯咖啡</a>
      <button id="download-source-button" class="action-button" onclick="downloadSource()">💾 下载源码</button>
      <button id="print-button" class="action-button" onclick="window.print()">🖨️ 打印</button>
    </div>

    <div class="page" id="page-content-to-download">
      <div class="page-content">
        <h2>第一大题</h2>
        <p>分支限界法与回溯法（环保方案投资问题）</p>

        <h3>1.1</h3>
        <p><strong>数学建模</strong></p>
        <ol>
          <li><strong>问题转化</strong>：将环保投资问题建模为 0-1 背包问题模型。</li>
          <li>
            <strong>变量定义</strong>：
            <ul>
              <li>
                <code>x<sub>i</sub> ∈ {0,1}</code> 表示是否投资第 <code>i</code> 个方案（1=投资，0=不投资）。
              </li>
            </ul>
          </li>
          <li>
            <strong>目标函数</strong>：最大化总减碳量 <code>max Σ v<sub>i</sub>x<sub>i</sub></code> (i=1 to 3)，其中 <code>v<sub>i</sub></code> 为减碳量。
          </li>
          <li>
            <strong>约束条件</strong>：总成本 <code>Σ w<sub>i</sub>x<sub>i</sub> ≤ 30</code> (i=1 to 3)，其中 <code>w<sub>i</sub></code> 为成本。
          </li>
          <li>
            <strong>答案</strong>：
            <ul>
              <li>减碳量等效为背包“价值”，成本等效为“重量”，投资上限 30 等效为背包容量。</li>
            </ul>
          </li>
        </ol>

        <h3>1.2</h3>
        <p><strong>队列式分支限界法求解过程</strong></p>
        <ol>
          <li><strong>构造解空间树</strong>：三层二叉树（左分支=选方案，右分支=不选）。</li>
          <li>
            <strong>搜索过程</strong>：
            <ul>
              <li>扩展根节点 A → 生成 B（选方案 1，成本 16≤30）、C（不选方案 1，成本 0）。活结点表：[B, C]。</li>
              <li>扩展 B → 生成 D（选方案 2，成本 16+15=31>30，不可行）、E（不选方案 2，成本 16）。活结点表：[C, E]。</li>
              <li>扩展 C → 生成 F（选方案 2，成本 15）、G（不选方案 2，成本 0）。活结点表：[E, F, G]。</li>
              <li>扩展 E → 生成 J（选方案 3，成本 16+10=26）、K（不选方案 3，成本 16）。K 为叶子节点，减碳量=45。活结点表：[F, G]。</li>
              <li>扩展 F → 生成 L（选方案 3，成本 15+10=25）、M（不选方案 3，成本 15）。L 为叶子节点，减碳量=25+25=50。活结点表：[G, M]。</li>
              <li>扩展 G → 生成 N（选方案 3，成本 10）、O（不选方案 3，成本 0）。N 减碳量=25，O 减碳量=0。</li>
            </ul>
          </li>
          <li>
            <strong>最优解</strong>：
            <ul>
              <li>最大减碳量 = 50 万吨（方案组合：选方案 2 和方案 3，即 <code>x = [0,1,1]</code>）。</li>
            </ul>
          </li>
        </ol>

        <h3>1.3</h3>
        <p><strong>回溯法编程实现</strong></p>
        <ol>
          <li>
            <strong>伪代码框架</strong>：
            <pre><code>def backtrack(i, cw, cv):
  # i: 当前决策方案索引
  # cw: 当前总成本
  # cv: 当前总减碳量
  if i > n: # 到达叶子节点
    if cv > best_value:
      best_value = cv
      best_solution = x.copy()
    return
  # 左子树：选择当前方案
  if cw + w[i] <= C: # 满足成本约束
    x[i] = 1
    backtrack(i+1, cw + w[i], cv + v[i])
    x[i] = 0 # 回溯
  # 右子树：不选当前方案（需剪枝）
  # 计算剩余方案减碳量上界
  bound = cv + bound_func(i+1, C-cw)
  if bound > best_value: # 上界可能更优才搜索
    x[i] = 0
    backtrack(i+1, cw, cv)</code></pre>
          </li>
          <li>
            <strong>关键函数</strong>：
            <ul>
              <li><code>bound_func</code>：贪心估算剩余方案最大减碳量（允许部分投资）。</li>
            </ul>
          </li>
        </ol>

        <h2>第二大题</h2>
        <p>贪心算法（哈夫曼编码应用）</p>

        <h3>2.1</h3>
        <p><strong>哈夫曼编码原理</strong></p>
        <ol>
          <li><strong>核心原则</strong>：频率越高，编码越短（不定长编码）。</li>
          <li>
            <strong>构造步骤</strong>：
            <ul>
              <li>按频率升序排序节点。</li>
              <li>每次合并频率最小的两个节点，生成父节点（频率=子节点和）。</li>
              <li>重复直至只剩根节点。</li>
              <li>左分支标 0，右分支标 1，从根到叶路径即为编码。</li>
            </ul>
          </li>
        </ol>

        <h3>2.2</h3>
        <p><strong>构造哈夫曼树及编码</strong></p>
        <ol>
          <li>
            <strong>构造过程</strong>：
            <ul>
              <li>初始节点：其他 (10%)、有害 (15%)、厨余 (30%)、可回收 (45%)。</li>
              <li>合并其他 (10%) + 有害 (15%) → 节点 A(25%)。</li>
              <li>合并 A(25%) + 厨余 (30%) → 节点 B(55%)。</li>
              <li>合并 B(55%) + 可回收 (45%) → 根节点 (100%)。</li>
            </ul>
          </li>
          <li>
            <strong>编码结果</strong>：
            <ul>
              <li>可回收物：<code>0</code></li>
              <li>厨余垃圾：<code>11</code></li>
              <li>有害垃圾：<code>101</code></li>
              <li>其他垃圾：<code>100</code></li>
            </ul>
          </li>
        </ol>

        <h3>2.3</h3>
        <p><strong>编码长度与节省比例计算</strong></p>
        <ol>
          <li>
            <strong>定长编码</strong>：
            <ul>
              <li>4 种类型需 2 位二进制（<code>2<sup>2</sup>=4</code>），总码长 = 2 × 10000 = 20000 位（假设处理 1 万次）。</li>
            </ul>
          </li>
          <li>
            <strong>哈夫曼编码</strong>：
            <ul>
              <li>可回收物：1 位 × 4500 次 = 4500 位</li>
              <li>厨余垃圾：2 位 × 3000 次 = 6000 位</li>
              <li>有害垃圾：3 位 × 1500 次 = 4500 位</li>
              <li>其他垃圾：3 位 × 1000 次 = 3000 位</li>
              <li>总码长 = 4500 + 6000 + 4500 + 3000 = 18000 位。</li>
            </ul>
          </li>
          <li>
            <strong>节省比例</strong>：
            <ul>
              <li>节省位数 = 20000 - 18000 = 2000 位</li>
              <li>节省比例 = 2000 / 20000 = 10%。</li>
            </ul>
          </li>
        </ol>

        <h2>第三大题</h2>
        <p>动态规划（多阶段决策问题）</p>

        <h3>3.1</h3>
        <p><strong>状态转移方程</strong></p>
        <ol>
          <li>
            <strong>定义</strong>：
            <ul>
              <li><code>f[s]</code>：从节点 1 到节点 s 的最短距离。</li>
              <li><code>p[s]</code>：节点 s 的前驱节点。</li>
            </ul>
          </li>
          <li>
            <strong>转移方程</strong>：
            <ul>
              <li>边界：<code>f[1] = 0</code></li>
              <li>
                递推：<code>f[s] = min<sub>(x,s)∈E</sub> { f[x] + c<sub>x,s</sub> }</code>（x 为 s 的前驱节点）。
              </li>
            </ul>
          </li>
        </ol>

        <h3>3.2</h3>
        <p><strong>填表计算最优值</strong></p>
        <table>
          <thead>
            <tr>
              <th>节点</th>
              <th>f[s]</th>
              <th>p[s]</th>
              <th>计算过程</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td>0</td>
              <td>-</td>
              <td>边界</td>
            </tr>
            <tr>
              <td>2</td>
              <td>4</td>
              <td>1</td>
              <td><code>f[1] + 4</code></td>
            </tr>
            <tr>
              <td>3</td>
              <td>2</td>
              <td>1</td>
              <td><code>f[1] + 2</code></td>
            </tr>
            <tr>
              <td>4</td>
              <td>3</td>
              <td>1</td>
              <td><code>f[1] + 3</code></td>
            </tr>
            <tr>
              <td>5</td>
              <td>8</td>
              <td>3</td>
              <td>min(14, 8) → 8</td>
            </tr>
            <tr>
              <td>6</td>
              <td>6</td>
              <td>4</td>
              <td>min(13, 9, 6) → 6</td>
            </tr>
            <tr>
              <td>7</td>
              <td>11</td>
              <td>4</td>
              <td>min(12, 11) → 11</td>
            </tr>
            <tr>
              <td>8</td>
              <td>12</td>
              <td>5</td>
              <td>min(12, 15, 16) → 12</td>
            </tr>
            <tr>
              <td>9</td>
              <td>12</td>
              <td>6</td>
              <td>min(16, 12, 15) → 12</td>
            </tr>
            <tr>
              <td>10</td>
              <td>16</td>
              <td>9</td>
              <td>min(20, 16) → 16</td>
            </tr>
          </tbody>
        </table>

        <h3>3.3</h3>
        <p><strong>最优解构造</strong></p>
        <ol>
          <li><strong>最短路径长度</strong>：16。</li>
          <li>
            <strong>路径</strong>：
            <ul>
              <li>10 ← 9 ← 6 ← 4 ← 1</li>
              <li>即 <code>1 → 4 → 6 → 9 → 10</code>。</li>
            </ul>
          </li>
        </ol>

        <h2>第四大题</h2>
        <p>分治法（大整数乘法）</p>

        <h3>4.1</h3>
        <p><strong>普通乘法复杂度</strong></p>
        <ol>
          <li><strong>算法</strong>：每位相乘，复杂度 <code>O(n<sup>2</sup>)</code>。</li>
        </ol>

        <h3>4.2</h3>
        <p><strong>分治法原理及优化</strong></p>
        <ol>
          <li>
            <strong>分治步骤</strong>：
            <ul>
              <li>
                将 X, Y 拆分为两半（<code>k = n/2</code> 位）：
                <ul>
                  <li>
                    <code>X = A × 10<sup>k</sup> + B</code> (A=1234, B=5678)
                  </li>
                  <li>
                    <code>Y = C × 10<sup>k</sup> + D</code> (C=5678, D=4321)
                  </li>
                </ul>
              </li>
              <li>
                原始计算：<code>XY = AC·10<sup>2k</sup> + (AD+BC)·10<sup>k</sup> + BD</code>（需 4 次乘法）。
              </li>
            </ul>
          </li>
          <li>
            <strong>优化（减少乘法次数）</strong>：
            <ul>
              <li>
                公式：<code>XY = AC·10<sup>2k</sup> + [(A+B)(C+D) - AC - BD]·10<sup>k</sup> + BD</code>
              </li>
              <li>乘法次数：3 次（计算 <code>AC</code>, <code>BD</code>, <code>(A+B)(C+D)</code>)。</li>
            </ul>
          </li>
        </ol>

        <h3>4.3</h3>
        <p><strong>复杂度对比</strong></p>
        <ol>
          <li><strong>优化前</strong>：<code>T(n) = 4T(n/2) + O(n)</code>，解得 <code>T(n) = O(n<sup>2</sup>)</code>。</li>
          <li><strong>优化后</strong>：<code>T(n) = 3T(n/2) + O(n)</code>，解得 <code>T(n) = O(n<sup>log<sub>2</sub>3</sup>) ≈ O(n<sup>1.585</sup>)</code>。</li>
          <li><strong>结论</strong>：优化后效率显著提升（指数级降低）。</li>
        </ol>
      </div>
    </div>

    <script>
      // 下载 HTML 源代码功能
      function downloadSource() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: "text/html;charset=utf-8" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "算法分析与设计 - 源代码.html";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }
    </script>
  </body>
</html>
