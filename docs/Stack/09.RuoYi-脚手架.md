# RuoYi 脚手架

## 简介

RuoYi 是一个基于 Spring Boot 和 Vue 的前后端分离的快速开发脚手架。它内置了用户管理、部门管理、岗位管理、菜单管理、角色管理、字典管理等一系列系统功能，可以帮助开发者快速搭建企业级中后台产品原型。

## 项目结构

RuoYi 的后端项目是一个多模块的 Maven 项目，结构清晰，职责分明。

```txt
ruoyi
├── ruoyi-admin      -- Web 入口，存放 Controller
├── ruoyi-common     -- 公共模块，存放通用代码
├── ruoyi-framework  -- 框架模块，集成第三方框架，如 Spring Security
├── ruoyi-generator  -- 代码生成器模块
├── ruoyi-quartz     -- 定时任务模块
└── ruoyi-system     -- 系统核心模块，包含 domain, service, mapper
```

## 依赖关系

各个模块之间的依赖关系如下，核心思想是上层模块依赖下层模块，`ruoyi-admin` 作为入口模块，依赖所有其他业务模块。

```mermaid
graph TD
    subgraph "依赖关系"
        A[ruoyi-admin] --> B[ruoyi-framework];
        A --> C[ruoyi-generator];
        A --> D[ruoyi-quartz];
        C --> F[ruoyi-common];
        B --> E[ruoyi-system];
    end
```

最终其实所有代码都整合到了 ruoyi-admin 当中。

## 表结构

RuoYi 内置了一套完整的权限管理和系统监控相关的表。

| 表名             | 描述               |
| :--------------- | :----------------- |
| gen_table        | 代码生成器表信息   |
| gen_table_column | 生成列表信息       |
| sys_config       | 系统配置信息       |
| sys_dept         | 部门表             |
| sys_dict_data    | 字典目录表         |
| sys_dict_type    | 字典类型表         |
| sys_job          | 定时任务表         |
| sys_job_log      | 任务日志表         |
| sys_logininfor   | 登录信息表         |
| sys_menu         | 菜单表             |
| sys_notice       | 系统通知表         |
| sys_oper_log     | 执行日志表         |
| sys_post         | 岗位表             |
| sys_role         | 角色表             |
| sys_role_dept    | 角色和部门关系表   |
| sys_role_menu    | 角色和菜单关系表   |
| sys_user         | 用户表             |
| sys_user_post    | 用户和岗位关系表   |
| sys_user_role    | 用户和角色的关系表 |

## 数据字典

若依通过 `sys_dict_type`（字典类型表）和 `sys_dict_data`（字典数据表）的组合来实现数据字典功能，实现了配置与代码的分离。

- **`sys_dict_type` (字典类型表):**
  - 这张表用来定义一个字典的类别。例如，我们可以定义一个名为 `sys_user_sex` 的字典类型，用于表示用户的性别。
  - 它相当于一个分组，将同一类型的字典数据归集在一起。

- **`sys_dict_data` (字典数据表):**
  - 这张表存放具体的键值对数据。
  - 它通过外键（通常是 `dict_type` 字段）与 `sys_dict_type` 表关联。
  - 例如，对于 `sys_user_sex` 这个字典类型，我们可以在 `sys_dict_data` 表中存储以下数据：
    - 标签为“男”，值为“0”
    - 标签为“女”，值为“1”
    - 标签为“未知”，值为“2”

**工作流程：**

1. **定义类型**：在 `sys_dict_type` 表中创建一个新的字典类型，比如 `sys_notice_status`（通知状态）。
2. **添加数据**：在 `sys_dict_data` 表中添加与 `sys_notice_status` 类型关联的多条记录，如 `{标签："正常", 值："0"}`，`{标签："关闭", 值："1"}`。
3. **前端调用**：前端可以通过调用后端提供的接口，传入字典类型 `sys_notice_status`，从而获取其下所有的字典数据（一个包含“正常”和“关闭”选项的列表）。
4. **后端使用**：后端在需要使用这些固定值的地方，可以通过字典工具类，根据字典类型和字典值来获取对应的标签，反之亦然。

通过这种方式，当需要修改或增加某个状态时，只需在数据库中操作 `sys_dict_data` 表，而无需修改任何代码，提高了系统的灵活性和可维护性。

## 认证和授权

若依的权限控制是基于 Spring Security + JWT 实现的，精确到按钮级别，提供了非常完善的认证和授权方案。

### 认证流程

认证就是验证用户身份的过程，在若依中具体表现为用户登录。

1. **用户登录**：前端将用户名和密码发送到后端登录接口。
2. **信息校验**：后端通过 `UserDetailsServiceImpl` 服务加载用户信息（主要是根据用户名查询数据库中的 `sys_user` 表）。
3. **密码比对**：Spring Security 使用 `BCryptPasswordEncoder` 将用户输入的密码与数据库中存储的加密密码进行比对。
4. **生成 Token**：密码验证通过后，系统会使用 JWT 技术生成一个 Token。这个 Token 中包含了用户的唯一标识（如用户 ID、用户名）等信息。
5. **返回 Token**：后端将生成的 Token 返回给前端。
6. **前端存储**：前端将 Token 存储在本地（例如 `localStorage` 或 `sessionStorage`）。
7. **后续请求**：在后续的所有请求中，前端都需要在请求头（Header）的 `Authorization` 字段中携带这个 Token，格式通常为 `Bearer <token>`。

### 授权流程

授权是指验证用户是否有权限访问某个资源（如 API 接口、菜单、按钮）。

1. **请求到达**：当一个携带 Token 的请求到达后端时，JWT 认证过滤器 `JwtAuthenticationTokenFilter` 会首先介入。
2. **解析 Token**：过滤器会解析 Token，验证其合法性（如是否过期、签名是否正确），并从中获取用户信息。
3. **获取权限**：根据用户信息，系统会查询 `sys_role`、`sys_menu` 等关联表，获取该用户拥有的所有权限标识（例如 `system:user:list`、`system:user:add`）。
4. **权限校验**：
    - **接口层面**：若依使用自定义的 `@PreAuthorize` 注解，结合 `ss` 表达式（例如 `@PreAuthorize("@ss.hasPermi('system:user:list')")`）来判断当前用户是否拥有访问该接口所需的权限标识。
    - **UI 层面**：前端在登录后会从后端获取该用户完整的权限列表，并根据这个列表来动态地决定哪些菜单、按钮应该被渲染和显示。
5. **返回结果**：如果用户拥有所需权限，则正常访问资源；否则，Spring Security 会拒绝访问，并返回 403 (Forbidden) 状态码。

通过这套机制，若依实现了前后端分离架构下的精细化权限控制。
