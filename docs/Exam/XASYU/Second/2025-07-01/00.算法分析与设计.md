# 算法分析与设计

- 时间：10:30 - 12:30
- 地点：中心楼 612-614
- 监考老师：杨晓明、肖琼谞

## 第一大题

::: tip 情景

分支限界法与回溯法（环保方案投资问题）

**题目背景**

有 3 个环保投资方案：

- 方案 1：成本 16 万元，减碳量 45 万吨
- 方案 2：成本 15 万元，减碳量 25 万吨
- 方案 3：成本 15 万元，减碳量 25 万吨

总投资成本上限 30 万元，目标是最大化总减碳量。

:::

### 1.1

> 分支限界与回溯法的区别？p.127

求解目标不同：

- 回溯法求所有解
- 分支限界只能求一个解

搜索方式不同：

- 回溯法使用深度优先
- 分支限界使用广度优先或最小耗费优先（优先队列式分支限界）

相同点：

- 都要在解分支树上进行搜索，构造解空间树的过程是一样的

### 1.2

> 数学建模。p.128

1. **问题转化**：将环保投资问题建模为 0-1 背包问题模型。
2. **变量定义**：$x_i \in \{0,1\}$ 表示是否投资第 $i$ 个方案（1=投资，0=不投资）。
3. **目标函数**：最大化总减碳量 $\max \sum_{i=1}^{3} v_i x_i$（$v_i$ 为减碳量）。
4. **约束条件**：总成本 $\sum_{i=1}^{3} w_i x_i \leq 30$（$w_i$ 为成本）。
5. **结论**：减碳量等效为背包"价值"，成本等效为"重量"，投资上限 30 等效为背包容量。

> 队列式分支限界法求解过程？最大减碳量？最优方案组合？

1. **构造解空间树**：三层二叉树（左分支=选方案，右分支=不选方案）。
2. **搜索过程**：
    - 扩展根节点 A → 生成 B（选方案 1，成本 16≤30）、C（不选方案 1，成本 0）。活结点表：[B, C]。
    - 扩展 B → 生成 D（选方案 2，成本 16+15=31>30，不可行）、E（不选方案 2，成本 16）。活结点表：[C, E]。
    - 扩展 C → 生成 F（选方案 2，成本 15）、G（不选方案 2，成本 0）。活结点表：[E, F, G]。
    - 扩展 E → 生成 J（选方案 3，成本 16+15=31>30，不可行）、K（不选方案 3，成本 16）。K 为叶子节点，减碳量=45。活结点表：[F, G]。
    - 扩展 F → 生成 L（选方案 3，成本 15+15=30）、M（不选方案 3，成本 15）。L 为叶子节点，减碳量=25+25=50。活结点表：[G, M]。
    - 扩展 G → 生成 N（选方案 3，成本 15）、O（不选方案 3，成本 0）。N 减碳量=25，O 减碳量=0。
3. **最优值（最大减碳量）**：50 万吨
4. **最优解（最优方案组合）**：选方案 2 和方案 3，即 $x = [0,1,1]$

![](./assets/009.png)

### 1.3

> 回溯法编程实现，找这个方案的最大减碳量以及最优方案组合。

```cpp [回溯函数]
void Backtrack(int i) {
    // 如果到达叶子节点
    if (i > n) { 
        bestp = cp; 
        return; 
    }

    // 进入左子树
    if (cw + w[i] <= c) {
        cw += w[i];
        cp += p[i];
        Backtrack(i + 1);
        cw -= w[i];
        cp -= p[i];
    }

    // 进入右子树
    if (Bound(i + 1) > bestp) {
        Backtrack(i + 1);
    }
}
```

```cpp [限界函数]
private static double Bound(int i) {
    // 计算剩余容量
    double cleft = c - cw;  

    double bound = cp;

    // 以物品单位重量价值递减序装入物品
    while (i <= n && w[i] <= cleft) {
        cleft -= w[i];
        bound += p[i];
        i++;
    }

    // 装满背包
    if (i <= n) {
        bound += p[i] / w[i] * cleft; 
    }

    return bound;
}
```

## 第二大题

::: tip 情景

贪心算法（哈夫曼编码应用）

**题目背景**

对 4 类垃圾编码，出现频率：

| 编号 | 垃圾类型 | 频率 |
| ---- | -------- | ---- |
| 1    | 可回收物 | 45%  |
| 2    | 厨余垃圾 | 30%  |
| 3    | 有害垃圾 | 15%  |
| 4    | 其他垃圾 | 10%  |

:::

### 2.1

> 贪心算法的原理是什么？

贪心算法是一种通过每一步做出局部最优选择，以期望获得全局最优解的算法策略。其基本原理如下：

1. **贪心选择性质**：算法在每一步中做出当前状态下看起来最优的选择，而不考虑全局。每次都选择当前最优解，期望最终能导致全局最优解。

2. **最优子结构**：问题的最优解包含其子问题的最优解。这意味着每一步做出的局部最优选择最终能构成全局最优解。

3. **无后效性**：一旦做出选择，不再回溯。贪心算法做出决策后不会重新考虑之前的选择。

4. **迭代决策过程**：
    - 将问题分解为若干个子问题
    - 对每个子问题做出局部最优选择
    - 将所有局部最优选择组合，形成最终解

5. **构造方式**：通常通过某种度量标准（如价值、权重、距离等）对候选解进行排序，然后按此顺序选择满足约束条件的元素。

贪心算法适用于能通过局部最优选择达到全局最优解的问题，但并非所有问题都适合使用贪心策略。与动态规划相比，贪心算法更高效（时间复杂度通常较低），但求解范围更窄。

> 哈夫曼编码原理是什么？

1. **变长编码：** 哈夫曼编码是一种变长编码方式。出现频率高的字符分配较短的编码，出现频率低的字符分配较长的编码。

2. **频率排序：** 首先将字符按照出现频率从小到大排序。

3. **构造哈夫曼树：**
    - 每次选取频率最小的两个节点。
    - 创建一个父节点，其频率等于这两个子节点频率之和。
    - 将该父节点按照频率大小重新插入到排序好的节点队列中。
    - 重复以上步骤，直到队列中只剩下一个节点，这个节点就是哈夫曼树的根节点。

4. **编码：** 在哈夫曼树上，从根节点开始，对左分支编码为“0”，对右分支编码为“1”，直到到达叶子节点（代表一个字符），路径上的 0 和 1 组成的字符串就是该字符的哈夫曼编码。

> 定长编码的原理是什么？

定长编码也称为等长编码，是一种数据编码方式，其中每个字符或符号都用固定长度的二进制位来表示。

定长编码计算方式：

1. 确定字符集大小 $N$（需编码的不同字符总数）。

2. 计算最小编码位长 $L$：$2^L \geqslant N$
    - 等价对数形式：$L = \lceil \log_2 N \rceil$，其中 $\lceil \cdot \rceil$ 表示向上取整函数。

### 2.2

> 构造哈夫曼树及编码，写出具体的构造过程，写出每种垃圾名称的具体编码。

1. **构造过程**：
    - 初始节点：其他 (10%)、有害 (15%)、厨余 (30%)、可回收 (45%)。
    - 合并其他 (10%) + 有害 (15%) → 节点 A(25%)。
    - 合并 A(25%) + 厨余 (30%) → 节点 B(55%)。
    - 合并 B(55%) + 可回收 (45%) → 根节点 (100%)。

    ![](./assets/010.png)

2. **编码结果**：
    - 可回收物：`0`
    - 厨余垃圾：`11`
    - 有害垃圾：`101`
    - 其他垃圾：`100`

### 2.3

**编码长度与节省比例计算**

1. **定长编码**：
    - 4 种类型需 2 位二进制（$2^2=4$），总码长 = $2 \times 10000 = 20000$ 位（假设处理 1 万次）。
2. **哈夫曼编码**：
    - 可回收物：1 位 × 4500 次 = 4500 位
    - 厨余垃圾：2 位 × 3000 次 = 6000 位
    - 有害垃圾：3 位 × 1500 次 = 4500 位
    - 其他垃圾：3 位 × 1000 次 = 3000 位
    - 总码长 = $4500 + 6000 + 4500 + 3000 = 18000$ 位。
3. **节省比例**：
    - 节省位数 = $20000 - 18000 = 2000$ 位
    - 节省比例 = $2000 / 20000 = 10\%$。

## 第三大题

::: tip 情景

动态规划（多阶段决策问题）

**题目背景**

求图 3-16 中节点 1 到 10 的最短路径（边权已知）。

:::

### 3.1

> 动态规划的原理是什么？p.41

1. 找出最优解的性质并描绘其结构特征（建立状态转移方程）。
2. 递归的定义最优值，用递归的思想填表。
3. 以自底向上的方式去计算最优值，构造最优解。

> 建立状态转移方程

1. **定义**：
    - $f[s]$：从节点 1 到节点 $s$ 的最短距离
    - $p[s]$：节点 $s$ 的前驱节点
    - $s$：当前节点
    - $x$：节点 $s$ 的前驱节点
    - $c(x, s)$：$x$ 到 $s$ 的边
2. **转移方程分段函数**：

    $$
    f[s] =
    \begin{cases}
    0 & \text{若 } s = 1 & \text{(起点)} \\
    \min \big\{ f[x] + c(x, s) \big\} & \text{若 } s \neq 1 & \text{(其他节点)}
    \end{cases}
    $$

### 3.2

**填表计算最优值**

| 节点 | $f[s]$ | $p[s]$ | 计算过程                                         |
| ---- | ---------- | ---------- | ------------------------------------------------ |
| 1    | 0          | -          | 边界                                             |
| 2    | 4          | 1          | $f[1] + 4$                                   |
| 3    | 2          | 1          | $f[1] + 2$                                   |
| 4    | 3          | 1          | $f[1] + 3$                                   |
| 5    | 8          | 3          | $\min(f[2]+10=14, f[3]+6=8) \to 8$             |
| 6    | 6          | 4          | $\min(f[2]+9=13, f[3]+7=9, f[4]+3=6) \to 6$    |
| 7    | 11         | 4          | $\min(f[3]+10=12, f[4]+8=11) \to 11$           |
| 8    | 12         | 7          | $\min(f[5]+4=12, f[6]+9=15, f[7]+5=16) \to 12$ |
| 9    | 12         | 6          | $\min(f[5]+8=16, f[6]+6=12, f[7]+4=15) \to 12$ |
| 10   | 16         | 9          | $\min(f[8]+8=20, f[9]+4=16) \to 16$            |

### 3.3

**最优解构造**

1. **最短路径长度**：16。
2. **路径**：
    - $10 \xleftarrow{p[10]=9} 9 \xleftarrow{p[9]=6} 6 \xleftarrow{p[6]=4} 4 \xleftarrow{p[4]=1} 1$
    - 即 $1 \to 4 \to 6 \to 9 \to 10$。

## 第四大题

::: tip 情景

分治法（大整数乘法）

**题目背景**

用分治法计算两个 8 位数乘法（如 $X = 12345678$，$Y = 56784321$)。

:::

### 4.1

> 普通乘法复杂度

1. **算法**：每位相乘，复杂度 $O(n^2)$。

> 分治法原理及优化

1. **分治步骤**：
    - 将 $X，Y$ 拆分为两半（$k = n/2 = 4$ 位）：
      - $X = A \times 10^k + B$（$A=1234$，$B=5678$)
      - $Y = C \times 10^k + D$（$C=5678$，$D=4321$)
    - 原始计算：$XY = AC \cdot 10^{2k} + (AD + BC) \cdot 10^k + BD$（需 4 次乘法）。
2. **优化（减少乘法次数）**：
    - 关键点：
        $$
        \begin{align*}
        (AD + BC) &= (AC + AD + BC + BD) - AC - BD \\
        &= A(C+D) + B(C+D) - AC - BD \\
        &= (A+B)(C+D) - AC - BD
        \end{align*}
        $$
    - 公式：$XY = AC \cdot 10^{2k} + [(A+B)(C+D) - AC - BD] \cdot 10^k + BD$
    - 乘法次数：3 次（计算 $AC$，$BD$，$(A+B)(C+D)$)。

### 4.2

> 复杂度对比

1. **优化前**：$T(n) = 4T(n/2) + O(n)$，解得 $T(n) = O(n^2)$。
2. **优化后**：$T(n) = 3T(n/2) + O(n)$，解得 $T(n) = O(n^{\log_2 3}) \approx O(n^{1.585})$。
3. **结论**：优化后效率显著提升（指数级降低）。

## 总结

<iframe src="/XASYU/Second/2025-07-01/00.算法分析与设计.html" width="100%" height="600" style="border:none;"></iframe>
