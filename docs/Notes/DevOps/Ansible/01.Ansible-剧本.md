# Ansible 剧本

## Ad-Hoc 模式常用模块

在编写复杂的 Playbook 之前，我们先回顾一些在 Ad-Hoc 模式下常用的模块。熟练掌握这些模块是编写剧本的基础。

### `apt` 模块

用于管理基于 Debian/Ubuntu 系统的软件包。对于 CentOS/RHEL 系统，应使用 `yum` 或 `dnf` 模块。

**常用参数：**

| 参数    | 说明                                               |
| :------ | :------------------------------------------------- |
| `name`  | **必须**，指定软件包名称                           |
| `state` | `present` 或 `latest` (安装/更新)，`absent` (卸载) |

**示例：**

```bash
# 安装最新版本的 net-tools
ansible web -m apt -a "name=net-tools state=latest"

# 卸载 net-tools
ansible web -m apt -a "name=net-tools state=absent"
```

### `systemd` 模块

用于管理系统服务。此模块依赖于 systemd，适用于通过包管理器安装的服务。

**常用参数：**

| 参数      | 说明                                                                      |
| :-------- | :------------------------------------------------------------------------ |
| `name`    | **必须**，指定服务名称                                                    |
| `state`   | `started` (启动)、`stopped` (停止)、`restarted` (重启)、`reloaded` (重载) |
| `enabled` | `yes` (开机自启)、`no` (禁止开机自启)                                     |

**示例：**

```bash
# 1. 安装 nginx
ansible web -m apt -a "name=nginx state=latest"

# 2. 启动 nginx 服务
ansible web -m systemd -a "name=nginx state=started"

# 3. 设置 nginx 开机自启
ansible web -m systemd -a "name=nginx enabled=yes"
```

### `archive` 模块

用于在远程主机上创建压缩文件。

**支持格式：** `gz` (默认), `bz2`, `tar`, `xz`, `zip`

**示例：**

```bash
# 将远程主机的 /etc 目录压缩为 tgz 格式
ansible web -m archive -a "path=/etc dest=/opt/etc.tgz format=gz"

# 将远程主机的 /var/log 目录压缩为 zip 格式
ansible web -m archive -a "path=/var/log dest=/tmp/log.zip format=zip"
```

### `unarchive` 模块

用于在远程主机上解压文件。也可以将本地压缩包推送到远程主机并解压。

**常用参数：**

| 参数         | 说明                                                           |
| :----------- | :------------------------------------------------------------- |
| `src`        | 源文件路径                                                     |
| `dest`       | **必须**，目标目录路径                                         |
| `remote_src` | `yes` 表示 `src` 是远程路径，`no` (默认) 表示 `src` 是本地路径 |

**示例：**

```bash
# 解压远程主机上的文件
ansible web -m unarchive -a "src=/opt/app.tgz dest=/opt/ remote_src=yes"

# 将本地压缩包上传并解压到远程主机
ansible web -m unarchive -a "src=/local/path/app.tgz dest=/opt/"
```

## Ansible Playbook 简介

虽然 Ad-Hoc 命令方便快捷，但它们不可复用，适合执行临时的、一次性的任务。

对于需要重复执行、涉及多步骤的复杂任务（如应用部署、配置管理），则需要使用 **Playbook**。

Playbook 是 Ansible 的配置、部署和编排语言。它们通过 YAML 格式的文件来描述一系列有序的任务，从而实现自动化。

**Playbook 优势：**

- **可重复性**：编写一次，随处运行。
- **版本控制**：可将剧本文件纳入 Git 等版本控制系统，追踪变更。
- **功能强大**：支持变量、循环、条件判断、模板、角色等高级功能。
- **易于阅读**：YAML 语法简洁明了，结构清晰。

## YAML 语法基础

Playbook 使用 YAML 格式编写，需要遵循以下基本规则：

1. **层级关系**：使用空格进行缩进表示层级，通常为 2 个空格。**严禁使用 Tab 键**。
2. **冒号**：键值对的冒号 (`:`) 后面必须跟一个空格。
3. **短横线**：列表项使用短横线 (`-`) 开头，短横线后必须跟一个空格。
4. **文件扩展名**：文件名通常以 `.yml` 或 `.yaml` 结尾。

## 编写第一个 Playbook

一个基本的 Playbook 包含 `hosts` 和 `tasks` 两个关键部分。

- `hosts`: 定义剧本在哪个或哪些主机上执行。
- `tasks`: 定义一系列要执行的任务。

**示例：安装并启动 Nginx**

对比 Ad-Hoc 命令：

```bash
ansible web -m apt -a "name=nginx state=latest"
ansible web -m systemd -a "name=nginx state=started"
```

使用 Playbook (例如 `nginx.yml`):

```yaml
- hosts: web
  tasks:
    - name: 安装 Nginx
      apt:
        name: nginx
        state: latest

    - name: 启动 Nginx 服务
      systemd:
        name: nginx
        state: started
        enabled: yes
```

**执行 Playbook:**

```bash
ansible-playbook nginx.yml
```

## Playbook 高级用法

### 循环 (`loop`)

当需要对一组项目执行相同任务时，可以使用循环来避免重复编写任务。

**示例：批量创建用户**

```yaml
- hosts: web
  tasks:
    - name: 批量创建用户
      user:
        name: "{{ item }}"
        state: present
      loop:
        - testuser1
        - testuser2
        - testuser3
```

### 变量 (`vars`)

变量用于存储值，使 Playbook 更加灵活和可复用。

**示例：使用变量批量安装软件**

```yaml
- hosts: web
  vars:
    packages_to_install:
      - nginx
      - wget
      - vim
      - net-tools
  tasks:
    - name: 批量安装软件包
      apt:
        name: "{{ item }}"
        state: latest
      loop: "{{ packages_to_install }}"
```

**示例：使用字典变量创建用户并指定 UID**

```yaml
- hosts: web
  vars:
    users_to_create:
      - { name: "test1", uid: "2001" }
      - { name: "test2", uid: "2002" }
  tasks:
    - name: 批量创建用户并指定 UID
      user:
        name: "{{ item.name }}"
        uid: "{{ item.uid }}"
        state: present
      loop: "{{ users_to_create }}"
```

### 注册变量 (`register`)

`register` 关键字可以将一个任务的输出结果保存到一个变量中，供后续任务使用。

**示例：捕获命令输出**

```yaml
- hosts: web
  tasks:
    - name: 查看 /opt 目录内容
      command: "ls /opt"
      register: ls_output

    - name: 显示上一个任务的输出
      debug:
        msg: "{{ ls_output.stdout_lines }}"
```
