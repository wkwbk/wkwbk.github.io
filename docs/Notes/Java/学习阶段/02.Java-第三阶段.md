# Java | 第三阶段

增强分析需求和代码实现能力，包含网络编程、反射、Mysql、JDBC 和连接池、正则表达式、Java8 和 Java11 新特性。

## 网络编程

## 反射

### 反射机制

- 基本介绍

  > 反射机制允许程序在执行期借助于 `Reflection API` 取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。
  >
  > 加载完类之后，在堆中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个 Class 对象就像一面镜子，透过这个镜子看到类的结构。

- 反射机制原理图

  ![](https://raw.githubusercontent.com/timerring/scratchpad2023/main/2023/image-20230509145140396.png)

- 反射机制可以完成

  1. 在运行时判断任意一个对象所属的类
  2. 在运行时构造任意一个类的对象
  3. 在运行时得到任意一个类所具有的成员变量和方法
  4. 在运行时调用任意一个对象的成员变量和方法
  5. 生成动态代理

- 反射相关的主要类

  1. `java.lang.Class`：代表一个类，Class 对象表示某个类加载后在堆中的对象
  2. `java.lang.reflect.Method`：代表类的方法，Method 对象表示某个类的方法
  3. `java.lang.reflect.Field`：代表类的成员变量，Field 对象表示某个类的成员变量
  4. `java.lang.reflect.Constructor`：代表类的构造方法，Constructor 对象表示构造器

  ::: details 点击查看案例演示

  ::: code-group

  ```java [test]
  import java.io.FileInputStream;
  import java.io.FileNotFoundException;
  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.Method;
  import java.util.Properties;

  public class Reflection01 {

      public static void main(String[] args) throws Exception {

          //1. 使用Properties 类, 可以读写配置文件
          Properties properties = new Properties();
          properties.load(new FileInputStream("src\\re.properties"));
          String classfullpath = properties.get("classfullpath").toString();//"com.hspedu.Cat"
          String methodName = properties.get("method").toString();//"hi"

          //2. 使用反射机制解决
          //(1) 加载类, 返回Class类型的对象cls
          Class cls = Class.forName(classfullpath);
          //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例
          Object o = cls.newInstance();
          System.out.println("o的运行类型=" + o.getClass()); //运行类型
          //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName"hi"  的方法对象
          //    即：在反射中，可以把方法视为对象（万物皆对象）
          Method method1 = cls.getMethod(methodName);
          //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法
          System.out.println("=============================");
          method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)

          // java.lang.reflect.Field: 代表类的成员变量, Field对象表示某个类的成员变量
          // getField不能得到私有的属性
          Field nameField = cls.getField("age"); //
          System.out.println(nameField.get(o)); // 传统写法 对象.成员变量 , 反射: 成员变量对象.get(对象)

          //java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象表示构造器
          //()中可以指定构造器参数类型, 返回无参构造器
          Constructor constructor = cls.getConstructor();
          System.out.println(constructor);//Cat()


          Constructor constructor2 = cls.getConstructor(String.class); //这里老师传入的 String.class 就是String类的Class对象
          System.out.println(constructor2);//Cat(String name)
      }
  }
  ```

  :::

- 反射优点和缺点

  1. 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。
  2. 缺点：使用反射基本是解释执行，对执行速度有影响。

- 反射调用优化（关闭访问检查）

  1. Method、Field 和 Constructor 对象都有 `setAccessible()` 方法。
  2. `setAccessible()` 方法是启用和禁用访问安全检查的开关。
  3. 参数值为 `true` 表示反射的对象在使用时取消访问检查，提高反射的效率，使其可以访问 `private` 修饰的构造器、方法和属性。
  4. 参数值为 `false` 则表示反射的对象执行访问检查。

### Class 类

- 基本介绍

  1. Class 也是类，因此也继承 Object 类。
  2. Class 类的对象不是 `new` 出来的，而是系统创建的。
  3. 对于某个类的 Class 对象，在内存中只有一份，因为类只加载一次。
  4. 每个类的实例都会记得自己是由哪个 Class 实例所生成。
  5. 通过 Class 对象可以完整地得到一个类的结构。
  6. Class 对象是存放在堆的。
  7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等等）。

- Class 类的常用方法

  ![](https://raw.githubusercontent.com/timerring/scratchpad2023/main/2023/image-20230509155511997.png)

  ::: details 点击查看案例演示

  ::: code-group

  ```java [test]
  import com.hspedu.Car;

  import java.lang.reflect.Field;

  /**
   * 演示Class类的常用方法
   */
  public class Class02 {
      public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException {

          String classAllPath = "com.hspedu.Car";
          //1 . 获取到Car类 对应的 Class对象
          //<?> 表示不确定的Java类型
          Class<?> cls = Class.forName(classAllPath);
          //2. 输出cls
          System.out.println(cls); //显示cls对象, 是哪个类的Class对象 com.hspedu.Car
          System.out.println(cls.getClass());//输出cls运行类型 java.lang.Class
          //3. 得到包名
          System.out.println(cls.getPackage().getName());//包名 com.hspedu
          //4. 得到全类名
          System.out.println(cls.getName()); // com.hspedu.Car
          //5. 通过cls创建对象实例
          Car car = (Car) cls.newInstance();
          System.out.println(car);//car.toString()
          //6. 通过反射获取属性 brand
          Field brand = cls.getField("brand");
          System.out.println(brand.get(car));//宝马
          //7. 通过反射给属性赋值
          brand.set(car, "奔驰");
          System.out.println(brand.get(car));//奔驰
          //8 我希望大家可以得到所有的属性(字段)
          System.out.println("=======所有的字段属性====");
          Field[] fields = cls.getFields();
          for (Field f : fields) {
              System.out.println(f.getName());//名称
          }
      }
  }
  ```

  :::

- 获取 Class 对象

  1. 已知一个类的全类名，可通过 Class 类的静态方法 `forName()` 获取，可能抛出 `ClassNotFoundException`。  
    应用场景：多用于配置文件，读取类全路径，加载类。

  2. 若已知具体的类，可通过 `类名.class` 获取，该方式最为安全可靠，程序性能最高。  
    应用场景：多用于参数传递，比如通过反射得到对应构造器对象。

  3. 已知某个类的实例，调用该实例的 `getClass()` 方法获取 Class 对象。  
    应用场景：通过创建好的对象，获取 Class 对象。

  4. 通过类加载器来获取到类的 Class 对象。

  5. 基本数据类型通过 `类型名称.class` （这个操作会自动将基本数据类型装箱成包装类）得到 Class 对象。

  6. 基本数据类型对应的包装类，可以通过 `包装类名称.TYPE` 得到 Class 对象。

  ::: details 点击查看案例演示

  ::: code-group

  ```java [test]
  import com.hspedu.Car;

  /**
   * 演示得到Class对象的各种方式(6)
  */
  public class GetClass_ {
      public static void main(String[] args) throws ClassNotFoundException {

          //1. Class.forName
          String classAllPath = "com.hspedu.Car"; //通过读取配置文件获取
          Class<?> cls1 = Class.forName(classAllPath);
          System.out.println(cls1);

          //2. 类名.class , 应用场景: 用于参数传递（例如前面通过反射得到构造器对象 传入参数就是 类名.class）
          Class cls2 = Car.class;
          System.out.println(cls2);

          //3. 对象.getClass(), 应用场景，有对象实例
          Car car = new Car();
          Class cls3 = car.getClass();
          System.out.println(cls3);

          //4. 通过类加载器【有4种类加载器】来获取到类的Class对象
          //(1)先得到类加载器 car
          ClassLoader classLoader = car.getClass().getClassLoader();
          //(2)通过类加载器得到Class对象
          Class cls4 = classLoader.loadClass(classAllPath);
          System.out.println(cls4);

          //cls1 , cls2 , cls3 , cls4 其实是同一个对象，因为一个类只能有一个class对象
          System.out.println(cls1.hashCode());
          System.out.println(cls2.hashCode());
          System.out.println(cls3.hashCode());
          System.out.println(cls4.hashCode());

          //5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象
          Class<Integer> integerClass = int.class;
          Class<Character> characterClass = char.class;
          Class<Boolean> booleanClass = boolean.class;
          System.out.println(integerClass);//int

          //6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象
          Class<Integer> type1 = Integer.TYPE;
          Class<Character> type2 = Character.TYPE; //其它包装类BOOLEAN, DOUBLE, LONG,BYTE类似
          System.out.println(type1);

          System.out.println(integerClass.hashCode());// 是同一个
          System.out.println(type1.hashCode());// 是同一个
      }
  }
  ```

  :::

- 哪些类型有 Class 对象

  1. 外部类
  2. 内部类：成员内部类、静态内部类、局部内部类、匿名内部类
  3. 接口：interface
  4. 数组
  5. 枚举：enum
  6. 注解：annotation
  7. 基本数据类型（包括 void）

  ::: details 点击查看案例演示

  ::: code-group

  ```java [test]
  import java.io.Serializable;

  /**
   * 演示哪些类型有Class对象
   */
  public class AllTypeClass {
      public static void main(String[] args) {

          Class<String> cls1 = String.class;//外部类
          Class<Serializable> cls2 = Serializable.class;//接口
          Class<Integer[]> cls3 = Integer[].class;//数组
          Class<float[][]> cls4 = float[][].class;//二维数组
          Class<Deprecated> cls5 = Deprecated.class;//注解
          Class<Thread.State> cls6 = Thread.State.class;//枚举
          Class<Long> cls7 = long.class;//基本数据类型
          Class<Void> cls8 = void.class;//void数据类型
          Class<Class> cls9 = Class.class;//

          System.out.println(cls1);
          System.out.println(cls2);
          System.out.println(cls3);
          System.out.println(cls4);
          System.out.println(cls5);
          System.out.println(cls6);
          System.out.println(cls7);
          System.out.println(cls8);
          System.out.println(cls9);
      }
  }
  ```

  :::

### 类加载

- 基本介绍

  反射机制是 Java 实现动态语言的关键，也就是通过**反射实现类动态加载**。
  - 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强。
    - 使用 `new` 创建对象时
    - 当子类被加载时，父类也加载
    - 调用类中的静态成员时
  - 动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性。
    - 通过反射创建对象

- 类加载过程图

  ![](https://raw.githubusercontent.com/timerring/scratchpad2023/main/2023/image-20230509163956778.png)

  加载后方法区存储的是类的字节码二进制文件，而堆区就创建了相应的类的 Class 对象。

- 类加载各阶段完成任务

  ![](https://raw.githubusercontent.com/timerring/scratchpad2023/main/2023/image-20230509164018419.png)

  注意：这里是针对类的加载阶段，并不是 new 的阶段，因此是针对静态成员。

#### 加载阶段

  JVM 在该阶段的主要目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的 Class 对象。

#### 连接阶段

1. 验证

    - 目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    - 包括：文件格式验证（是否以魔数 `oxcafebabe` 开头）、元数据验证、字节码验证和符号引用验证。
    - 可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。

2. 准备

    - JVM 会在该阶段对静态变量分配内存并默认初始化（对应数据类型的默认初始值，如 0、OL、null、false 等）。这些变量所使用的内存都将在方法区中进行分配。

    ::: details 点击查看案例演示

    ```java
    public class ClassLoad02 {
        public static void main(String[] args) {

        }
    }
    class A {
        //属性-成员变量-字段
        //分析类加载的链接阶段-准备 属性是如何处理
        //1. n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存
        //2. n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是20。初始化子阶段才会是20。
        //3. n3 是 static final 是 常量, 他和静态变量不一样, 因为一旦赋值就不变 因此n3 = 30
        public int n1 = 10;
        public static  int n2 = 20;
        public static final  int n3 = 30;
    }
    ```

    :::

3. 解析

    虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。这个过程是由 JVM 机自动完成的。

#### 初始化阶段

- 到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 `clinit()` 方法的过程。
- `clinit()` 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**静态变量**的赋值动作和**静态代码块**中的语句，并进行合并。
- 虚拟机会保证一个类的 `clinit()` 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `clinit()` 方法，其他线程都需要阻塞等待，直到活动线程执行 `clinit()` 方法完毕。
- 正因为有这个机制，才能保证某个类在内存中，只有一份 Class 对象。

::: details 点击查看案例演示

```java
/**
 * 演示类加载-初始化阶段
 */
public class ClassLoad03 {
    public static void main(String[] args) throws ClassNotFoundException {
        //1. 加载B类，并生成 B的class对象
        //2. 链接 num = 0
        //3. 初始化阶段
        //    依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句,并合并
        /*
                clinit() {
                // 按照顺序合并
                    System.out.println("B 静态代码块被执行");
                    //num = 300;
                    num = 100;
                }
                合并: num = 100

         */

        //new B();//类加载
        //System.out.println(B.num);//100, 如果直接使用类的静态属性，也会导致类的加载

        //看看加载类的时候，是有同步机制控制
        /*
        protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
        {
            //正因为有这个机制，才能保证某个类在内存中, 只有一份Class对象
            synchronized (getClassLoadingLock(name)) {
            //....
            }
            }
         */
        B b = new B();
    }
}

class B {
    static {
        System.out.println("B 静态代码块被执行");
        num = 300;
    }

    static int num = 100;

    //如果直接调用类的静态变量，而没有new对象，则构造器不会被执行
    public B() {//构造器
        System.out.println("B() 构造器被执行");
    }
}
```

:::

### 反射用法

- 通过反射获取类的结构信息

  | 类                            | 方法                        | 描述                                               |
  | ----------------------------- | --------------------------- | -------------------------------------------------- |
  | java.lang.Class               | `getName()`                 | 获取全类名                                         |
  |                               | `getSimpleName()`           | 获取简单类名                                       |
  |                               | `getFields()`               | 获取所有 `public` 修饰的属性，包含本类以及父类     |
  |                               | `getDeclaredFields()`       | 获取本类中所有属性                                 |
  |                               | `getMethods()`              | 获取所有 `public` 修饰的方法，包含本类以及父类     |
  |                               | `getDeclaredMethods()`      | 获取本类中所有方法                                 |
  |                               | `getConstructors()`         | 获取本类所有 `public` 修饰的构造器                 |
  |                               | `getDeclaredConstructors()` | 获取本类中所有构造器                               |
  |                               | `getPackage()`              | 以 `Package` 形式返回包信息                        |
  |                               | `getSuperClass()`           | 以 `Class` 形式返回父类信息                        |
  |                               | `getInterfaces()`           | 以 `Class[]` 形式返回接口信息                      |
  |                               | `getAnnotations()`          | 以 `Annotation[]` 形式返回注解信息                 |
  | java.lang.reflect.Field       | `getModifiers()`            | 以 `int` 形式返回修饰符                            |
  |                               | `getType()`                 | 以 `Class` 形式返回类型（属性对应类的 Class 对象） |
  |                               | `getName()`                 | 返回属性名                                         |
  | java.lang.reflect.Method      | `getModifiers()`            | 以 `int` 形式返回修饰符                            |
  |                               | `getReturnType()`           | 以 `Class` 形式获取返回类型                        |
  |                               | `getName()`                 | 返回方法名                                         |
  |                               | `getParameterTypes()`       | 以 `Class[]` 返回参数类型数组                      |
  | java.lang.reflect.Constructor | `getModifiers()`            | 以 `int` 形式返回修饰符                            |
  |                               | `getName()`                 | 返回构造器名（全类名）                             |
  |                               | `getParameterTypes()`       | 以 `Class[]` 返回参数类型数组                      |

- 通过反射创建对象

  - 方式一：调用类中的 `public` 修饰的无参构造器
  - 方式二：调用类中的指定构造器

  | 类                            | 方法                                     | 描述                                         |
  | ----------------------------- | ---------------------------------------- | -------------------------------------------- |
  | java.lang.Class               | `newInstance()`                          | 调用类中的无参构造器，获取对应类的对象       |
  |                               | `getConstructor(Class... clazz)`         | 根据参数列表，获取对应的 `public` 构造器对象 |
  |                               | `getDeclaredConstructor(Class... clazz)` | 根据参数列表，获取对应的所有构造器对象       |
  | java.lang.reflect.Constructor | `setAccessible()`                        | 暴破                                         |
  |                               | `newInstance(Object... obj)`             | 调用构造器                                   |

- 通过反射访问类中的成员

  TODO

## Mysql

## JDBC 和连接池

## 正则表达式
