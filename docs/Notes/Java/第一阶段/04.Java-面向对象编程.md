# Java | 面向对象编程

## 基本概念

- **类**：类是具有相同属性和行为的一组对象的抽象，是对象的模板。
- **对象**：现实世界中任何事物都可以看作对象，对象是拥有状态和行为的实体。
- **属性**：对象的状态，例如颜色、大小、重量等。
- **行为**：对象可以执行的操作，例如移动、说话、吃饭等。
- **封装**：将对象的属性和行为组合在一起，并控制对内部数据的访问。
- **继承**：子类继承父类的属性和行为，并可以扩展或修改它们。
- **多态**：允许使用父类类型的引用来引用子类对象，从而实现不同的行为。

## 类与对象

- **定义类**：使用 `class` 关键字定义类，并在类中声明属性和方法。

    ```java
    public class Person {
        String name;    // 姓名
        int age;        // 年龄

        // 构造方法
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        // 方法
        public void sayHello() {
            System.out.println("Hello, my name is " + name + ", I am " + age + " years old.");
        }
    }
    ```

- **创建对象**：使用 `new` 关键字创建类的对象。

    ```java
    Person person = new Person("Alice", 30);
    person.sayHello();  // 输出：Hello, my name is Alice, I am 30 years old.
    ```

## 构造方法

- **作用**：用于初始化对象的状态。
- **特点**：
  - 方法名与类名相同。
  - 没有返回值类型。
  - 可以有参数，也可以没有参数（默认构造方法）。
- **示例**：

    ```java
    public class Dog {
        String breed;

        // 默认构造方法
        public Dog() {
            breed = "Unknown";
        }

        // 带参数的构造方法
        public Dog(String breed) {
            this.breed = breed;
        }
    }
    ```

## 访问修饰符

- **作用**：控制类、属性和方法的访问权限。
- **类型**：
  - `public`：公共的，任何地方都可以访问。
  - `protected`：受保护的，同一个包中的类或子类可以访问。
  - `private`：私有的，只有当前类可以访问。
  - `default`（不写）：默认的，同一个包中的类可以访问。

## 封装

- **目的**：隐藏对象的内部实现细节，只暴露必要的接口给外部使用。
- **实现**：
  - 将属性设置为 `private`。
  - 提供 `public` 的 `getter` 和 `setter` 方法来访问和修改属性。

    ```java
    public class Student {
        private String name;
        private int age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            if (age > 0) {
                this.age = age;
            }
        }
    }
    ```

## 继承

- **概念**：子类继承父类的属性和行为，并可以扩展或修改它们。
- **关键字**：`extends`
- **特点**：
  - Java 只支持单继承，一个类只能继承一个父类。
  - 子类可以访问父类的 `public` 和 `protected` 成员。
  - 子类可以重写（override）父类的方法。
- **示例**：

    ```java
    public class Animal {
        String name;

        public void eat() {
            System.out.println("Animal is eating.");
        }
    }

    public class Dog extends Animal {
        public void bark() {
            System.out.println("Dog is barking.");
        }

        @Override
        public void eat() {
            System.out.println("Dog is eating.");
        }
    }
    ```

## 多态

- **概念**：允许使用父类类型的引用来引用子类对象，从而实现不同的行为。
- **实现方式**：
  - **方法重写（Override）**：子类重写父类的方法，实现不同的行为。
  - **方法重载（Overload）**：在同一个类中定义多个同名方法，但参数列表不同。
- **示例**：

    ```java
    public class Animal {
        public void makeSound() {
            System.out.println("Animal makes a sound.");
        }
    }

    public class Cat extends Animal {
        @Override
        public void makeSound() {
            System.out.println("Cat meows.");
        }
    }

    public class Dog extends Animal {
        @Override
        public void makeSound() {
            System.out.println("Dog barks.");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Animal animal1 = new Animal();
            Animal animal2 = new Cat();
            Animal animal3 = new Dog();

            animal1.makeSound();    // 输出：Animal makes a sound.
            animal2.makeSound();    // 输出：Cat meows.
            animal3.makeSound();    // 输出：Dog barks.
        }
    }
    ```

## 抽象类和接口

- **抽象类**：
  - 使用 `abstract` 关键字定义。
  - 可以包含抽象方法（没有实现的方法）和非抽象方法。
  - 不能被实例化，只能被继承。
  - 子类必须实现抽象类中的所有抽象方法，除非子类也是抽象类。
- **接口**：
  - 使用 `interface` 关键字定义。
  - 只能包含抽象方法（默认是 `public abstract`）和常量（默认是 `public static final`）。
  - 可以被多个类实现（implements）。
  - 接口之间可以继承（extends），一个接口可以继承多个接口。
- **示例**：

    ```java
    // 抽象类
    public abstract class Shape {
        public abstract double getArea();

        public void display() {
            System.out.println("This is a shape.");
        }
    }

    // 接口
    public interface Drawable {
        void draw();
    }

    public class Circle extends Shape implements Drawable {
        private double radius;

        public Circle(double radius) {
            this.radius = radius;
        }

        @Override
        public double getArea() {
            return Math.PI * radius * radius;
        }

        @Override
        public void draw() {
            System.out.println("Drawing a circle.");
        }
    }
    ```

## 内部类

- **概念**：在一个类内部定义的类。
- **类型**：
  - **成员内部类**：作为外部类的成员存在，可以访问外部类的所有成员（包括 `private`）。
  - **静态内部类**：使用 `static` 关键字定义，可以访问外部类的静态成员。
  - **局部内部类**：在方法或代码块中定义的类，只能在当前方法或代码块中使用。
  - **匿名内部类**：没有类名的内部类，通常用于简化代码。
- **示例**：

    ```java
    public class OuterClass {
        private int outerData = 100;

        // 成员内部类
        public class InnerClass {
            public void display() {
                System.out.println("Outer data: " + outerData);
            }
        }

        // 静态内部类
        public static class StaticInnerClass {
            public void display() {
                System.out.println("This is a static inner class.");
            }
        }

        public void test() {
            // 局部内部类
            class LocalInnerClass {
                public void display() {
                    System.out.println("This is a local inner class.");
                }
            }

            LocalInnerClass localInner = new LocalInnerClass();
            localInner.display();

            // 匿名内部类
            Drawable drawable = new Drawable() {
                @Override
                public void draw() {
                    System.out.println("Drawing something anonymously.");
                }
            };
            drawable.draw();
        }

        public static void main(String[] args) {
            OuterClass outer = new OuterClass();
            OuterClass.InnerClass inner = outer.new InnerClass();
            inner.display();

            OuterClass.StaticInnerClass staticInner = new OuterClass.StaticInnerClass();
            staticInner.display();

            outer.test();
        }
    }

    interface Drawable {
        void draw();
    }
    ```

## Lambda 表达式

- **概念**：一种简洁的表示匿名函数的方式。
- **语法**：`(parameters) -> expression` 或 `(parameters) -> { statements; }`
- **特点**：
  - 可以作为参数传递给方法。
  - 可以访问外部的 final 变量。
- **示例**：

    ```java
    import java.util.Arrays;
    import java.util.List;

    public class Main {
        public static void main(String[] args) {
            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

            // 使用 Lambda 表达式遍历集合
            numbers.forEach(number -> System.out.println(number));

            // 使用 Lambda 表达式过滤集合
            numbers.stream()
                    .filter(number -> number % 2 == 0)
                    .forEach(number -> System.out.println("Even number: " + number));
        }
    }
    ```
