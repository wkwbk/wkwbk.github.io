# 高级部分

## 类变量

- 基本概念

  - 类变量也叫静态变量/静态属性。
  - 定义语法：`访问修饰符 static 数据类型 变量名`
  - 类变量是该类的所有对象共享的变量。任何一个该类的对象访问它时，得到的是相同的值，修改它时也是修改的同一个变量。
  - 类变量在类加载时就已经生成，可以不创建对象实例，直接通过 `类名.类变量名` 访问。

- 注意事项

  - 访问方式：类变量可以通过 `类名.类变量名` 或 `对象名.类变量名` 访问，推荐使用 `类名.类变量名`。
  - 使用场景：当需要让某个类的所有对象共享一个变量时，考虑使用类变量。
  - 类变量与实例变量：类变量是所有对象共享的，而实例变量是每个对象独享的。
  - 生命周期：类变量在类加载时初始化，类卸载时销毁，生命周期随类的加载与卸载而变化。

## 类方法

- 基本概念

  - 类方法也叫静态方法。
  - 定义语法：`访问修饰符 static 数据返回类型 方法名() {}`
  - 类方法是与类相关联的，可以不创建实例直接调用的方法。
  - 如果希望在不创建实例的情况下调用某个方法（例如作为工具方法使用），可以将方法定义为静态方法。

- 注意事项

  - 访问方式：类方法可以通过 `类名.类方法名` 或 `对象名.类方法名` 访问。
  - 类方法与普通方法：类方法和普通方法都是随类加载而加载，存储在方法区。类方法没有隐式的 `this` 参数，普通方法会隐式携带 `this`。
  - 调用规则：类方法可以通过类名或对象名调用。普通方法需要通过对象名调用，不能通过类名调用。
  - 关键字限制：类方法中不能使用 `this` 和 `super`，因为它们与具体的对象实例相关。
  - 访问权限：类方法只能访问类变量和其他静态方法。普通方法既可以访问静态成员，也可以访问非静态成员。

- `main` 方法

  - `main` 方法由 JVM 调用，是程序的入口点。
  - 由于 JVM 需要从外部调用 `main` 方法，所以该方法必须是 `public`，保证能够被外部访问。
  - 由于 JVM 不需要创建类的实例对象就能调用 `main` 方法，所以该方法必须是 `static`。
  - `main` 方法接收一个 `String` 类型的数组 `args`，该数组存储了执行 Java 程序时传入的命令行参数。
  - `main` 方法可以访问静态方法和静态变量，但无法直接访问实例变量和实例方法，必须先创建对象实例。

## final 关键字

- 基本介绍

  - `final` 的意思是“最终的”，表示一旦被赋值或定义后，不能再改变。
  - `final` 可以修饰类、属性、方法和局部变量。

- 使用场景

  - **修饰类**：当不希望类被继承时，使用 `final` 修饰。
  - **修饰方法**：当不希望子类重写父类的方法时，使用 `final` 修饰。
  - **修饰属性**：当不希望属性的值被修改时，使用 `final` 修饰。
  - **修饰局部变量**：当不希望局部变量被修改时，使用 `final` 修饰。

- 注意事项

  - `final` 修饰的属性又叫常量，一般用大写来命名。
  - `final` 属性必须在定义时、构造器中或代码块中初始化，赋值后不能再修改。
  - 如果 `final` 修饰的属性是静态的，那么只能在定义时或静态代码块中初始化。
  - `final` 类不能被继承，但可以实例化对象。
  - `final` 方法不能被子类重写，但可以被继承和调用。
  - `final` 不能修饰构造方法。
  - `final` 和 `static` 一起使用可以提高效率，因为它不会引起类加载，编译器进行了优化。

## 抽象类

> 当父类中的某些方法需要声明，但不确定具体实现时，可以将这些方法声明为抽象方法，从而将该类声明为抽象类。
>
> 抽象类是为了设计而存在的，它定义了一个框架或蓝图，子类负责具体实现。抽象类多用于设计模式和框架中。
>
> 抽象类的目的是为了被继承和扩展，而不是直接被实例化。

```java
abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    // 抽象方法，没有方法体
    public abstract void eat();
}
```

- 基本概念

  - **抽象类**：使用 `abstract` 关键字修饰的类，表示该类是抽象类。抽象类通常包含抽象方法，并且必须被继承。
  - **抽象方法**：使用 `abstract` 修饰的方法，没有方法体。表示该方法需要在子类中实现。

- 注意事项

  - `abstract` 只能修饰类和方法，不能修饰属性或其他成员。
  - 抽象类不能被直接实例化。只能通过继承抽象类来创建子类实例。
  - 抽象类可以有构造器、非抽象方法、静态属性等，仍然可以包含具体的实现。
  - 如果一个类包含抽象方法，该类必须声明为抽象类。
  - 如果子类继承了抽象类，子类必须实现所有的抽象方法，除非子类本身也声明为抽象类。
  - 抽象方法不能有方法体，且不能使用 `private`、`final` 和 `static` 修饰，因为这些修饰符与方法重写冲突。

## 接口

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。
>
> 特别说明：JDK8.0 后接口类可以有静态方法 `static`，默认方法 `default`，也就是说接口中可以有方法的具体实现入。

```java
interface 接口名 {
    // 接口可以包含常量、抽象方法
    // 接口中的方法默认是抽象的，也可以包含静态方法和默认方法（JDK8 及以上）
}

class 类名 implements 接口 {
    // 实现接口中声明的所有抽象方法
}
```

- 基本概念

  - 接口是更加抽象的类，仅定义了一些方法签名（即方法的名称、参数、返回类型），而没有具体实现。
  - 接口中的方法不能有方法体，所有的方法都是抽象的。
  - 接口定义了规范，类根据规范实现功能，从而实现高内聚低耦合的设计。

- 注意事项

  - 接口不能创建实例，它只定义了规范，必须通过实现该接口的类来完成具体的功能实现。
  - 接口中的方法默认是 `public`，且无需使用 `abstract` 修饰。
  - 一个普通类实现接口时，必须实现接口中的所有抽象方法。
  - 如果一个类没有实现接口的所有方法，必须将该类声明为抽象类。
  - 接口中的属性只能是 `public static final`（即常量），且必须在声明时初始化。
  - 接口可以继承多个其他接口，但接口不能继承类。一个类可以实现多个接口。
  - 接口的修饰符可以是 `public` 或默认修饰符，不能使用 `protected` 或 `private`。

- 实现接口与继承类的区别

  - **继承类**：当子类继承父类时，子类自动继承了父类的功能，并可以扩展或修改这些功能。继承主要解决代码复用和可维护性。
  - **实现接口**：接口的主要作用是定义规范，允许不同的类按照相同的规范提供不同的实现。接口可以让不同的类通过实现相同的方法来提供不同的功能，灵活性更高。
  - 继承满足 is-a 关系：例如，“狗”是“动物”，它继承了动物类。
  - 接口满足 like-a 关系：例如，某个类“会走”或者“能飞”，它们并不一定是同一个类别的子类，但都可以实现“可走”或者“可飞”的接口。

- 接口的多态特性

  - 多态数组：通过接口数组，可以存放多种实现了该接口的对象，这样可以灵活地处理不同类型的对象。
  - 多态参数：接口的多态体现在方法的参数类型为接口类型时，可以传入实现了该接口的任意类的实例。
  - 接口多态传递现象：如果接口 `B` 继承了接口 `A`，那么 `A` 接口类型的引用可以指向实现了 `B` 接口的类的对象。
