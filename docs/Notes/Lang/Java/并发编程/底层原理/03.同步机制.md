# 同步机制

`volatile` 是 Java 虚拟机提供的一种轻量级的同步机制，它主要解决了 JMM（Java Memory Model）中的三大特性问题：

1. **保证可见性**：当一个线程修改了 `volatile` 变量的值，这个新值会立即被刷新到主内存中；当其他线程读取这个 `volatile` 变量时，它们会强制从主内存中获取最新值，而不是使用自己工作内存中的旧副本。
2. **不保证原子性**：`volatile` 变量的读写操作本身是原子的（单个读或单个写），但复合操作（如 `i++`，它包含 `读取 i`、`i 加 1`、`写入 i` 三个步骤）不保证原子性。在复合操作中，仍然可能存在竞态条件。
3. **保证有序性**：`volatile` 关键字可以禁止 JVM 编译器和 CPU 对其修饰的变量进行指令重排序。它通过插入内存屏障来确保特定操作的执行顺序。

性能对比：

- 对 `volatile` 变量进行读操作，与普通变量的读取性能差异不大。
- 对 `volatile` 变量进行写操作，会相对慢一些，因为 JVM 需要插入内存屏障，这会增加一些开销。然而，这种开销通常比使用 `synchronized` 或 `Lock` 来加锁的开销要小得多。

`synchronized` 为什么能保证有序性和可见性？

- 有序性：`synchronized` 块内的代码，由于在任何时刻只有一个线程能获取锁并执行，因此在逻辑上形成了单线程执行的错觉。对于单线程，指令重排序会确保不改变程序的最终执行结果。所以，synchronized 隐式地保证了其保护的代码块的有序性。
- 可见性：
  - 线程在获取锁时，会清空工作内存中所有共享变量的副本，强制从主内存中重新读取最新的值。
  - 线程在释放锁时，必须把其工作内存中对共享变量的最新修改刷新到主内存中。通过这种机制，`synchronized` 确保了共享变量在加锁和解锁时的可见性。

## 指令重排

指令重排是编译器和处理器为了优化程序性能，在不改变单线程程序执行结果的前提下，调整指令执行顺序的一种行为。

`volatile` 修饰的变量，可以禁用针对该变量的指令重排。

指令重排示例 1 (单线程)：

```java
public void mySort() {
    int x = 11; // 语句 1
    int y = 12; // 语句 2
    x = x + 5;  // 语句 3 (依赖于 x)
    y = x - x;  // 语句 4 (依赖于 x)
}
```

- 可能的执行顺序：`1 -> 2 -> 3 -> 4` 或 `2 -> 1 -> 3 -> 4`。
- 不能出现 `4 -> 3 -> 2 -> 1`，因为语句 3 依赖语句 1 的 `x` 初始化，语句 4 依赖语句 3 的 `x` 更新。这种依赖关系会阻止重排。

指令重排示例 2 (多线程与可见性)：

```java
int num = 0;
boolean ready = false;
// 线程 1 执行此方法（消费者）
public void actor1(I_Result r) {
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
// 线程 2 执行此方法（生产者）
public void actor2(I_Result r) {
    num = 2;        // 写入 num (语句 A)
    ready = true;   // 写入 ready (语句 B)
}
```

- 情况一：线程 1 先执行，`ready = false`，结果 `r.r1 = 1`。
- 情况二：线程 2 先执行 `num = 2`，但还没来得及执行 `ready = true`，线程 1 执行，`ready` 仍为 `false`，结果 `r.r1 = 1`。
- 情况三：线程 2 先执行 `num = 2` 和 `ready = true` (且都同步到主内存)，线程 1 执行，进入 `if` 分支，结果 `r.r1 = 4`。
- 情况四：线程 2 执行 `ready = true` (语句 B) 先于 `num = 2` (语句 A) 或者 `num` 的写入未同步。此时线程 1 看到 `ready` 为 `true`，但 `num` 仍为旧值 `0`，结果 `r.r1 = 0`。这就是指令重排和可见性问题导致的错误。

## 底层原理

### 缓存一致

使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据

lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

内存屏障有三个作用：

- 确保对内存的读 - 改 - 写操作原子执行
- 阻止屏障两侧的指令重排序
- 强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效

### 内存屏障

保证**可见性**：

- 写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中

    ```java
    public void actor2(I_Result r) {
        num = 2;
        ready = true; // ready 是 volatile 赋值带写屏障
        // 写屏障
    }
    ```

- 读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据

    ```java
    public void actor1(I_Result r) {
        // 读屏障
        // ready 是 volatile 读取值带读屏障
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;" />

- 全能屏障：mfence（modify/mix Barrier），兼具 sfence 和 lfence 的功能

保证**有序性**：

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

不能解决指令交错：

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前

- 有序性的保证也只是保证了本线程内相关代码不被重排序

    ```java
    volatile i = 0;
    new Thread(() -> {i++});
    new Thread(() -> {i--});
    ```

    i++ 反编译后的指令：

    ```java
    0: iconst_1         // 当 int 取值 -1~5 时，JVM 采用 iconst 指令将常量压入栈中
    1: istore_1         // 将操作数栈顶数据弹出，存入局部变量表的 slot 1
    2: iinc     1, 1
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;" />

### 交互规则

对于 volatile 修饰的变量：

- 线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载
- 线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存
- 线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排

## 双端检锁

### 检锁机制

Double-Checked Locking：双端检锁机制

DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    
    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2，这里的判断不是线程安全的
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化
                if (INSTANCE == null) { 
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

不锁 INSTANCE 的原因：

- INSTANCE 要重新赋值
- INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用

实现特点：

- 懒惰初始化
- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题

### DCL 问题

getInstance 方法对应的字节码为：

```java
0:  getstatic       #2      // Field INSTANCE:Ltest/Singleton;
3:  ifnonnull       37
6:  ldc             #3      // class test/Singleton
8:  dup
9:  astore_0
10: monitorenter
11: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
14: ifnonnull 27
17: new             #3      // class test/Singleton
20: dup
21: invokespecial   #4      // Method "<init>":()V
24: putstatic       #2      // Field INSTANCE:Ltest/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
40: areturn
```

- 17 表示创建对象，将对象引用入栈
- 20 表示复制一份对象引用，引用地址
- 21 表示利用一个对象引用，调用构造方法初始化对象
- 24 表示利用一个对象引用，赋值给 static INSTANCE

**步骤 21 和 24 之间不存在数据依赖关系**，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的

- 关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值
- 当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL出现的问题.png)

### 解决方法

指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性

引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：

```java
private static volatile SingletonDemo INSTANCE = null;
```
