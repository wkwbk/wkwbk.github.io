# 线程状态

进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态

线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 `java.lang.Thread.State` 这个枚举中给出了六种线程状态：

| 线程状态                  | 导致状态发生条件                                                                                                                                                                                                           |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NEW（新建）               | 线程刚被创建，但是并未启动，还没调用 `start` 方法，只有线程对象，没有线程特征                                                                                                                                              |
| RUNNABLE（可运行）        | 线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。<br>调用了 `start` 方法后，线程进入就绪（Ready）状态，等待 CPU 调度。一旦获得 CPU，就进入运行状态。                          |
| BLOCKED（阻塞）           | 当一个线程试图获取一个对象锁（通过 `synchronized` 关键字），而该对象锁被其他的线程持有，则该线程进入 BLOCKED 状态；<br>当该线程持有锁时，该线程将变成 RUNNABLE 状态                                                        |
| WAITING（无限等待）       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 WAITING 状态。进入这个状态后不能自动唤醒，必须等待另一个线程调用 `Object.notify()`、`Object.notifyAll()` 方法，或者被 `Thread.interrupt()` 方法打断才能被唤醒。 |
| TIMED_WAITING（限期等待） | 有几个方法有超时参数，调用将进入 TIMED_WAITING 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。<br>带有超时参数的常用方法有 `Thread.sleep()`、`Object.wait()`                                                        |
| TERMINATED（结束）        | `run()` 方法正常退出而死亡，或者因为没有捕获的异常终止了 `run()` 方法而死亡                                                                                                                                                |

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-线程6种状态.png)

- NEW → RUNNABLE：当调用 `t.start()` 方法时，由 NEW → RUNNABLE

- RUNNABLE ←→ WAITING：
  - 调用 `obj.wait()` 方法时，线程释放对象锁并进入 WAITING 状态。
  - 当被 `obj.notify()`、`obj.notifyAll()` 唤醒，或被 `t.interrupt()` 打断时：
    - 如果该线程能够立即重新竞争并获取到对象锁，则从 WAITING → RUNNABLE
    - 如果该线程未能立即获取到对象锁（因为锁被其他线程持有），则从 WAITING → BLOCKED
  - 当前线程调用 `t.join()` 方法时，当前线程（调用 join 的线程）会等待 t 线程结束，所以调用线程进入 WAITING 状态
  - 当前线程调用 `LockSupport.park()` 方法时，进入 WAITING 状态

- RUNNABLE ←→ TIMED_WAITING：
  - 调用 `obj.wait(long n)` 方法
  - 当前线程调用 `t.join(long n)` 方法
  - 当前线程调用 `Thread.sleep(long n)`

- RUNNABLE ←→ BLOCKED：
  - t 线程尝试通过 `synchronized(obj)` 获取对象锁时竞争失败，进入 BLOCKED 状态

## 查看线程

Windows：

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist` 查看进程
- `taskkill /PID <PID>` 杀死进程

Linux：

- `ps -ef` 查看所有进程
- `ps -fT -p <PID>` 查看某个进程（PID）的所有线程
- `kill <PID>` 杀死进程
- `top` 命令，按大写 H 键切换是否显示线程
- `top -H -p <PID>` 查看某个进程（PID）的所有线程

Java：

- `jps` 命令，查看所有 Java 进程的进程 ID
- `jstack <PID>` 查看某个 Java 进程（PID）的所有线程的堆栈信息和状态，是排查死锁和线程阻塞问题的利器
- `jconsole` 命令，来查看某个 Java 进程中线程的运行情况（图形界面）
- `jvisualvm` 命令，功能更强大的图形化工具，除了 jconsole 的功能外，还支持插件扩展，可以进行性能分析、内存分析等
