# 基本概念

JUC 是 `java.util.concurrent` 包的缩写，是 Java 并发编程的核心工具包。它提供了一系列用于处理多线程编程的类和接口，旨在简化并发编程的复杂性，提高程序性能和可靠性。

> <https://www.bilibili.com/video/BV16J411h7Rd>

## 线程与进程

**进程**：程序是静止的，进程实体的运行过程就是进程，是系统进行**资源分配的基本单位**

**线程**：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统**独立调度的基本单位**，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源

**关系**：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程

**线程的作用**：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能

**线程与进程对比**：

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集

- 进程拥有共享的资源，如内存空间等，供其**内部的线程共享**

- 进程间通信较为复杂

  同一台计算机的进程通信称为 IPC（Inter-process communication）

  - 信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件
  - 共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问
  - 管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持**半双工通信**
    - 匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
    - 命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO
  - 消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供**全双工通信**，对比管道：
    - 匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除
    - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收

  不同计算机之间的**进程通信**，需要通过网络，并遵守共同的协议，例如 HTTP

  - 套接字：与其它通信机制不同的是，可用于不同机器间的互相通信

- 线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量

  **Java 中的通信机制**：volatile、等待/通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer

- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

## 并发与并行

单核 CPU 下，线程实际还是**串行执行**的。

操作系统中有一个组件叫做任务调度器，将 CPU 的时间片（Windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 CPU 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。

总结为一句话就是：微观串行，宏观并行，一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）

- 并发：在同一时刻，有多个指令在单个 CPU 上交替执行
- 并行：在同一时刻，有多个指令在多个 CPU 上同时执行

> 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
>
> 并行（parallel）是同一时间动手做（doing）多件事情的能力

## 同步与异步

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

## 阻塞与非阻塞

- 阻塞是指程序在执行某个操作时会暂停，必须等待该操作彻底完成后才能继续执行后续代码，就像原地不动地等待结果。
- 非阻塞是指程序在执行操作时会立即返回，不等待结果，而是继续处理其他任务，稍后通过轮询或事件通知来获取操作结果。

## 创建线程

### Thread

Thread 创建线程方式：创建线程类、匿名内部类方式

- `start()` 方法底层其实是给 CPU 注册当前线程，并且触发 `run()` 方法执行
- 线程的启动必须调用 `start()` 方法，如果线程直接调用 `run()` 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程
- 为了观察子线程的并发执行效果，通常会将主线程自身较长的任务放在子线程启动之后，否则主线程可能在子线程开始执行前就已经完成

Thread 构造器：

- `public Thread()`
- `public Thread(String name)`

```java
public class ThreadDemo {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start();
        for(int i = 0 ; i < 100 ; i++ ){
            System.out.println("main 线程" + i);
        }
        // 如果将 main 线程的循环放在 t.start() 之前，那么 main 线程的循环会先完全执行完，之后子线程才可能开始或继续执行。
        // 如果放在 t.start() 之后（如当前代码），main 线程和子线程是并发执行的，输出会交错。
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        for(int i = 0 ; i < 100 ; i++ ) {
            System.out.println("子线程输出："+i);
        }
    }
}
```

继承 Thread 类的优缺点：

- 优点：编码简单
- 缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）

### Runnable

Runnable 创建线程方式：创建线程类、匿名内部类方式

Thread 的构造器：

- `public Thread(Runnable target)`
- `public Thread(Runnable target, String name)`

```java
public class ThreadDemo {
    public static void main(String[] args) {
        Runnable target = new MyRunnable();
        Thread t1 = new Thread(target,"1 号线程");
        t1.start();
        Thread t2 = new Thread(target);
        t2.start();
    }
}

public class MyRunnable implements Runnable{
    @Override
    public void run() {
        for(int i = 0 ; i < 10 ; i++ ){
            System.out.println(Thread.currentThread().getName() + "->" + i);
        }
    }
}
```

**Thread 类本身也是实现了 Runnable 接口**，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：

```java
public class Thread implements Runnable {
    private Runnable target;
    
    public void run() {
        if (target != null) {
            // 底层调用的是 Runnable 的 run 方法
            target.run();
        }
    }
}
```

Runnable 方式的优缺点：

- 缺点：代码复杂一点。

- 优点：

  1. 线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性
  2. 同一个线程任务对象可以被包装成多个线程对象
  3. 适合多个线程去共享同一个资源
  4. 实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立
  5. 线程池可以放入实现 Runnable 或 Callable 线程任务对象

### Callable

实现 Callable 接口：

1. 定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型
2. 重写线程任务类的 `call()` 方法，这个方法可以直接返回执行的结果
3. 创建一个 Callable 的线程任务对象
4. 把 Callable 的线程任务对象**包装成一个未来任务对象**
5. 把未来任务对象包装成线程对象
6. 调用线程的 `start()` 方法启动线程

`public FutureTask(Callable<V> callable)`：未来任务对象，在线程执行完后得到线程的执行结果

- FutureTask 就是 Runnable 对象，因为 **Thread 类只能执行 Runnable 实例的任务对象**，所以把 Callable 包装成未来任务对象
- 线程池部分详解了 FutureTask 的源码

`public V get()`：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步

- `get()` 线程会阻塞等待任务执行完成
- `run()` 执行完后会把结果设置到 FutureTask  的一个成员变量，`get()` 线程可以获取到该变量的值

优缺点：

- 优点：同 Runnable，并且能得到线程执行的结果
- 缺点：编码复杂

```java
public class ThreadDemo {
    public static void main(String[] args) {
        Callable call = new MyCallable();
        FutureTask<String> task = new FutureTask<>(call);
        Thread t = new Thread(task);
        t.start();
        try {
            String s = task.get(); // 获取 call 方法返回的结果（正常/异常结果）
            System.out.println(s);
        }  catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class MyCallable implements Callable<String> {
    @Override//重写线程任务类方法
    public String call() throws Exception {
        return Thread.currentThread().getName() + "->" + "Hello World";
    }
}
```

## 线程方法

Thread 类 API：

| 方法                                          | 说明                                                                                         |
| --------------------------------------------- | -------------------------------------------------------------------------------------------- |
| `public void start()`                         | 启动一个新线程，Java 虚拟机调用此线程的 run 方法                                             |
| `public void run()`                           | 线程启动后调用该方法                                                                         |
| `public void setName(String name)`            | 给当前线程取名字                                                                             |
| `public void getName()`                       | 获取当前线程的名字<br />线程存在默认名称：子线程是 `Thread-索引`，主线程是 `main`            |
| `public static Thread currentThread()`        | 获取当前线程对象，代码在哪个线程中执行                                                       |
| `public static void sleep(long time)`         | 让当前线程休眠多少毫秒再继续执行<br />`Thread.sleep(0)`：让操作系统立刻重新进行一次 CPU 竞争 |
| `public static native void yield()`           | 提示线程调度器让出当前线程对 CPU 的使用                                                      |
| `public final int getPriority()`              | 返回此线程的优先级                                                                           |
| `public final void setPriority(int priority)` | 更改此线程的优先级，常用 `1` `5` `10`                                                        |
| `public void interrupt()`                     | 中断这个线程，异常处理机制                                                                   |
| `public static boolean interrupted()`         | 判断当前线程是否被打断，清除打断标记                                                         |
| `public boolean isInterrupted()`              | 判断当前线程是否被打断，不清除打断标记                                                       |
| `public final void join()`                    | 等待这个线程结束                                                                             |
| `public final void join(long n)`              | 等待线程运行结束，最多等待 `n` 毫秒，0 意味着永远等待                                        |
| `public final native boolean isAlive()`       | 线程是否存活（还没有运行完毕）                                                               |
| `public final void setDaemon(boolean on)`     | 将此线程标记为守护线程或用户线程                                                             |

### run、start

`run`：

- 称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止
- 直接调用 `run` 是在主线程中执行了 `run`，没有启动新的线程，需要顺序执行

`start`：

- 使用 `start` 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 `run` 中的代码

> 说明：Thread 类是 Java 中用于创建和管理线程的核心类，它封装了线程的生命周期和操作。

`run()` 方法中的异常不能抛出，只能 `try/catch`

- 因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常
- **异常不能跨线程传播回 `main()` 中**，因此必须在本地进行处理

### sleep、yield

`sleep`：

- 调用 `sleep` 会让当前线程从 `Running` 进入 `Timed Waiting` （阻塞）状态
- `sleep()` 方法的过程中，**线程不会释放对象锁**
- 其它线程可以使用 `interrupt` 方法打断正在睡眠的线程，这时 `sleep` 方法会抛出 InterruptedException
- 睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU
- 建议用 TimeUnit 的 `sleep` 代替 Thread 的 `sleep` 来获得更好的可读性

`yield`：

- 调用 `yield` 会让提示线程调度器让出当前线程对 CPU 的使用
- 具体的实现依赖于操作系统的任务调度器
- **会放弃 CPU 资源，锁资源不会释放**

### join

`public final void join()`：等待这个线程结束

原理：调用者线程进入被 `join` 线程的 `waitSet` 等待，直到被 `join` 线程结束并发出通知。其内部机制可以类比为：

```java
public final synchronized void join(long millis) throws InterruptedException {
    // 调用者线程（如 main 线程）获取当前线程对象（t1）的锁，如果 t1 仍然存活，则进入 t1 的 waitSet 等待。
    while (isAlive()) {
        wait(0);
    }
}
```

- `join` 方法是被 `synchronized` 修饰的，本质上是一个对象锁，其内部的 `wait` 方法调用也是释放锁的，但是**释放的是当前的线程对象锁，而不是外面的锁**

- 当调用某个线程（t1）的 `join` 方法后，是调用者线程（例如 main 线程）暂停执行，等待 t1 线程完成。`join` 方法并不会让 t1 线程抢占 CPU 资源或优先执行，t1 线程的调度依然由操作系统决定

线程同步：

- `join` 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行
  - 需要外部共享变量来获取结果，不符合面向对象封装的思想（对于结果传递而言）
  - 必须等待线程结束，不能配合线程池使用（因为线程池管理的是任务，而非直接的 Thread 对象）
- Future 实现（同步）：`get()` 方法阻塞等待执行结果
  - `main` 线程接收结果
  - `get` 方法是让调用线程同步等待

```java
public class Test {
    static int r = 0;
    public static void main(String[] args) throws InterruptedException {
        test1();
    }
    private static void test1() throws InterruptedException {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(1000); // t1 线程休眠 1 秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            r = 10; // t1 线程将 r 设置为 10
        });
        t1.start();
        t1.join();// main 线程会等待 t1 线程执行结束，因此会输出 10
        System.out.println(r);
    }
}
```

### interrupt

#### 打断线程

`public void interrupt()`：打断这个线程，异常处理机制

`public static boolean interrupted()`：判断当前线程是否被打断，打断返回 true，**清除打断标记**，连续调用两次一定返回 false

`public boolean isInterrupted()`：判断当前线程是否被打断，不清除打断标记

> `interrupt()` 方法的主要作用是设置线程的打断标记。它不会立即停止线程的执行，也不会强制线程进行上下文切换。线程需要通过 `isInterrupted()` 或 `interrupted()`主动检查打断标记，或处理 `InterruptedException` 来响应打断请求。

- sleep、wait、join 方法都会让线程进入阻塞状态，打断线程**会清空打断状态**（false）

  ```java
  public static void main(String[] args) throws InterruptedException {
      Thread t1 = new Thread(()->{
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              e.printStackTrace();
              System.out.println("在 catch 块中，打断状态：" + Thread.currentThread().isInterrupted()); // 输出 false
          }
      }, "t1");
      t1.start();
      Thread.sleep(500);    // main 线程等待 0.5 秒，确保 t1 进入 sleep
      t1.interrupt();       // 打断 t1 线程的 sleep
      System.out.println(" t1 线程的打断状态：" + t1.isInterrupted());  // 输出 false
  }
  ```

- 打断正常运行的线程：不会清空打断状态（true）

  ```java
  public static void main(String[] args) throws Exception {
      Thread t2 = new Thread(()->{
          while(true) {
              Thread current = Thread.currentThread();
              boolean interrupted = current.isInterrupted();
              if(interrupted) {
                  System.out.println("打断状态：" + interrupted);  // 打断状态：true
                  break;    // 线程响应打断，退出循环
              }
          }
      }, "t2");
      t2.start();
      Thread.sleep(500);    // main 线程等待 0.5 秒
      t2.interrupt();       // 打断 t2 线程
  }
  ```

#### 打断 park

park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）

```java
public static void main(String[] args) throws Exception {
    Thread t1 = new Thread(() -> {
        System.out.println("park...");
        LockSupport.park();
        System.out.println("unpark...");
        System.out.println("打断状态：" + Thread.currentThread().isInterrupted()); // 打断状态：true
    }, "t1");
    t1.start();
    Thread.sleep(2000); // 等待 t1 线程启动并进入 park 状态
    t1.interrupt();     // 打断 t1 线程
}
```

如果在调用 `LockSupport.park()` 之前，线程的打断标记已经是 `true`，那么 `park()` 方法会立即返回，不会阻塞。

```java
public static void main(String[] args) {
    Thread current = Thread.currentThread();
    current.interrupt(); // 手动设置当前线程的打断标记为 true
    System.out.println("第一次 park 前，打断状态：" + current.isInterrupted()); // true
    LockSupport.park(); // 由于打断标记为 true，park 会立即返回，不会阻塞
    System.out.println("第一次 unpark...");
    System.out.println("第一次 unpark 后，打断状态：" + current.isInterrupted()); // 仍然是 true (park 不会清除打断标记)
    // 注意：LockSupport.park() 不会清除打断标记，所以如果再次调用 park，它依然会立即返回。
    // 如果需要清除打断标记，需要手动调用 Thread.interrupted()
    current.interrupted(); // 清除打断标记，将打断状态设为 false
    System.out.println("清除打断标记后，打断状态：" + current.isInterrupted()); // false
    LockSupport.park(); // 这次会阻塞，因为打断标记已清除
    System.out.println("第二次 unpark..."); // 这行代码通常不会被执行，除非有 unpark() 或再次 interrupt()
}
```

LockSupport 类在 [同步](./02.同步) → [park-un](./02.同步#park-un) 详解

#### 终止模式

终止模式之两阶段终止模式：Two Phase Termination

目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器

错误思想：

- 使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁
- 使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止

两阶段终止模式图示：

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-两阶段终止模式.png)

打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：

```java
public class Test {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();
        tpt.start();
        Thread.sleep(3500);
        tpt.stop();
    }
}

class TwoPhaseTermination {
    private Thread monitor;
    // 启动监控线程
    public void start() {
        monitor = new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    Thread thread = Thread.currentThread();
                    if (thread.isInterrupted()) { // 检查打断标记，决定是否进行后置处理并退出
                        System.out.println("后置处理");
                        break; // 退出循环，线程终止
                    }
                    try {
                        Thread.sleep(1000);                 // 睡眠
                        System.out.println("执行监控记录"); // 在此被打断不会异常
                    } catch (InterruptedException e) {      // 在 sleep 期间被打断，会抛出 InterruptedException
                        e.printStackTrace();
                        // 捕获 InterruptedException 后，打断标记会被清除
                        // 为了让外层循环的 isInterrupted() 判断为 true 从而执行后置处理并退出，需要重新设置打断标记。
                        thread.interrupt();
                    }
                }
            }
        });
        monitor.start();
    }
    // 停止监控线程
    public void stop() {
        monitor.interrupt();
    }
}
```

### daemon

`public final void setDaemon(boolean on)`：如果是 true，将此线程标记为守护线程

线程**启动前**调用此方法：

```java
Thread t = new Thread() {
    @Override
    public void run() {
        System.out.println("running");
        // 守护线程的特点是随着用户线程的结束而结束，
        // 为了更好地观察这个特性，可以让守护线程执行一个耗时操作。
        try {
            Thread.sleep(5000); // 模拟守护线程长时间运行
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("守护线程执行完毕"); // 这行可能不会被打印，取决于主线程何时结束
    }
};
// 设置该线程为守护线程
t.setDaemon(true);
t.start();
System.out.println("主线程结束");
```

**用户线程**：

- 平常创建的普通线程
- JVM 会等待所有用户线程执行完毕才会退出

**守护线程**：

- 服务于用户线程，只要所有非守护线程运行结束了，即使守护线程的代码没有执行完，JVM 也会强制结束所有守护线程，然后退出
- 守护线程是一种特殊类型的线程，它的存在不阻止 JVM 退出

> 说明：当运行的线程都是守护线程，JVM 将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去

常见的守护线程：

- 垃圾回收器线程就是一种守护线程
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求

### 不推荐

不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：

- `public final void stop()`：强制停止线程运行

  废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面

- `public final void suspend()`：**挂起（暂停）线程运行**

  废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果**恢复目标线程的线程**在调用 resume 之前会尝试访问此共享资源，则会导致死锁

- `public final void resume()`：恢复被 `suspend()` 挂起的线程运行

## 线程原理

### 运行机制

Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程

- 线程的 CPU 时间片用完
- 垃圾回收（GC 线程可能需要暂停应用线程）
- 有更高优先级的线程需要运行
- 线程自己调用了 sleep、yield、wait、join、park 等方法，或者遇到 I/O 阻塞。

程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的

当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等

JVM 规范并没有限定线程模型，以 HotSopot 为例：

- Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）
- **线程的调度是在内核态运行的，而线程中的代码是在用户态运行**，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能

Java 中 main 方法启动的是一个进程，也是一个主线程。main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程

### 线程调度

线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）

协同式线程调度：线程的执行时间由线程本身控制

- 优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题（因为没有并发）
- 缺点：线程执行时间不可控，如果代码编写出现问题（如死循环），可能导致程序一直阻塞，引起系统的奔溃

抢占式线程调度：线程的执行时间由系统分配（操作系统调度器）

- 优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用
- 缺点：无法主动为某个线程多分配时间（虽然有优先级提示），且需要处理线程同步问题

Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用

> 说明：并不能通过优先级来判断线程执行的先后顺序，也不能保证高优先级线程一定比低优先级线程先执行或获得更多执行时间，这高度依赖于操作系统和 JVM 的具体实现

### 未来优化

内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多个用户线程映射到一个内核级线程），被设计为协同式调度，所以叫协程

- 有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程
- 无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限

有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：

- 执行过程：用于维护执行现场，保护、恢复上下文状态，它封装了代码的执行路径和暂停/恢复点
- 调度器：负责编排所有要执行的代码顺序，并将纤程映射到少量的平台线程（内核线程）上

## 线程状态

进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态

线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 `java.lang.Thread.State` 这个枚举中给出了六种线程状态：

| 线程状态                  | 导致状态发生条件                                                                                                                                                                                                           |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NEW（新建）               | 线程刚被创建，但是并未启动，还没调用 `start` 方法，只有线程对象，没有线程特征                                                                                                                                              |
| RUNNABLE（可运行）        | 线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。<br>调用了 `start` 方法后，线程进入就绪（Ready）状态，等待 CPU 调度。一旦获得 CPU，就进入运行状态。                          |
| BLOCKED（阻塞）           | 当一个线程试图获取一个对象锁（通过 `synchronized` 关键字），而该对象锁被其他的线程持有，则该线程进入 BLOCKED 状态；<br>当该线程持有锁时，该线程将变成 RUNNABLE 状态                                                        |
| WAITING（无限等待）       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 WAITING 状态。进入这个状态后不能自动唤醒，必须等待另一个线程调用 `Object.notify()`、`Object.notifyAll()` 方法，或者被 `Thread.interrupt()` 方法打断才能被唤醒。 |
| TIMED_WAITING（限期等待） | 有几个方法有超时参数，调用将进入 TIMED_WAITING 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。<br>带有超时参数的常用方法有 `Thread.sleep()`、`Object.wait()`                                                        |
| TERMINATED（结束）        | `run()` 方法正常退出而死亡，或者因为没有捕获的异常终止了 `run()` 方法而死亡                                                                                                                                                |

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-线程6种状态.png)

- NEW → RUNNABLE：当调用 `t.start()` 方法时，由 NEW → RUNNABLE

- RUNNABLE ←→ WAITING：
  - 调用 `obj.wait()` 方法时，线程释放对象锁并进入 WAITING 状态。
  - 当被 `obj.notify()`、`obj.notifyAll()` 唤醒，或被 `t.interrupt()` 打断时：
    - 如果该线程能够立即重新竞争并获取到对象锁，则从 WAITING → RUNNABLE
    - 如果该线程未能立即获取到对象锁（因为锁被其他线程持有），则从 WAITING → BLOCKED
  - 当前线程调用 `t.join()` 方法时，当前线程（调用 join 的线程）会等待 t 线程结束，所以调用线程进入 WAITING 状态
  - 当前线程调用 `LockSupport.park()` 方法时，进入 WAITING 状态

- RUNNABLE ←→ TIMED_WAITING：
  - 调用 `obj.wait(long n)` 方法
  - 当前线程调用 `t.join(long n)` 方法
  - 当前线程调用 `Thread.sleep(long n)`

- RUNNABLE ←→ BLOCKED：
  - t 线程尝试通过 `synchronized(obj)` 获取对象锁时竞争失败，进入 BLOCKED 状态

## 查看线程

Windows：

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist` 查看进程
- `taskkill /PID <PID>` 杀死进程

Linux：

- `ps -ef` 查看所有进程
- `ps -fT -p <PID>` 查看某个进程（PID）的所有线程
- `kill <PID>` 杀死进程
- `top` 命令，按大写 H 键切换是否显示线程
- `top -H -p <PID>` 查看某个进程（PID）的所有线程

Java：

- `jps` 命令，查看所有 Java 进程的进程 ID
- `jstack <PID>` 查看某个 Java 进程（PID）的所有线程的堆栈信息和状态，是排查死锁和线程阻塞问题的利器
- `jconsole` 命令，来查看某个 Java 进程中线程的运行情况（图形界面）
- `jvisualvm` 命令，功能更强大的图形化工具，除了 jconsole 的功能外，还支持插件扩展，可以进行性能分析、内存分析等
