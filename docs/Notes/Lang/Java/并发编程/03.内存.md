# 内存

## JMM

### 内存模型

Java 内存模型（JMM）是一个**抽象概念**，它不是实际存在的硬件或软件，而是一套**规则和规范**。这套规则定义了程序中所有变量（包括实例变量、静态变量和数组元素）在内存中的访问方式，特别是在多线程环境下的行为。

**JMM 的作用**：

- **平台一致性**：屏蔽不同硬件和操作系统内存访问的差异，确保 Java 程序在任何平台下都能有一致的并发行为。
- **定义内存关系**：规定了线程如何与内存进行交互。

**核心思想**：

- JMM 假定系统存在一个**主内存（Main Memory）**，所有线程共享的变量都存储在这里。
- 每条线程都有自己的**工作内存（Working Memory）**，里面保存着主内存中这些共享变量的**副本**。
- 线程对变量的所有操作（读、写）都必须先在自己的工作内存中进行，不能直接操作主内存。
- 线程之间的通信（数据传递）也必须通过主内存来完成。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM内存模型.png)

**主内存与工作内存的对应关系（与 JVM 内存区域的区别）**：JMM 的主内存和工作内存是**抽象概念**，与 JVM 运行时数据区（堆、栈、方法区等）不是直接对应的。

- **主内存**：更接近于物理内存，主要存储 Java 堆中的对象实例数据。
- **工作内存**：更接近于 CPU 的高速缓存和寄存器，存储线程私有的变量副本。

### 内存交互

JMM 定义了 8 种**原子操作**来规范主内存和工作内存之间的数据交互。每个操作都是不可中断的。

> 注意：除了 `volatile` 修饰的 `long` 和 `double` 类型变量，其他 `long` 和 `double` 变量的读写操作在 32 位系统上可能不是原子的，而是被拆分成两次 32 位操作。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-内存交互.png)

- `lock`（锁定）：作用于主内存，将变量标记为线程独占状态。
- `unlock`（解锁）：作用于主内存，释放变量的独占状态，允许其他线程锁定。
- `read`（读取）：作用于主内存，将变量值从主内存传输到线程的工作内存。
- `load`（载入）：作用于工作内存，紧接在 `read` 之后，将 `read` 到的值放入工作内存的变量副本。
- `use`（使用）：作用于工作内存，将工作内存中变量的值传递给**执行引擎**（CPU），每次使用变量前都需要。
- `assign`（赋值）：作用于工作内存，将执行引擎计算出的值赋给工作内存的变量。
- `store`（存储）：作用于工作内存，将工作内存中变量的值传输到主内存。
- `write`（写入）：作用于主内存，紧接在 `store` 之后，将 `store` 得到的值写入主内存的变量。

> 规则总结：这些操作必须遵循严格的顺序和组合规则，以确保内存操作的正确性。例如，`read` 和 `load` 必须成对出现，`store` 和 `write` 也必须成对出现。`lock` 和 `unlock` 必须成对，且 `unlock` 前必须先 `store` 和 `write`。`lock` 操作会清空工作内存中该变量的副本，强制线程重新从主内存加载最新值。

参考文章：<https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md>

### 三大特性

#### 可见性

**定义**：当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够**立即**看到并读取到这个修改后的最新值。

**问题根源**：由于每个线程都有自己的工作内存（缓存），它们操作的是共享变量的副本。如果一个线程修改了副本，但没有及时同步回主内存，或者其他线程没有及时从主内存刷新副本，就会导致“不可见”问题，即线程读取到的是旧值。

**示例**：main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止

```java
static boolean run = true; // 默认值是 true
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while(run) { // t 线程持续检查 run 变量
        // ... 其他操作
        }
        System.out.println("t 线程停止了。");
    });
    t.start();

    Thread.sleep(1000); // 主线程等待 1 秒
    run = false; // 主线程修改 run 的值
    System.out.println("主线程将 run 设置为 false。");
    // 预期：t 线程应该在 1 秒后停止，但实际可能不会。
}
```

**原因分析**：

1. **初始状态**：`t` 线程启动后，将 `run` 变量的初始值 `true` 从主内存读取到自己的工作内存中。
2. **JIT 优化**：为了提高效率，JIT 编译器可能会将 `while(run)` 循环优化为直接读取 `t` 线程工作内存中的 `run` 副本，甚至可能将其视为一个常量 `true`，从而减少频繁访问主内存。
3. **修改不同步**：1 秒后，`main` 线程修改了 `run` 的值为 `false`，并同步回主内存。
4. **`t` 线程的盲区**：由于 `t` 线程可能持续从自己的工作内存缓存中读取 `run` 的旧值（`true`），它无法感知 `main` 线程对主内存中 `run` 变量的修改，导致 `while(run)` 循环永远不会结束。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-可见性例子.png)

**解决方案**：

- 使用 `volatile` 关键字修饰 `run` 变量：`volatile` 强制所有线程从主内存读取最新值，并立即写回主内存。
- 使用 `synchronized` 或 `Lock`：它们不仅保证原子性，也隐式地保证了可见性（在释放锁前会把工作内存修改同步回主内存，在获取锁后会清空工作内存，强制从主内存读取）。
- 使用 `final` 关键字修饰的变量是不可变的，虽然不是直接解决可见性问题，但其不可变性天然保证了多线程环境下的一致性（因为值不会变）。

#### 原子性

**定义**：一个或一系列操作是**不可分割**的，要么全部成功执行，要么全部不执行（失败），在执行过程中不会被任何其他线程的操作打断。它保证了指令的完整性，不会受到线程上下文切换的影响。

**JMM 对原子操作的规则**：JMM 定义了 8 个内存交互操作，这些操作本身是原子的。但为了保证更高级别操作的原子性，JMM 规定了一些使用规则：

1. `read` 和 `load` 必须成对出现，不能单独执行。`store` 和 `write` 也必须成对出现。
2. 线程不能丢弃 `assign` 操作，即对工作内存变量的修改必须同步回主内存。
3. 线程不能无原因地将工作内存的数据同步回主内存（必须是发生了 `assign` 操作）。
4. 新变量只能在主内存中创建。线程在使用或存储变量前，必须先进行 `assign` 或 `load` 操作（即从主内存初始化）。
5. 一个变量在同一时刻只允许一个线程对其执行 `lock` 操作。`lock` 操作可以被同一线程重复执行多次（可重入），但只有执行相同次数的 `unlock` 操作后，变量才会被真正解锁。`lock` 和 `unlock` 必须成对出现。
6. 对变量执行 `lock` 操作会**清空工作内存中此变量的值**，强制线程在使用前重新从主内存加载。
7. 不允许对未被 `lock` 操作锁定的变量执行 `unlock` 操作，也不允许解锁被其他线程锁定的变量。
8. 对变量执行 `unlock` 操作之前，必须**先把此变量同步到主内存**中（执行 `store` 和 `write` 操作）。

**解决方案**：

- 使用 `synchronized` 关键字：保证代码块或方法的原子性。
- 使用 `java.util.concurrent.atomic` 包下的原子类：如 `AtomicInteger`、`AtomicLong`，它们通过 CAS 操作实现原子性。
- 使用 `java.util.concurrent.locks.Lock` 接口的实现类：如 `ReentrantLock`。

#### 有序性

**定义**：

- 本线程内观察（有序）：无论底层指令如何重排序，程序都会保证最终执行结果与你写的代码逻辑一致，让你感觉是按顺序执行的。
  - 就像你在家穿衣服，你是先穿袜子还是先穿裤子，你自己并不在意，只要最后你“穿整齐了出门”这个结果是对的，你就觉得自己的逻辑是有序的。
- 线程间观察（无序）：在没有同步约束时，一个线程为了性能而产生的指令重排会被另一个线程察觉，从而看到逻辑颠倒或未完成的中间状态。
  - 你在窗外看发货员。发货员（线程 A）为了效率，先在系统里点了“已发货”，然后再去打包快递。你（线程 B）看到系统显示“已发货”，兴冲冲去取件，结果发现包裹还是空的。在你的视角里，发货员的操作顺序“乱了”。

**指令重排序**：为了提高性能，编译器和处理器会对指令进行优化，调整其执行顺序，只要不改变**单线程内的执行结果**，这种重排序就是允许的。

**重排序的阶段**：源代码 → 编译器优化的重排 → 指令并行的重排 → 内存系统的重排 → 最终执行指令

- **CPU 流水线**：现代 CPU 支持多级指令流水线（如经典的“取指令、指令译码、执行指令、访存取数和结果写回”五级流水线）。CPU 可以在一个时钟周期内，同时运行五条指令的**不同阶段**。这本质上不能缩短单条指令的执行时间，但通过并行处理提高了指令的吞吐率。
- **数据依赖性**：处理器在进行重排序时，必须考虑**指令之间的数据依赖性**。如果一个指令的执行结果是另一个指令的输入，那么这两个指令不能被重排序。
  - **单线程环境**：即使存在指令重排，由于数据依赖性的保证，最终执行结果和代码顺序的结果是一致的。
  - **多线程环境**：线程交替执行时，由于编译器和处理器的优化重排，一个线程可能观察到另一个线程的操作顺序与代码顺序不一致，这可能导致意想不到的错误。

**示例**：著名的“双重检查锁定（DCL）”单例模式中，如果不使用 `volatile`，就可能因为指令重排序导致问题。

```java
class Singleton {
    private static Singleton instance; // 考虑不使用 volatile 的情况

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    // 这行代码可能发生指令重排序
                    // 1. memory = allocate() 分配内存
                    // 2. ctorInstance(memory) 初始化对象
                    // 3. instance = memory 设置 instance 指向内存
                    // 如果重排序为 1 -> 3 -> 2，那么在 3 执行后，另一个线程可能看到非空的 instance，
                    // 但此时对象还未完全初始化，导致访问到半初始化对象。
                    instance = new Singleton(); 
                }
            }
        }
        return instance;
    }
}
```

**解决方案**：使用 `volatile` 关键字：`volatile` 除了保证可见性，还能**禁止指令重排序**（特别是针对 `volatile` 变量的读写操作）。在 DCL 中，`private static volatile Singleton instance;` 可以解决重排序问题。

## cache

### 缓存机制

#### 缓存结构

在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率

CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-CPU缓存结构.png" style="zoom: 50%;" />

| 从 CPU 到 | 大约需要的时钟周期                |
| --------- | --------------------------------- |
| 寄存器    | 1 cycle (4GHz 的 CPU 约为 0.25ns) |
| L1        | 3~4 cycle                         |
| L2        | 10~20 cycle                       |
| L3        | 40~45 cycle                       |
| 内存      | 120~240 cycle                     |

#### 缓存使用

当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器

缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率

### 伪共享

**缓存以缓存行 cache line 为单位**，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中

缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的**整个缓存行必须失效**，这就是伪共享

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-内存伪共享.png" style="zoom: 67%;" />

解决方法：

- padding：通过填充，让数据落在不同的 cache line 中

- @Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享

Linux 查看 CPU 缓存行：

- 命令：`cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64`
- 内存地址格式：[高位组标记] [低位索引] [偏移量]

### 缓存一致

缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-缓存一致性.png" style="zoom:80%;" />

MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的**支持写回策略的缓存一致性协议**，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：

- M：被修改（Modified）

  该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次

  当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态

- E：独享的（Exclusive）

  该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)

  当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态

- S：共享的（Shared）

  该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据

- I：无效的（Invalid）

  该缓存是无效的，可能有其它 CPU 修改了该缓存行

解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等

### 处理机制

单核 CPU 处理器会自动保证基本内存操作的原子性

多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：

- 总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（**平台级别的加锁**）
- 缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现

有如下两种情况处理器不会使用缓存锁定：

- 当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定

- 有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定

总线机制：

- 总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就**将当前处理器的缓存行设置为无效状态**，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中

- 总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（**写传播**），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景

## volatile

### 同步机制

volatile 是 Java 虚拟机提供的**轻量级**的同步机制（三大特性）

- 保证可见性
- 不保证原子性
- 保证有序性（禁止指令重排）

性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小

synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性

- 加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的
- 线程加锁前，将**清空工作内存**中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值**刷新到主内存**中（JMM 内存交互章节有讲）

### 指令重排

volatile 修饰的变量，可以禁用指令重排

指令重排实例：

- example 1:

    ```java
    public void mySort() {
        int x = 11; //语句 1
        int y = 12; //语句 2  谁先执行效果一样
        x = x + 5;  //语句 3
        y = x - x;  //语句 4
    }
    ```

  执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4

  指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行

- example 2:

    ```java
    int num = 0;
    boolean ready = false;
    // 线程 1 执行此方法
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    // 线程 2 执行此方法
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
    ```

  情况一：线程 1 先执行，ready = false，结果为 r.r1 = 1
  
  情况二：线程 2 先执行 num = 2，但还没执行 ready = true，线程 1 执行，结果为 r.r1 = 1
  
  情况三：线程 2 先执行 ready = true，线程 1 执行，进入 if 分支结果为 r.r1 = 4
  
  情况四：线程 2 执行 ready = true，切换到线程 1，进入 if 分支为 r.r1 = 0，再切回线程 2 执行 num = 2，发生指令重排

### 底层原理

#### 缓存一致

使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据

lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

内存屏障有三个作用：

- 确保对内存的读 - 改 - 写操作原子执行
- 阻止屏障两侧的指令重排序
- 强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效

#### 内存屏障

保证**可见性**：

- 写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中

    ```java
    public void actor2(I_Result r) {
        num = 2;
        ready = true; // ready 是 volatile 赋值带写屏障
        // 写屏障
    }
    ```

- 读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据

    ```java
    public void actor1(I_Result r) {
        // 读屏障
        // ready 是 volatile 读取值带读屏障
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;" />

- 全能屏障：mfence（modify/mix Barrier），兼具 sfence 和 lfence 的功能

保证**有序性**：

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

不能解决指令交错：

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前

- 有序性的保证也只是保证了本线程内相关代码不被重排序

    ```java
    volatile i = 0;
    new Thread(() -> {i++});
    new Thread(() -> {i--});
    ```

    i++ 反编译后的指令：

    ```java
    0: iconst_1         // 当 int 取值 -1~5 时，JVM 采用 iconst 指令将常量压入栈中
    1: istore_1         // 将操作数栈顶数据弹出，存入局部变量表的 slot 1
    2: iinc     1, 1
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;" />

#### 交互规则

对于 volatile 修饰的变量：

- 线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载
- 线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存
- 线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排

### 双端检锁

#### 检锁机制

Double-Checked Locking：双端检锁机制

DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    
    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2，这里的判断不是线程安全的
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化
                if (INSTANCE == null) { 
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

不锁 INSTANCE 的原因：

- INSTANCE 要重新赋值
- INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用

实现特点：

- 懒惰初始化
- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题

#### DCL 问题

getInstance 方法对应的字节码为：

```java
0:  getstatic       #2      // Field INSTANCE:Ltest/Singleton;
3:  ifnonnull       37
6:  ldc             #3      // class test/Singleton
8:  dup
9:  astore_0
10: monitorenter
11: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
14: ifnonnull 27
17: new             #3      // class test/Singleton
20: dup
21: invokespecial   #4      // Method "<init>":()V
24: putstatic       #2      // Field INSTANCE:Ltest/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
40: areturn
```

- 17 表示创建对象，将对象引用入栈
- 20 表示复制一份对象引用，引用地址
- 21 表示利用一个对象引用，调用构造方法初始化对象
- 24 表示利用一个对象引用，赋值给 static INSTANCE

**步骤 21 和 24 之间不存在数据依赖关系**，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的

- 关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值
- 当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL出现的问题.png)

#### 解决方法

指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性

引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：

```java
private static volatile SingletonDemo INSTANCE = null;
```

## ha-be

happens-before 先行发生

Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结

不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性

1. 程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序

2. 锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见

3. **volatile 变量规则**  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读

4. 传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C

5. 线程启动规则 (Thread Start Rule)：Thread 对象的 start() 方 法先行发生于此线程中的每一个操作

    ```java
    static int x = 10;//线程 start 前对变量的写，对该线程开始后对该变量的读可见
    new Thread(()->{ System.out.println(x);  },"t1").start();
    ```

6. 线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7. 线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行

8. 对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始

## 设计模式

### 终止模式

终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性

```java
class TwoPhaseTermination {
    // 监控线程
    private Thread monitor;
    // 停止标记
    private volatile boolean stop = false;;

    // 启动监控线程
    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                Thread thread = Thread.currentThread();
                if (stop) {
                    System.out.println("后置处理");
                    break;
                }
                try {
                    Thread.sleep(1000);// 睡眠
                    System.out.println(thread.getName() + "执行监控记录");
                } catch (InterruptedException e) {
                    System.out.println("被打断，退出睡眠");
                }
            }
        });
        monitor.start();
    }

    // 停止监控线程
    public void stop() {
        stop = true;
        monitor.interrupt();// 让线程尽快退出 Timed Waiting
    }
}
// 测试
public static void main(String[] args) throws InterruptedException {
    TwoPhaseTermination tpt = new TwoPhaseTermination();
    tpt.start();
    Thread.sleep(3500);
    System.out.println("停止监控");
    tpt.stop();
}
```

### Balking

Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回

```java
public class MonitorService {
    // 用来表示是否已经有线程已经在执行启动了
    private volatile boolean starting = false;
    public void start() {
        System.out.println("尝试启动监控线程...");
        synchronized (this) {
            if (starting) {
                return;
            }
            starting = true;
        }
        // 真正启动监控线程...
    }
}
```

对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待

例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：

- 当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为 f alse，则 t2 就又初始化一次
- volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁

```java
public class TestVolatile {
    volatile boolean initialized = false;
    
    void init() {
        if (initialized) {
            return;
        }
        doInit();
        initialized = true;
    }
    private void doInit() {
    }
}
```
