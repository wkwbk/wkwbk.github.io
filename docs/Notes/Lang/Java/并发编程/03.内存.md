# 内存

## JMM

### 内存模型

Java 内存模型（JMM）是一个**抽象概念**，它不是实际存在的硬件或软件，而是一套**规则和规范**。这套规则定义了程序中所有变量（包括实例变量、静态变量和数组元素）在内存中的访问方式，特别是在多线程环境下的行为。

**JMM 的作用**：

- **平台一致性**：屏蔽不同硬件和操作系统内存访问的差异，确保 Java 程序在任何平台下都能有一致的并发行为。
- **定义内存关系**：规定了线程如何与内存进行交互。

**核心思想**：

- JMM 假定系统存在一个**主内存（Main Memory）**，所有线程共享的变量都存储在这里。
- 每条线程都有自己的**工作内存（Working Memory）**，里面保存着主内存中这些共享变量的**副本**。
- 线程对变量的所有操作（读、写）都必须先在自己的工作内存中进行，不能直接操作主内存。
- 线程之间的通信（数据传递）也必须通过主内存来完成。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM内存模型.png)

**主内存与工作内存的对应关系（与 JVM 内存区域的区别）**：JMM 的主内存和工作内存是**抽象概念**，与 JVM 运行时数据区（堆、栈、方法区等）不是直接对应的。

- **主内存**：更接近于物理内存，主要存储 Java 堆中的对象实例数据。
- **工作内存**：更接近于 CPU 的高速缓存和寄存器，存储线程私有的变量副本。

### 内存交互

JMM 定义了 8 种**原子操作**来规范主内存和工作内存之间的数据交互。每个操作都是不可中断的。

> 注意：除了 `volatile` 修饰的 `long` 和 `double` 类型变量，其他 `long` 和 `double` 变量的读写操作在 32 位系统上可能不是原子的，而是被拆分成两次 32 位操作。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-内存交互.png)

- `lock`（锁定）：作用于主内存，将变量标记为线程独占状态。
- `unlock`（解锁）：作用于主内存，释放变量的独占状态，允许其他线程锁定。
- `read`（读取）：作用于主内存，将变量值从主内存传输到线程的工作内存。
- `load`（载入）：作用于工作内存，紧接在 `read` 之后，将 `read` 到的值放入工作内存的变量副本。
- `use`（使用）：作用于工作内存，将工作内存中变量的值传递给**执行引擎**（CPU），每次使用变量前都需要。
- `assign`（赋值）：作用于工作内存，将执行引擎计算出的值赋给工作内存的变量。
- `store`（存储）：作用于工作内存，将工作内存中变量的值传输到主内存。
- `write`（写入）：作用于主内存，紧接在 `store` 之后，将 `store` 得到的值写入主内存的变量。

> 规则总结：这些操作必须遵循严格的顺序和组合规则，以确保内存操作的正确性。例如，`read` 和 `load` 必须成对出现，`store` 和 `write` 也必须成对出现。`lock` 和 `unlock` 必须成对，且 `unlock` 前必须先 `store` 和 `write`。`lock` 操作会清空工作内存中该变量的副本，强制线程重新从主内存加载最新值。

参考文章：<https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md>

### 三大特性

#### 可见性

**定义**：当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够**立即**看到并读取到这个修改后的最新值。

**问题根源**：由于每个线程都有自己的工作内存（缓存），它们操作的是共享变量的副本。如果一个线程修改了副本，但没有及时同步回主内存，或者其他线程没有及时从主内存刷新副本，就会导致“不可见”问题，即线程读取到的是旧值。

**示例**：main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止

```java
static boolean run = true; // 默认值是 true
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while(run) { // t 线程持续检查 run 变量
        // ... 其他操作
        }
        System.out.println("t 线程停止了。");
    });
    t.start();

    Thread.sleep(1000); // 主线程等待 1 秒
    run = false; // 主线程修改 run 的值
    System.out.println("主线程将 run 设置为 false。");
    // 预期：t 线程应该在 1 秒后停止，但实际可能不会。
}
```

**原因分析**：

1. **初始状态**：`t` 线程启动后，将 `run` 变量的初始值 `true` 从主内存读取到自己的工作内存中。
2. **JIT 优化**：为了提高效率，JIT 编译器可能会将 `while(run)` 循环优化为直接读取 `t` 线程工作内存中的 `run` 副本，甚至可能将其视为一个常量 `true`，从而减少频繁访问主内存。
3. **修改不同步**：1 秒后，`main` 线程修改了 `run` 的值为 `false`，并同步回主内存。
4. **`t` 线程的盲区**：由于 `t` 线程可能持续从自己的工作内存缓存中读取 `run` 的旧值（`true`），它无法感知 `main` 线程对主内存中 `run` 变量的修改，导致 `while(run)` 循环永远不会结束。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-可见性例子.png)

**解决方案**：

- 使用 `volatile` 关键字修饰 `run` 变量：`volatile` 强制所有线程从主内存读取最新值，并立即写回主内存。
- 使用 `synchronized` 或 `Lock`：它们不仅保证原子性，也隐式地保证了可见性（在释放锁前会把工作内存修改同步回主内存，在获取锁后会清空工作内存，强制从主内存读取）。
- 使用 `final` 关键字修饰的变量是不可变的，虽然不是直接解决可见性问题，但其不可变性天然保证了多线程环境下的一致性（因为值不会变）。

#### 原子性

**定义**：一个或一系列操作是**不可分割**的，要么全部成功执行，要么全部不执行（失败），在执行过程中不会被任何其他线程的操作打断。它保证了指令的完整性，不会受到线程上下文切换的影响。

**JMM 对原子操作的规则**：JMM 定义了 8 个内存交互操作，这些操作本身是原子的。但为了保证更高级别操作的原子性，JMM 规定了一些使用规则：

1. `read` 和 `load` 必须成对出现，不能单独执行。`store` 和 `write` 也必须成对出现。
2. 线程不能丢弃 `assign` 操作，即对工作内存变量的修改必须同步回主内存。
3. 线程不能无原因地将工作内存的数据同步回主内存（必须是发生了 `assign` 操作）。
4. 新变量只能在主内存中创建。线程在使用或存储变量前，必须先进行 `assign` 或 `load` 操作（即从主内存初始化）。
5. 一个变量在同一时刻只允许一个线程对其执行 `lock` 操作。`lock` 操作可以被同一线程重复执行多次（可重入），但只有执行相同次数的 `unlock` 操作后，变量才会被真正解锁。`lock` 和 `unlock` 必须成对出现。
6. 对变量执行 `lock` 操作会**清空工作内存中此变量的值**，强制线程在使用前重新从主内存加载。
7. 不允许对未被 `lock` 操作锁定的变量执行 `unlock` 操作，也不允许解锁被其他线程锁定的变量。
8. 对变量执行 `unlock` 操作之前，必须**先把此变量同步到主内存**中（执行 `store` 和 `write` 操作）。

**解决方案**：

- 使用 `synchronized` 关键字：保证代码块或方法的原子性。
- 使用 `java.util.concurrent.atomic` 包下的原子类：如 `AtomicInteger`、`AtomicLong`，它们通过 CAS 操作实现原子性。
- 使用 `java.util.concurrent.locks.Lock` 接口的实现类：如 `ReentrantLock`。

#### 有序性

**定义**：

- 本线程内观察（有序）：无论底层指令如何重排序，程序都会保证最终执行结果与你写的代码逻辑一致，让你感觉是按顺序执行的。
  - 就像你在家穿衣服，你是先穿袜子还是先穿裤子，你自己并不在意，只要最后你“穿整齐了出门”这个结果是对的，你就觉得自己的逻辑是有序的。
- 线程间观察（无序）：在没有同步约束时，一个线程为了性能而产生的指令重排会被另一个线程察觉，从而看到逻辑颠倒或未完成的中间状态。
  - 你在窗外看发货员。发货员（线程 A）为了效率，先在系统里点了“已发货”，然后再去打包快递。你（线程 B）看到系统显示“已发货”，兴冲冲去取件，结果发现包裹还是空的。在你的视角里，发货员的操作顺序“乱了”。

**指令重排序**：为了提高性能，编译器和处理器会对指令进行优化，调整其执行顺序，只要不改变**单线程内的执行结果**，这种重排序就是允许的。

**重排序的阶段**：源代码 → 编译器优化的重排 → 指令并行的重排 → 内存系统的重排 → 最终执行指令

- **CPU 流水线**：现代 CPU 支持多级指令流水线（如经典的“取指令、指令译码、执行指令、访存取数和结果写回”五级流水线）。CPU 可以在一个时钟周期内，同时运行五条指令的**不同阶段**。这本质上不能缩短单条指令的执行时间，但通过并行处理提高了指令的吞吐率。
- **数据依赖性**：处理器在进行重排序时，必须考虑**指令之间的数据依赖性**。如果一个指令的执行结果是另一个指令的输入，那么这两个指令不能被重排序。
  - **单线程环境**：即使存在指令重排，由于数据依赖性的保证，最终执行结果和代码顺序的结果是一致的。
  - **多线程环境**：线程交替执行时，由于编译器和处理器的优化重排，一个线程可能观察到另一个线程的操作顺序与代码顺序不一致，这可能导致意想不到的错误。

**示例**：著名的“双重检查锁定（DCL）”单例模式中，如果不使用 `volatile`，就可能因为指令重排序导致问题。

```java
class Singleton {
    private static Singleton instance; // 考虑不使用 volatile 的情况

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    // 这行代码可能发生指令重排序
                    // 1. memory = allocate() 分配内存
                    // 2. ctorInstance(memory) 初始化对象
                    // 3. instance = memory 设置 instance 指向内存
                    // 如果重排序为 1 -> 3 -> 2，那么在 3 执行后，另一个线程可能看到非空的 instance，
                    // 但此时对象还未完全初始化，导致访问到半初始化对象。
                    instance = new Singleton(); 
                }
            }
        }
        return instance;
    }
}
```

**解决方案**：使用 `volatile` 关键字：`volatile` 除了保证可见性，还能**禁止指令重排序**（特别是针对 `volatile` 变量的读写操作）。在 DCL 中，`private static volatile Singleton instance;` 可以解决重排序问题。

## Cache

### 缓存机制

#### 缓存结构

在计算机系统中，CPU 高速缓存是处理器内部或紧邻处理器的一小块高速存储区域。它的主要目的是减少处理器访问主内存的平均时间。

- **层次结构**：CPU 缓存位于存储体系的第二层，仅次于 CPU 寄存器。
- **速度与容量**：它的容量远小于主内存，但速度却可以接近处理器的频率。
- **多级缓存**：由于 CPU 速度远超主内存，为了弥补巨大的速度差距，在 CPU 和主内存之间架设了多级缓存，如 L1、L2、L3。这些缓存离 CPU 越近，速度越快，容量越小。它们将处理器频繁操作的数据缓存起来，大大加快了数据访问速度。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-CPU缓存结构.png)

| 从 CPU 到 | 大约需要的时钟周期                |
| --------- | --------------------------------- |
| 寄存器    | 1 cycle (4GHz 的 CPU 约为 0.25ns) |
| L1        | 3~4 cycle                         |
| L2        | 10~20 cycle                       |
| L3        | 40~45 cycle                       |
| 内存      | 120~240 cycle                     |

#### 缓存使用

- **工作原理**：当处理器需要数据时，它首先检查 CPU 缓存中是否有该数据。
  - **命中 (Cache Hit)**：如果数据在缓存中，处理器直接从缓存获取，速度极快，无需访问主内存。
  - **失效 (Cache Miss)**：如果数据不在缓存中，处理器必须先从主内存中把相应的数据块载入到缓存中，然后再将其返回给处理器。
- **局部性原理**：缓存之所以有效，是因为程序在运行时对内存的访问通常具有**局部性**特征：
  - **时间局部性**：如果一个数据项被访问，那么它很可能在不久的将来再次被访问。
  - **空间局部性**：如果一个数据项被访问，那么它附近的内存地址中的数据项也很可能在不久的将来被访问。

有效利用这些局部性，可以使缓存达到很高的命中率。

### 伪共享

**核心概念**：CPU 缓存不是以单个字节为单位加载数据的，而是以固定的**缓存行 (Cache Line)** 为单位。一个缓存行通常是 64 字节（例如，可以存储 8 个 `long` 类型数据）。当 CPU 从主内存获取数据时，会以整个缓存行的大小加载到缓存中。因此，内存中相邻的数据会一并被加载。

**问题描述**：当不同线程操作**独立且不相关的变量**时，如果这些变量恰好位于**同一个缓存行**中，就会发生“伪共享”。

- **数据副本**：同一份数据（包括该缓存行中的所有变量）可能会被缓存在多个 CPU 核心的缓存行中。
- **缓存一致性协议**：为了保证数据一致性，当某个 CPU 核心修改了缓存行中的**任何一个变量**时，其他所有 CPU 核心中对应的**整个缓存行**都必须被标记为**失效 (Invalid)**。
- **性能影响**：即使线程操作的是不同的变量，但由于它们共享同一个缓存行，一个线程的修改会导致其他线程的缓存行失效，迫使它们重新从主内存加载数据，从而频繁地触发缓存同步，降低性能。

**解决方法**：

- **填充 (Padding)**：在变量之间插入无用的填充字段（如 `long` 类型），使得原本相邻的变量落到不同的缓存行中。
- **`@Contended` 注解**：Java 8 引入的 `@sun.misc.Contended` 注解（需要配置 JVM 参数 `-XX:-RestrictContended` 才能生效）可以自动为字段添加填充，将其隔离到独立的缓存行。

### 缓存一致

**定义**：当多个处理器（或核心）同时处理任务，并且它们都涉及到同一块主内存区域时，每个处理器可能会有该内存区域的缓存副本。缓存一致性协议就是为了确保在这些副本之间，数据始终保持一致。

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-缓存一致性.png)

**MESI 协议**：MESI (Modified Exclusive Shared Invalid) 是一种广泛使用的**支持写回 (Write-Back) 策略**的缓存一致性协议。它通过给每个缓存行标记四种状态来管理一致性：

- **M (Modified - 已修改)**：该缓存行只存在于当前 CPU 的缓存中，并且已被修改过，与主内存中的数据不一致（是“脏”的）。它最终需要被写回主内存。
  - 当再次修改时，无需通知其他核心。
  - 写回主内存后，状态会变为 E (独享)。
- **E (Exclusive - 独享)**：该缓存行只存在于当前 CPU 的缓存中，但**未被修改**过，与主内存数据一致。
  - 当 CPU 修改该缓存行内容时，状态变为 M。
  - 当其他 CPU 读取该内存时，状态变为 S (共享)。
- **S (Shared - 共享)**：该缓存行可能存在于多个 CPU 的缓存中，并且所有缓存中的数据都与主内存数据一致。
  - 当当前 CPU 修改该缓存行内容时，它会向总线广播一个**失效请求 (Invalidate Request)**，通知其他 CPU 将其对应的缓存行标记为 I (无效)，然后当前缓存行状态变为 M。
- **I (Invalid - 无效)**：该缓存行的数据是无效的，可能因为其他 CPU 修改了它。当 CPU 访问该缓存行时，必须重新从主内存加载。

**作用**：MESI 协议确保了在多核 CPU 环境下，对共享数据的修改能够被所有核心正确地感知和同步。

### 处理机制

在多核 CPU 环境下，为了解决缓存数据不一致的问题，处理器提供了两种主要的机制：

1. **总线锁定 (Bus Locking)**：
    - **原理**：当一个处理器需要对共享变量进行操作时，它会在 CPU 总线上发出一个 `LOCK#` 信号。这个信号会**锁定整个总线**，阻止其他处理器访问主内存，从而确保当前处理器对共享变量的操作是独占的。
    - **缺点**：总线锁定会导致其他处理器完全停滞，等待总线释放，从而引入大量阻塞，严重增加系统性能开销，降低并发度。
    - **使用场景**：当操作的数据跨多个缓存行，或者数据未被缓存到处理器内部时，处理器可能会使用总线锁定。一些旧的处理器不支持缓存锁定（如 Intel 486 和 Pentium）也会使用总线锁定。

2. **缓存锁定 (Cache Locking)**：
    - **原理**：这是更高效的方式。当处理器对**缓存中的共享变量**进行操作时，它会利用**缓存一致性协议**（如 MESI）来保证数据一致性。
        - **嗅探机制 (Snooping)**：每个处理器都会“嗅探”总线上的数据传播。当一个处理器发现自己缓存中的数据对应的内存地址被其他处理器修改时，它会**将自己缓存中的该缓存行标记为无效状态 (Invalid)**。
        - **重新加载**：当处理器再次尝试访问这个被标记为无效的数据时，它会强制从主内存中重新读取最新的数据到自己的缓存中。
    - **优点**：相比总线锁定，缓存锁定只影响相关的缓存行，其他不相关的数据访问可以继续进行，大大提高了并发性能。

**总线机制的补充说明**：

- **总线嗅探 (Bus Snooping)**：是缓存一致性协议的基础。每个处理器持续监听总线上的所有内存事务。当它发现其他处理器发出了对某个内存地址的写入请求，并且这个地址的数据正好在自己的缓存中时，它就会根据协议（如 MESI）将自己缓存中的对应缓存行标记为无效。
- **总线风暴 (Bus Storm)**：当系统中有大量共享变量被频繁修改时，会导致总线上出现大量的缓存同步（如失效广播）和数据传输操作。CPU 需要不断监听总线活动，并且频繁地使缓存行失效并重新加载，这会占用大量的总线带宽，导致总线成为性能瓶颈，这种现象被称为“总线风暴”。
  - **提示**：因此，过度使用 `volatile` 关键字或 `synchronized` 锁（尤其是在高竞争场景下）都可能导致频繁的缓存同步和总线流量，需要根据实际场景进行权衡和优化。

## volatile

### 同步机制

volatile 是 Java 虚拟机提供的**轻量级**的同步机制（三大特性）

- 保证可见性
- 不保证原子性
- 保证有序性（禁止指令重排）

性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小

synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性

- 加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的
- 线程加锁前，将**清空工作内存**中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值**刷新到主内存**中（JMM 内存交互章节有讲）

### 指令重排

volatile 修饰的变量，可以禁用指令重排

指令重排实例：

- example 1:

    ```java
    public void mySort() {
        int x = 11; //语句 1
        int y = 12; //语句 2  谁先执行效果一样
        x = x + 5;  //语句 3
        y = x - x;  //语句 4
    }
    ```

  执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4

  指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行

- example 2:

    ```java
    int num = 0;
    boolean ready = false;
    // 线程 1 执行此方法
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    // 线程 2 执行此方法
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
    ```

  情况一：线程 1 先执行，ready = false，结果为 r.r1 = 1
  
  情况二：线程 2 先执行 num = 2，但还没执行 ready = true，线程 1 执行，结果为 r.r1 = 1
  
  情况三：线程 2 先执行 ready = true，线程 1 执行，进入 if 分支结果为 r.r1 = 4
  
  情况四：线程 2 执行 ready = true，切换到线程 1，进入 if 分支为 r.r1 = 0，再切回线程 2 执行 num = 2，发生指令重排

### 底层原理

#### 缓存一致

使用 volatile 修饰的共享变量，底层通过汇编 lock 前缀指令进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程通过 CPU 总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据

lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

内存屏障有三个作用：

- 确保对内存的读 - 改 - 写操作原子执行
- 阻止屏障两侧的指令重排序
- 强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效

#### 内存屏障

保证**可见性**：

- 写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中

    ```java
    public void actor2(I_Result r) {
        num = 2;
        ready = true; // ready 是 volatile 赋值带写屏障
        // 写屏障
    }
    ```

- 读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据

    ```java
    public void actor1(I_Result r) {
        // 读屏障
        // ready 是 volatile 读取值带读屏障
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;" />

- 全能屏障：mfence（modify/mix Barrier），兼具 sfence 和 lfence 的功能

保证**有序性**：

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

不能解决指令交错：

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前

- 有序性的保证也只是保证了本线程内相关代码不被重排序

    ```java
    volatile i = 0;
    new Thread(() -> {i++});
    new Thread(() -> {i--});
    ```

    i++ 反编译后的指令：

    ```java
    0: iconst_1         // 当 int 取值 -1~5 时，JVM 采用 iconst 指令将常量压入栈中
    1: istore_1         // 将操作数栈顶数据弹出，存入局部变量表的 slot 1
    2: iinc     1, 1
    ```

  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;" />

#### 交互规则

对于 volatile 修饰的变量：

- 线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载
- 线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存
- 线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排

### 双端检锁

#### 检锁机制

Double-Checked Locking：双端检锁机制

DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    
    public static Singleton getInstance() {
        if(INSTANCE == null) { // t2，这里的判断不是线程安全的
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化
                if (INSTANCE == null) { 
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

不锁 INSTANCE 的原因：

- INSTANCE 要重新赋值
- INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用

实现特点：

- 懒惰初始化
- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题

#### DCL 问题

getInstance 方法对应的字节码为：

```java
0:  getstatic       #2      // Field INSTANCE:Ltest/Singleton;
3:  ifnonnull       37
6:  ldc             #3      // class test/Singleton
8:  dup
9:  astore_0
10: monitorenter
11: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
14: ifnonnull 27
17: new             #3      // class test/Singleton
20: dup
21: invokespecial   #4      // Method "<init>":()V
24: putstatic       #2      // Field INSTANCE:Ltest/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic       #2      // Field INSTANCE:Ltest/Singleton;
40: areturn
```

- 17 表示创建对象，将对象引用入栈
- 20 表示复制一份对象引用，引用地址
- 21 表示利用一个对象引用，调用构造方法初始化对象
- 24 表示利用一个对象引用，赋值给 static INSTANCE

**步骤 21 和 24 之间不存在数据依赖关系**，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的

- 关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值
- 当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL出现的问题.png)

#### 解决方法

指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性

引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：

```java
private static volatile SingletonDemo INSTANCE = null;
```

## ha-be

happens-before 先行发生

Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结

不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性

1. 程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序

2. 锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见

3. **volatile 变量规则**  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读

4. 传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C

5. 线程启动规则 (Thread Start Rule)：Thread 对象的 start() 方 法先行发生于此线程中的每一个操作

    ```java
    static int x = 10;//线程 start 前对变量的写，对该线程开始后对该变量的读可见
    new Thread(()->{ System.out.println(x);  },"t1").start();
    ```

6. 线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7. 线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行

8. 对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始

## 设计模式

### 终止模式

终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性

```java
class TwoPhaseTermination {
    // 监控线程
    private Thread monitor;
    // 停止标记
    private volatile boolean stop = false;;

    // 启动监控线程
    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                Thread thread = Thread.currentThread();
                if (stop) {
                    System.out.println("后置处理");
                    break;
                }
                try {
                    Thread.sleep(1000);// 睡眠
                    System.out.println(thread.getName() + "执行监控记录");
                } catch (InterruptedException e) {
                    System.out.println("被打断，退出睡眠");
                }
            }
        });
        monitor.start();
    }

    // 停止监控线程
    public void stop() {
        stop = true;
        monitor.interrupt();// 让线程尽快退出 Timed Waiting
    }
}
// 测试
public static void main(String[] args) throws InterruptedException {
    TwoPhaseTermination tpt = new TwoPhaseTermination();
    tpt.start();
    Thread.sleep(3500);
    System.out.println("停止监控");
    tpt.stop();
}
```

### Balking

Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回

```java
public class MonitorService {
    // 用来表示是否已经有线程已经在执行启动了
    private volatile boolean starting = false;
    public void start() {
        System.out.println("尝试启动监控线程...");
        synchronized (this) {
            if (starting) {
                return;
            }
            starting = true;
        }
        // 真正启动监控线程...
    }
}
```

对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待

例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：

- 当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为 f alse，则 t2 就又初始化一次
- volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁

```java
public class TestVolatile {
    volatile boolean initialized = false;
    
    void init() {
        if (initialized) {
            return;
        }
        doInit();
        initialized = true;
    }
    private void doInit() {
    }
}
```
