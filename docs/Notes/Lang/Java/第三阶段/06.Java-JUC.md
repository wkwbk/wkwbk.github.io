# Java | JUC

JUC 是 `java.util.concurrent` 包的缩写，是 Java 并发编程的核心工具包。它提供了一系列用于处理多线程编程的类和接口，旨在简化并发编程的复杂性，提高程序性能和可靠性。

> <https://www.bilibili.com/video/BV16J411h7Rd>

## 基本概念

### 进程与线程

- 进程
- 线程
- 两者对比

### 并发与并行

- 并发
- 并行
- 串行，单核 CPU 并行在微观上任然是串行

> 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
>
> 并行（parallel）是同一时间动手做（doing）多件事情的能力

### 同步与异步

> 需要等待结果返回，才能继续运行就是同步
>
> 不需要等待结果返回，就能继续运行就是异步

### 阻塞与非阻塞

- IO 操作不占用 CPU，只是我们一般拷贝文件使用的是**阻塞 IO**，这时相当于线程虽然不用 CPU，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的**非阻塞 IO**和**异步 IO**优化

## 创建和运行线程

### 方法一：直接使用 Thread

```java
//创建线程对象
Thread t = new Thread() {
    public void run() {
        //要执行的任务
    }
};

//启动线程
t.start();
```

### 方法二：使用 Runnable

- 把【线程】和【任务】（要执行的代码）分开
- `Thread` 代表线程
- `Runnable` 可运行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable() {
    public void run() {
        //要执行的任务
    }
};
//创建线程对象
Thread t = new Thread(runnable);
//启动线程
t.start();
```

Java8 以后可以使用 lambda 精简代码

```java
//创建任务对象
Runnable task2 = () -> log.debug("hello");
//参数 1 是任务对象；参数 2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

#### 原理

- 方法一，是把线程和任务合并在了一起
- 方法二，是把线程和任务分开了
- 用 `Runnable` 更容易与线程池等高级 API 配合
- 用 `Runnable` 让任务类脱离了 `Thread` 继承体系，更灵活

### 方法三：FutureTask

`FutureTask` 能够接收 `Callable` 类型的参数，用来处理有返回结果的情况

```java
//创建任务对象
FutureTask<Integer> task3 = new FutureTask<>(() -> {
    log.debug("hello");
    return 100;
});

//参数 1 是任务对象；参数 2 是线程名字，推荐
new Thread(task3, "t3").start();

//主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
log.debug("结果是:{}", result);
```

## 查看进程线程的方法

### Windows

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- `tasklist` 查看进程
- `taskkill` 杀死进程

### Linux

- `ps -fe` 查看所有进程
- `ps -fT -p <PID>` 查看某个进程（PID）的所有线程
- `kill` 杀死进程
- `top` 按大写 H 切换是否显示线程
- `top -H -p <PID>` 查看某个进程（PID）的所有线程

### Java

- `ps` 命令查看所有 Java 进程
- `jstack <PID>` 查看某个 Java 进程（PID）的所有线程状态
- `jconsole` 来查看某个 Java 进程中线程的运行情况（图形界面）

### jconsole 远程监控配置

- 需要以如下方式运行你的 java 类

  ```shell
  java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 java 类
  ```

- 修改 `/etc/hosts` 文件将 `127.0.0.1` 映射至主机名

如果要认证访问，还需要做如下步骤

- 复制 `jmxremote.password` 文件
- 修改 `jmxremote.password` 和 `jmxremote.access` 文件的权限为 `600` 即文件所有者可读写
- 连接时填入 `controlRole` (用户名) , `R&D` (密码)

## 线程运行原理

### 栈与栈帧

JVM 中的栈（Java Virtual Machine Stacks）内存是为线程服务的。每个线程启动后，虚拟机会为其分配一块栈内存。

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

### 线程上下文切换 (Thread Context Switch)

- **原因**：由于以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码
  - 线程的 CPU 时间片用完
  - 垃圾回收
  - 有更高优先级的线程需要运行
  - 线程自己调用了 `sleep`、`yield`、`wait`、`join`、`park`、`synchronized`、`lock` 等方法

- **过程**：当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态。Java 中对应的概念就是**程序计数器**（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。

- **状态**：状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。

- **影响**：上下文切换频繁发生会影响性能。

## 常见方法

| 方法名                         | 功能说明                                                           | 注意                                                                                                                                                                                        |
| :----------------------------- | :----------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `start()`                      | 启动一个新线程，在新线程中运行 `run()` 方法中的代码                | `start()` 方法只是让线程进入就绪状态，里面的代码不一定立刻运行。每个线程对象的 `start()` 方法只能调用一次，否则会出现 `IllegalThreadStateException`                                         |
| `run()`                        | 新线程启动后会调用的方法                                           | 如果在构造 `Thread` 对象时传递了 `Runnable` 参数，则线程启动后会调用 `Runnable` 中的 `run()` 方法，否则默认不执行任何操作。但可以创建 `Thread` 的子类对象，来覆盖默认行为                   |
| `join()`                       | 等待线程运行结束                                                   |                                                                                                                                                                                             |
| `join(long n)`                 | 等待线程运行结束，最多等待 `n` 毫秒                                |                                                                                                                                                                                             |
| `getId()`                      | 获取线程长整型的 id                                                | id 唯一                                                                                                                                                                                     |
| `getName()`                    | 获取线程名                                                         |                                                                                                                                                                                             |
| `setName(String)`              | 修改线程名                                                         |                                                                                                                                                                                             |
| `getPriority()`                | 获取线程优先级                                                     |                                                                                                                                                                                             |
| `setPriority(int)`             | 修改线程优先级                                                     | Java 中规定线程优先级是 1~10 的整数，较大的优先级能提高该线程被 CPU 调度的几率                                                                                                              |
| `getState()`                   | 获取线程状态                                                       | Java 中线程状态是用 6 个 `enum` 表示，分别为：`NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, `TERMINATED`                                                                        |
| `isInterrupted()`              | 判断是否被打断                                                     | 不会清除打断标记                                                                                                                                                                            |
| `isAlive()`                    | 线程是否存活（还没有运行完毕）                                     |                                                                                                                                                                                             |
| `interrupt()`                  | 打断线程                                                           | 如果被打断线程正在 `sleep`, `wait`, `join` 会导致被打断的线程抛出 `InterruptedException`，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记；`park` 的线程被打断，也会设置打断标记 |
| `interrupted()` **(static)**   | 判断当前线程是否被打断                                             | 会清除打断标记                                                                                                                                                                              |
| `currentThread()` **(static)** | 获取当前正在执行的线程                                             |                                                                                                                                                                                             |
| `sleep(long n)` **(static)**   | 让当前执行的线程休眠 `n` 毫秒，休眠时会让出 cpu 的时间片给其它线程 |                                                                                                                                                                                             |
| `yield()` **(static)**         | 提示线程调度器让出当前线程对 CPU 的使用                            | 主要是为了测试和调试                                                                                                                                                                        |

## 不推荐的方法

还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁。

| 方法名 | 功能说明 |
| :--- | :--- |
| `stop()` | 停止线程运行 |
| `suspend()` | 挂起（暂停）线程运行 |
| `resume()` | 恢复线程运行 |

## 主线程与守护线程

默认情况下，Java 进程需要等待所有非守护线程都运行结束，才会结束。

有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

**例：**

```java
log.debug("开始运行...");
Thread t1 = new Thread(() -> {
    log.debug("开始运行...");
    sleep(2);
    log.debug("运行结束...");
}, "daemon");
// 设置该线程为守护线程
t1.setDaemon(true);
t1.start();

sleep(1);
log.debug("运行结束...");
```

**注意**

- 垃圾回收器线程就是一种守护线程。
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求。

## 线程状态

### 五种状态

这是从**操作系统**层面来描述的。

- **【初始状态】**：仅是在语言层面创建了线程对象，还未与操作系统线程关联。
- **【可运行状态】**（就绪状态）：指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行。
- **【运行状态】**：指获取了 CPU 时间片运行中的状态。
  - 当 CPU 时间片用完，会从【运行状态】转换为【可运行状态】，会导致线程的上下文切换。
- **【阻塞状态】**：
  - 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】。
  - 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换为【可运行状态】。
  - 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们。
- **【终止状态】**：表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。

### 六种状态

这是从 **Java 语言** 层面来描述的。

- **【NEW】**：线程刚被创建，但是还没有调用 `start()` 方法。
- **【RUNNABLE】**：当调用了 `start()` 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）。
- **【BLOCKED】**：线程正在等待锁的释放。
- **【WAITING】**：线程进入等待状态，例如调用了 `wait()`、`join()` 方法。
- **【TIMED_WAITING】**：线程进入限时等待状态，例如调用了 `sleep(long)` 方法。
- **【TERMINATED】**：线程执行完毕，生命周期结束。

### 状态转换

#### 情况 1 NEW -> RUNNABLE

- 当调用 `t.start()` 方法时，由 `NEW -> RUNNABLE`

#### 情况 2 RUNNABLE <-> WAITING

`t` 线程用 `synchronized(obj)` 获取了对象锁后

- 调用 `obj.wait()` 方法时，`t` 线程从 `RUNNABLE -> WAITING`
- 调用 `obj.notify()`，`obj.notifyAll()`，`t.interrupt()` 时
  - 竞争锁成功，`t` 线程从 `WAITING -> RUNNABLE`
  - 竞争锁失败，`t` 线程从 `WAITING -> BLOCKED`

```java
public class TestWaitNotify {
    final static Object obj = new Object();
    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}
```

#### 情况 3 RUNNABLE <-> WAITING

- 当前线程调用 `t.join()` 方法时，当前线程从 `RUNNABLE -> WAITING`
  - 注意是当前线程在 `t` 线程对象的监视器上等待
- `t` 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从 `WAITING -> RUNNABLE`

#### 情况 4 RUNNABLE <-> WAITING

- 当前线程调用 `LockSupport.park()` 方法会让当前线程从 `RUNNABLE -> WAITING`
- 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()`，会让目标线程从 `WAITING -> RUNNABLE`

#### 情况 5 RUNNABLE <-> TIMED_WAITING

`t` 线程用 `synchronized(obj)` 获取了对象锁后

- 调用 `obj.wait(long n)` 方法时，`t` 线程从 `RUNNABLE -> TIMED_WAITING`
- `t` 线程等待时间超过了 `n` 毫秒，或调用 `obj.notify()`，`obj.notifyAll()`，`t.interrupt()` 时
  - 竞争锁成功，`t` 线程从 `TIMED_WAITING -> RUNNABLE`
  - 竞争锁失败，`t` 线程从 `TIMED_WAITING -> BLOCKED`
  
#### 情况 6 RUNNABLE <-> TIMED_WAITING

- 当前线程调用 `t.join(long n)` 方法时，当前线程从 `RUNNABLE -> TIMED_WAITING`
- 注意是当前线程在 `t` 线程对象的监视器上等待
- 当前线程等待时间超过了 `n` 毫秒，或 `t` 线程运行结束，或调用了当前线程的 `interrupt()` 时，当前线程从 `TIMED_WAITING -> RUNNABLE`

#### 情况 7 RUNNABLE <-> TIMED_WAITING

- 当前线程调用 `Thread.sleep(long n)`，当前线程从 `RUNNABLE -> TIMED_WAITING`
- 当前线程等待时间超过了 `n` 毫秒，当前线程从 `TIMED_WAITING -> RUNNABLE`

#### 情况 8 RUNNABLE <-> TIMED_WAITING

- 当前线程调用 `LockSupport.parkNanos(long nanos)` 或 `LockSupport.parkUntil(long millis)` 时，当前线程从 `RUNNABLE -> TIMED_WAITING`
- 调用 `LockSupport.unpark(目标线程)` 或调用了线程的 `interrupt()`，或是等待超时，会让目标线程从 `TIMED_WAITING -> RUNNABLE`

#### 情况 9 RUNNABLE <-> BLOCKED

- `t` 线程用 `synchronized(obj)` 获取了对象锁时如果竞争失败，从 `RUNNABLE -> BLOCKED`
- 持 `obj` 锁线程的同步代码块执行完毕，会唤醒该对象上所有 `BLOCKED` 的线程重新竞争，如果其中 `t` 线程竞争成功，从 `BLOCKED -> RUNNABLE`，其它失败的线程仍然 `BLOCKED`

#### 情况 10 RUNNABLE <-> TERMINATED

当前线程所有代码运行完毕，进入 `TERMINATED`

## 共享模型

- 上下文切换
- 临界区
- 竞态条件

## 临界区与竞态条件

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

- **阻塞式的解决方案**：`synchronized`，`Lock`
- **非阻塞式的解决方案**：原子变量

本次课使用阻塞式的解决方案：`synchronized`，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

**注意**

虽然 Java 中互斥和同步都可以采用 `synchronized` 关键字来完成，但它们还是有区别的：

- **互斥**是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码。
- **同步**是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点。

### synchronized

synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。

`synchronized` 关键字用在方法上，锁住的是 `this` 对象。

```java
class Test {
    public synchronized void test() {
        // ...
    }
}

// 等价于
class Test {
    public void test() {
        synchronized(this) {
            // ...
        }
    }
}
```

`synchronized` 关键字用在静态方法上，锁住的是类对象。

```java
class Test {
    public synchronized static void test() {
        // ...
    }
}

// 等价于
class Test {
    public static void test() {
        synchronized(Test.class) {
            // ...
        }
    }
}
```

## 线程安全分析

### 变量与线程安全

### 成员变量和静态变量

- 如果它们没有共享，则线程安全。
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况：
  - 如果只有读操作，则线程安全。
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全。

### 局部变量

- 局部变量是线程安全的。
- 但局部变量引用的对象则未必：
  - 如果该对象没有逃离方法的作用访问，它是线程安全的。
  - 如果该对象逃离方法的作用范围，需要考虑线程安全。

### 常见线程安全类

- `String`
- `Integer`
- `StringBuffer`
- `Random`
- `Vector`
- `Hashtable`
- `java.util.concurrent` 包下的类

这里说它们是线程安全的，是指多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为：

- 它们的每个方法是原子的。
- 但**注意**它们多个方法的组合不是原子的。

## Monitor 概念

### Java 对象头

以 32 位虚拟机为例

#### 普通对象

```txt
|----------------------------------------------------------------|
|                   Object Header (64 bits)                      |
|----------------------------------------|-----------------------|
|           Mark Word (32 bits)          |  Klass Word (32 bits) |
|----------------------------------------|-----------------------|
```

#### 数组对象

```txt
|----------------------------------------------------------------------------------|
|                            Object Header (96 bits)                               |
|--------------------------------|-----------------------|-------------------------|
|       Mark Word (32bits)       |   Klass Word (32bits) |  array length (32bits)  |
|--------------------------------|-----------------------|-------------------------|
```

#### Mark Word 结构

```txt
|-------------------------------------------------------|---------------------|
|                Mark Word (32 bits)                    |        State        |
|-------------------------------------------------------|---------------------|
|  hashcode:25             | age:4 | biased_lock:0 | 01 |        Normal       |
|-------------------------------------------------------|---------------------|
|  thread:23 |   epoch:2   | age:4 | biased_lock:1 | 01 |        Biased       |
|-------------------------------------------------------|---------------------|
|             ptr_to_lock_record:30                | 00 |  Lightweight Locked |
|-------------------------------------------------------|---------------------|
|          ptr_to_heavyweight_monitor:30           | 10 |  Heavyweight Locked |
|-------------------------------------------------------|---------------------|
|                                                  | 11 |     Marked for GC   |
|-------------------------------------------------------|---------------------|
```

```txt
|----------------------------------------------------------------------|--------------------|
|                Mark Word (64 bits)                                   |       State        |
|----------------------------------------------------------------------|--------------------|
| unused:25 | hashcode:31 | unused:1  |  age:4  |  biased_lock:0  | 01 |       Normal       |
|----------------------------------------------------------------------|--------------------|
| thread:54 | epoch:2     | unused:1  |  age:4  |  biased_lock:1  | 01 |       Biased       |
|----------------------------------------------------------------------|--------------------|
|                    ptr_to_lock_record:62                        | 00 | Lightweight Locked |
|----------------------------------------------------------------------|--------------------|
|                ptr_to_heavyweight_monitor:62                    | 10 | Heavyweight Locked |
|----------------------------------------------------------------------|--------------------|
|                                                                 | 11 |    Marked for GC   |
|----------------------------------------------------------------------|--------------------|
```

### Monitor (重量级锁)

Monitor 被翻译为监视器或**管程**。

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 `synchronized` 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针。

Monitor 结构如下：

- `WaitSet`：关联了所有处于 `WAITING` 状态的线程。
- `EntryList`：关联了所有处于 `BLOCKED` 状态的线程，它们都会竞争 `Owner` 的所有权。
- `Owner`：初始时为 `null`，当有线程占有该 Monitor 时，Owner 指向这个线程。

注意：

- synchronized 必须是进入同一个对象的 monitor 才有上述的效果
- 不加 synchronized 的对象不会关联监视器，不遵从以上规则

### 轻量级锁

- **使用场景**：如果一个对象虽然有多个线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。
- 轻量级锁对使用者是透明的，即语法仍然是 `synchronized`。

假设有两个方法同步块，利用同一个对象加锁：

```java
static final Object obj = new Object();

public static void method1() {
    synchronized(obj) {
        // 同步块 A
        method2();
    }
}

public static void method2() {
    synchronized(obj) {
        // 同步块 B
    }
}
```

### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块
    }
}
```

- 当 `Thread-1` 进行轻量级加锁时，`Thread-0` 已经对该对象加了轻量级锁。

### 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候待锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

**自旋重试成功的情况**

| 线程 1 (cpu 1 上)        | 对象 Mark              | 线程 2 (cpu 2 上)        |
| :----------------------- | :--------------------- | :----------------------- |
| -                        | 10 (重量锁)            | -                        |
| 访问同步块，获取 monitor | 10 (重量锁) 重量锁指针 | -                        |
| 成功 (加锁)              | 10 (重量锁) 重量锁指针 | -                        |
| 执行同步块               | 10 (重量锁) 重量锁指针 | -                        |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 访问同步块，获取 monitor |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 自旋重试                 |
| 执行完毕                 | 10 (重量锁) 重量锁指针 | 自旋重试                 |
| 成功 (解锁)              | 01 (无锁)              | 自旋重试                 |
| -                        | 10 (重量锁) 重量锁指针 | 成功 (加锁)              |
| -                        | 10 (重量锁) 重量锁指针 | 执行同步块               |

**自旋重试失败的情况**

| 线程 1 (cpu 1 上)        | 对象 Mark              | 线程 2 (cpu 2 上)        |
| :----------------------- | :--------------------- | :----------------------- |
| -                        | 10 (重量锁)            | -                        |
| 访问同步块，获取 monitor | 10 (重量锁) 重量锁指针 | -                        |
| 成功 (加锁)              | 10 (重量锁) 重量锁指针 | -                        |
| 执行同步块               | 10 (重量锁) 重量锁指针 | -                        |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 访问同步块，获取 monitor |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 自旋重试                 |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 自旋重试                 |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 自旋重试                 |
| 执行同步块               | 10 (重量锁) 重量锁指针 | 阻塞                     |

在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。

自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。

Java 7 之后不能控制是否开启自旋功能

### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有

例如：

```java
static final Object obj = new Object();
public static void m1() {
    synchronized( obj ) {
        // 同步块 A
        m2();
    }
}
public static void m2() {
    synchronized( obj ) {
        // 同步块 B
        m3();
    }
}
public static void m3() {
    synchronized( obj ) {
        // 同步块 C
    }
}
```

**偏向锁状态**

一个对象创建时：

- 如果开启了偏向锁 (默认开启)，那么对象创建后，markword 值为 0x05 即最后 3 位为 `101`，这时它的 thread、epoch、age 都为 0
- 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 `-XX:BiasedLockingStartupDelay=0` 来禁用延迟
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值
- 处于偏向锁的对象解锁后，线程 id 仍存储于对象头中
- 添加 VM 参数 `-XX:-UseBiasedLocking` 可以禁用偏向锁，`-XX:+UseBiasedLocking` 启用偏向锁，默认是启用
- 升级过程：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

撤销偏向锁的状态：

- 调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashcode 导致偏向锁被撤销，原因是只有 MarkWord 在 Normal 模式下才能存放下 hashcode
- 当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁
- 调用 wait/notify，需要申请 Monitor，进入 WaitSet

批量重偏向：

- 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID
- 当撤销偏向锁阀值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程

批量撤销：

- 当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的

## 锁消除

锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM **即时编译器的优化**

锁消除主要是通过**逃逸分析**来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）

## 锁粗化

对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化

如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部

> 锁粗化（Lock Coarsening）是一种 JVM（Java 虚拟机）的优化技术，旨在减少不必要的锁获取和释放操作，从而提高程序的性能。
>
> 当 JVM 检测到一系列连续的操作都对同一个锁对象进行加锁和解锁时，它可能会将这些分散的加锁/解锁操作合并（粗化）为一个更大的锁区域，只在整个操作序列的开始处加锁，在结束处解锁。

- 一些看起来没有加锁的代码，其实隐式的加了很多锁：

  ```java
  public static String concatString(String s1, String s2, String s3) {
      return s1 + s2 + s3;
  }
  ```

- String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块

  ```java
  public static String concatString(String s1, String s2, String s3) {
      StringBuffer sb = new StringBuffer();
      sb.append(s1);
      sb.append(s2);
      sb.append(s3);
      return sb.toString();
  }
  ```

扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以

## wait/notify

- Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态
- BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片
- BLOCKED 线程会在 Owner 线程释放锁时唤醒
- WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争

API：

- `obj·wait()` 让进入 object 监视器的线程到 waitSet 等待
- `obj.notify()` 在 object 上正在 waitSet 等待的线程中挑一个唤醒
- `obj.notifyAll()` 让 object 上正在 waitSet 等待的线程全部唤醒
- `wait()` 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 `notify` 为止
- `wait(long n)` 有时限的等待，到 n 毫秒后结束等待，或是被 `notify`

它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法

`sleep(long n)` 和 `wait(long n)`：

区别：

- sleep 是 Thread 方法，而 wait 是 Object 的方法
- sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用
- sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁。

共同点：

- 它们线程状态都是 TIMED_WAITING（注意：不带参的 `wait()` 是 WAITING）

### 正确使用姿势

虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程

解决方法：采用 notifyAll

notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断

解决方法：用 while + wait，当条件不成立，再次 wait

```java
synchronized(lock) {
    while(条件不成立) {
        lock.wait();
    }
    // 干活
}

// 另一个线程
synchronized(lock) {
    lock.notifyAll();
}
```

## 异步模式

### 保护性暂停

即 Guarded Suspension，用在一个线程等待另一个线程的执行结果

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject
- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）
- JDK 中，join 的实现、Future 的实现，采用的就是此模式
- 因为要等待另一方的结果，因此归类到同步模式

## 异步模式

### 生产者/消费者

- 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应
- 消费队列可以用来平衡生产和消费的线程资源
- 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据
- 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
- JDK 中各种阻塞队列，采用的就是这种模式

## Park/Unpark

### 基本使用

它们是 `LockSupport` 类中的方法

```java
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象);
```

### 特点

与 `Object` 的 `wait`/`notify` 相比

- `wait`, `notify` 和 `notifyAll` 必须配合 `Object Monitor` 一起使用，而 `park`，`unpark` 不必
- `park`/`unpark` 是以线程为单位来【阻塞】和【唤醒】线程，而 `notify` 只能随机唤醒一个等待线程，`notifyAll` 是唤醒所有等待线程，就不那么【精确】
- `park`/`unpark` 可以先 `unpark`，而 `wait`/`notify` 不能先 `notify`（先 `notify` 是无效的）

## 多把锁

将锁的粒度细分

- 好处，是可以增强并发度
- 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁

## 活跃性

### 死锁

有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁

- t2 线程获得 B 对象锁，接下来想获取 A 对象的锁
- t1 线程获得 A 对象锁，接下来想获取 B 对象的锁

定位死锁：

- 检测死锁可以使用 jconsole 工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁

### 活锁

活锁出现在两个线程互相改变对方的结束条件，最后准也无法结束

### 饥饿锁

一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束

## ReentrantLock

相对于 `synchronized` 它具备如下特点：

- 可中断
- 可以设置超时时间
- 可以设置为公平锁
- 支持多个条件变量

与 `synchronized` 一样，都支持可重入。

### 可重入

- 可重入是指同一个线程如果首次获得了这把锁，那么因为它就是这把锁的拥有者，因此有权利再次获取这把锁。
- 如果不是可重入锁，那么第二次获得锁时，自己也会被锁挡住。

### 可打断

`public void lockInterruptibly()`：获得可打断的锁

- 如果没有竞争此方法就会获取 lock 对象锁
- 如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断

注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断

### 锁超时

`public boolean tryLock()`：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列

`public boolean tryLock(long timeout, TimeUnit unit)`：在给定时间内获取锁，获取不到就退出

注意：tryLock 期间也可以被打断

### 公平锁

构造方法：`ReentrantLock lock = new ReentrantLock(true)`

```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

ReentrantLock 默认是不公平的：

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

说明：公平锁一般没有必要，会降低并发度

### 条件变量

`synchronized` 中也有条件变量，就是我们讲原理时那个 `waitSet` 休息室，当条件不满足时进入 `waitSet` 等待。
`ReentrantLock` 的条件变量比 `synchronized` 强大之处在于，它是支持多个条件变量的，这就好比：

- `synchronized` 是那些不满足条件的线程都在一间休息室等消息
- 而 `ReentrantLock` 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒

使用流程：

- `await` 前需要获得锁
- `await` 执行后，会释放锁，进入 `conditionObject` 等待
- `await` 的线程被唤醒（或打断、或超时）取重新竞争 `lock` 锁
- 竞争 `lock` 锁成功后，从 `await` 后继续执行

## Java 内容模型

JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

JMM 体现在以下几个方面

- 原子性－保证指令不会受到线程上下文切换的影响
- 可见性－保证指令不会受 cpu 缓存的影响
- 有序性－保证指令不会受 cpu 指令并行优化的影响

### 可见性

是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是**不可变**的，就算有缓存，也不会存在不可见的问题

main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：

```java
static boolean run = true;      // 添加 volatile
public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(()->{
        while(run){
        // ....
        }
    });
    t.start();
    sleep(1);
    run = false;    // 线程 t 不会如预想的停下来
}
```

原因：

- 初始状态，t 线程刚开始从主内存读取了 run 的值到工作内存
- 因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率
- 1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

解决方法

volatile（易变关键字）：它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存

### 原子性

原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响

定义原子操作的使用规则：

1. 不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续
2. 不允许一个线程丢弃 assign 操作，必须同步回主存
3. 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中
4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作
5. 一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有**执行相同次数的 unlock** 操作，变量才会被解锁，**lock 和 unlock 必须成对出现**
6. 如果对一个变量执行 lock 操作，将会**清空工作内存中此变量的值**，在执行引擎使用这个变量之前需要重新从主存加载
7. 如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量
8. 对一个变量执行 unlock 操作之前，必须**先把此变量同步到主内存**中（执行 store 和 write 操作）

### 有序性

有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序

CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：

```java
源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行指令
```

现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为**五级指令流水线**。CPU 可以在一个时钟周期内，同时运行五条指令的**不同阶段**（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率

处理器在进行重排序时，必须要考虑**指令之间的数据依赖性**

- 单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致
- 多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行

补充知识：

- 指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成
- 机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期
- 振荡周期指周期性信号作周期性重复变化的时间间隔
