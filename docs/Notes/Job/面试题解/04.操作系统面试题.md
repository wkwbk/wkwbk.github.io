# 操作系统面试题

::: details 线程和进程有什么区别？

- **进程（Process）**：就像一个独立的**工厂**。这个工厂有自己的地盘（内存空间），自己的机器设备（资源，比如文件、网络连接），自己的工人（线程），并且它能独立生产产品（执行任务）。一个工厂倒闭了，不会影响其他工厂正常运转。
  - **特点**：独立性强，资源开销大，但很安全。
- **线程（Thread）**：就像工厂里的**工人**。一个工厂里可以有很多工人，这些工人共享工厂的设备和材料（共享进程的内存和资源），他们各自负责生产流程中的一个环节，或者一起完成一个大任务。如果一个工人偷懒了，可能会影响整个工厂的生产效率；如果他搞砸了生产线，整个工厂可能都会受影响。
  - **特点**：共享资源，开销小，切换快，但相互影响大（一个线程出问题容易影响整个进程）。

**打个比方：**

你正在用电脑看电影（一个进程），同时打开了 Word 文档在写东西（另一个进程），这两个任务互不干扰。

电影播放器这个“工厂”里，一个“工人”（线程 A）负责解码视频，另一个“工人”（线程 B）负责解码音频，还有一个“工人”（线程 C）负责显示字幕。它们共享电影播放器的内存空间和 CPU 时间，共同完成电影播放这个任务。如果解码视频的线程卡住了，整个电影可能就会卡住。

**总结**：进程是资源分配的基本单位，线程是 CPU 调度的基本单位。一个进程可以包含多个线程，但一个线程只能属于一个进程。

:::

::: details 进程之间的通信方式有哪些？

进程就像不同的工厂，它们各自独立。但有时候，不同的工厂之间需要互相协作，交换信息，比如工厂 A 生产了半成品，需要交给工厂 B 继续加工。那么，它们之间怎么“打电话”或者“寄快递”呢？

这些“打电话”或“寄快递”的方式就是进程间通信（IPC）。

1. **管道（Pipes）：**
    - **理解**：就像一根水管，数据只能单向流动（或双向但需要两根管子），而且通常只能在有亲缘关系（比如父子进程）的工厂之间使用。
    - **应用**：Linux 命令行里经常用 `|`（管道符），比如 `ls -l | grep .txt`，就是把 `ls -l` 的输出作为 `grep` 的输入。
2. **消息队列（Message Queues）：**
    - **理解**：就像一个“留言板”或“邮局”，工厂们可以把消息写下来投递进去，其他工厂可以去读取。消息是有序的，而且可以按类型分类。
    - **应用**：比如一个日志收集进程把日志信息放到队列，另一个日志分析进程去队列里取。
3. **共享内存（Shared Memory）：**
    - **理解**：就像划出一块“公共仓库”，所有工厂都可以直接读写这个仓库里的东西。这是最快的方式，因为它省去了数据的复制过程。
    - **应用**：数据库服务器和客户端之间可能用共享内存来快速交换数据。
    - **注意**：因为大家都能读写，所以需要额外的机制（比如“交通信号灯”——信号量）来避免同时修改导致数据混乱。
4. **信号量（Semaphores）：**
    - **理解**：就像一个“交通信号灯”或“计数器”，本身不传输数据，而是用来控制多个工厂对共享资源的访问。比如，只有绿灯亮了（信号量允许），工厂才能进入“公共仓库”取货。
    - **应用**：常和共享内存一起使用，避免数据竞争。
5. **信号（Signals）：**
    - **理解**：就像一个“紧急通知”或“中断”，用于通知某个工厂发生了特定事件。比如，工厂着火了（收到终止信号），就得赶紧停工。
    - **应用**：`Ctrl+C` 终止程序就是发送一个信号。
6. **套接字（Sockets）：**
    - **理解**：就像“电话”，可以进行本地通信，也可以跨电脑（网络）通信。是最灵活、应用最广的方式。
    - **应用**：浏览器访问网站（HTTP 协议），聊天软件通信等，都是基于套接字。

**总结**：选哪种方式取决于需求：速度要求高用共享内存，需要远程通信用套接字，简单通知用信号，有序通信用消息队列等。

:::

::: details 进程的调度算法你知道吗？

你的电脑 CPU 就像一个“总经理”，而每个进程（工厂）都是一个“项目”。总经理手里有很多项目（进程）等着处理，但他只有一个大脑，不能同时做所有事。那么，他得有个“排班表”或者“工作优先级”来决定先处理哪个项目，后处理哪个，以及每个项目处理多久。这个“排班表”和“优先级”的规则，就是进程调度算法。

调度算法的目标通常是：

- **公平**：尽量让每个进程都有机会执行。
- **效率**：CPU 尽量不空闲。
- **响应快**：用户操作能很快得到反馈。
- **吞吐量高**：单位时间内完成更多任务。

常见的调度算法有：

1. **先来先服务（FCFS - First-Come, First-Served）：**
    - **理解**：最简单粗暴，谁先提交项目，就先处理谁的。
    - **缺点**：如果一个项目耗时特别长，后面的项目就得一直等着，效率低下。就像银行排队，前面有个办大业务的，后面排队的人都得傻等。
2. **短作业优先（SJF - Shortest Job First）：**
    - **理解**：哪个项目看起来最短，就先处理哪个。
    - **优点**：整体效率高，平均等待时间最短。
    - **缺点**：很难提前准确知道一个项目到底有多短，而且长作业可能一直得不到执行（“饥饿”）。
3. **优先级调度（Priority Scheduling）：**
    - **理解**：每个项目都有一个重要程度（优先级），总经理优先处理重要性高的。
    - **缺点**：低优先级的项目可能永远得不到执行（“饥饿”），除非有“老化机制”：随着等待时间的增加，优先级逐渐提高。
4. **时间片轮转（Round Robin - RR）：**
    - **理解**：给每个项目分配一个很短的“时间片”（比如 10 毫秒），时间到了就暂停这个项目，去处理下一个项目，轮流着来。
    - **优点**：公平，响应快，适合分时系统（多个用户共享电脑）。
    - **应用**：现代操作系统中最常用的算法之一。
5. **多级反馈队列（Multilevel Feedback Queue）：**
    - **理解**：这是一个更复杂的“组合拳”。它设置多个队列，每个队列有不同的优先级和时间片。新来的项目放在最高优先级队列，如果一个项目用完时间片还没完成，就把它降级到下一个较低优先级队列。如果项目长时间没执行，又可以提升其优先级（“老化”）。
    - **优点**：综合了以上算法的优点，既能保证响应速度，又能兼顾长短作业和优先级。
    - **应用**：绝大多数现代操作系统（如 Windows、Linux）的调度器都基于这种思想。

**总结**：调度算法就像 CPU 这个“总经理”在管理他手头一大堆任务的策略。没有哪个算法是万能的，现代操作系统通常会结合多种算法，形成一套复杂的调度策略，以应对不同类型的任务和系统需求。

:::
