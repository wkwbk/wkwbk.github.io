# 设计模式面试题

::: details 单例模式有哪几种实现？如何保证线程安全？

想象一下，你家里只有一间茅厕（厕所），每次只能一个人进去用。当有人想用的时候，就得去排队，或者看看里面有没有人。用完了，门开着，下一个人才能进去。

单例模式就是这个意思：**保证一个类在整个程序运行过程中，只有一个实例（对象）存在，而且提供一个公共的、方便的方法让大家都能访问到这个唯一的实例。**

为啥要这样？比如，你家就一个管家，所有需要他做的事情都找他。或者说，程序里有一个配置中心，所有地方都得从这同一个地方读取配置。

**有哪几种实现？**

1. **饿汉式（Eager Initialization）：**
    - **比喻**：就像你还没饿，但妈已经把饭做好了放在桌上。等你一说“饿了”，饭马上就能吃。
    - **怎么实现**：在类加载的时候，就直接把唯一的实例创建好。
    - **代码大概长这样：**

      ```java
      public class Singleton {
          private static Singleton instance = new Singleton(); // 类加载时就创建了

          private Singleton() {} // 构造器私有，外面不能随便 new

          public static Singleton getInstance() { // 提供一个公共方法获取实例
              return instance;
          }
      }
      ```

    - **优点**：简单粗暴，线程安全（因为类加载时就创建了，后面不会再有并发问题）。
    - **缺点**：可能会提前创建实例，如果这个实例很占资源，但又一直没用到，就有点浪费。

2. **懒汉式（Lazy Initialization）：**
    - **比喻**：你说“饿了”，妈才开始给你做饭。如果一直没说饿，饭就一直不烧。
    - **怎么实现**：第一次需要用到这个实例的时候，才去创建它。
    - **代码大概长这样（初始版本，有线程安全问题）：**

      ```java
      public class Singleton {
          private static Singleton instance; // 默认是 null

          private Singleton() {}

          public static Singleton getInstance() {
              if (instance == null) { // 第一次用才创建
                  instance = new Singleton();
              }
              return instance;
          }
      }
      ```

    - **优点**：真正需要的时候才创建，节省资源。
    - **缺点**：**有线程安全问题！**（看下面怎么解决）

3. **双重检查锁定（Double-Checked Locking - DCL）：**
    - **比喻**：你说“饿了”，妈先看冰箱有没有菜。没菜才去买菜做饭，而且为了避免你和弟弟同时说饿都跑去买菜，她会锁上门（同步），一个人去买。买完菜回来，再看看冰箱里是不是已经有菜了（双重检查），确认没有重复买。
    - **怎么实现**：在懒汉式的基础上，加锁来保证线程安全，并且进行两次 `null` 检查，提高性能。
    - **代码大概长这样：**

      ```java
      public class Singleton {
          private volatile static Singleton instance; // 注意这里的 volatile 关键字

          private Singleton() {}

          public static Singleton getInstance() {
              if (instance == null) { // 第一次检查，如果已经创建了，就直接返回，避免进入同步块
                  synchronized (Singleton.class) { // 进入同步块，保证同一时间只有一个线程执行
                      if (instance == null) { // 第二次检查，防止多个线程同时通过第一次检查，导致重复创建
                          instance = new Singleton();
                      }
                  }
              }
              return instance;
          }
      }
      ```

    - **优点**：既实现了懒加载，又保证了线程安全，而且性能较好（大部分时间不会进入同步块）。
    - **缺点**：实现相对复杂一点点，`volatile` 关键字很重要，不加可能会有问题（指令重排）。

4. **静态内部类（Static Inner Class）：**
    - **比喻**：妈把饭店的菜单放在一个小抽屉里，只有你真正想点菜的时候，才去打开抽屉，拿出菜单。这个小抽屉（静态内部类）只有在第一次被打开（使用）时，里面的菜（单例实例）才会被“准备好”。
    - **怎么实现**：利用了类加载机制。静态内部类只有在被首次使用时才会被加载，它的静态成员（单例实例）也会随之被初始化。
    - **代码大概长这样：**

      ```java
      public class Singleton {
          private Singleton() {}

          // 静态内部类，只有在第一次调用 getInstance() 时才会被加载
          private static class SingletonHolder {
              private static final Singleton INSTANCE = new Singleton();
          }

          public static Singleton getInstance() {
              return SingletonHolder.INSTANCE;
          }
      }
      ```

    - **优点**：完美结合了懒加载和线程安全，代码也比较简洁，是推荐的实现方式之一。

5. **枚举（Enum）：**
    - **比喻**：枚举天生就是独一无二的，就像你家的门牌号，只有一个，而且是系统自动保证的。
    - **怎么实现**：直接定义一个枚举类型，里面就一个枚举值。
    - **代码大概长这样：**

      ```java
      public enum Singleton {
          INSTANCE; // 唯一的实例

          public void doSomething() {
              // 做一些事情
          }
      }
      // 使用：Singleton.INSTANCE.doSomething();
      ```

    - **优点**：最简洁、最推荐的方式！不仅线程安全，还能有效防止反射攻击和序列化问题，简直是“万能解药”。

**如何保证线程安全？**

1. **饿汉式**：简单粗暴，因为实例在类加载时就已经创建，JVM 会保证这个过程的线程安全。
2. **懒汉式（非线程安全）**：存在问题，多个线程可能同时判断 `instance == null` 为真，导致创建多个实例。
3. **懒汉式（加同步锁）**：在 `getInstance()` 方法上加 `synchronized` 关键字，但性能较差，因为每次调用都会加锁。
4. **双重检查锁定（DCL）**：`synchronized` 块只在第一次创建实例时才有效，大部分时间不加锁，配合 `volatile` 关键字防止指令重排，兼顾性能和安全。
5. **静态内部类**：利用 JVM 类加载机制的线程安全性。一个类在首次加载时只会执行一次初始化，这个过程是线程安全的。
6. **枚举**：JVM 从语言层面就保证了枚举实例的唯一性，天生线程安全，且能避免反射和序列化问题。

:::

::: details 什么是策略模式？一般用在什么场景？

想象一下，你要去上班，可以坐地铁、骑共享单车、打的，或者走路。每种方式都代表一种“策略”，它们都能把你送到公司，但具体怎么实现（坐地铁怎么买票，骑车怎么扫码）是不同的。你可以根据当天的天气、时间、心情来选择用哪种方式。

策略模式就是这个意思：**定义一系列的算法（策略），将每一个算法封装起来，并使它们可以相互替换。客户端（你）可以根据需要选择不同的策略，而不需要改变使用策略的代码。**

它解决的问题是：当一个操作有多种实现方式，并且这些方式在运行时需要灵活切换时。

**一般用在哪些场景？**

1. **支付方式选择：**
    - 比如电商网站，用户可以选择支付宝支付、微信支付、银联支付、银行卡支付等。每种支付方式就是一种策略。
    - 代码里会有一个“支付上下文”，你告诉它用支付宝，它就知道怎么调用支付宝接口；告诉它用微信，它就知道怎么调用微信接口。

2. **不同排序算法：**
    - 比如对一堆数据进行排序，你可以选择冒泡排序、快速排序、插入排序等等。每种排序算法就是一种策略。
    - 你可以写一个排序工具类，传入不同的“排序策略”，它就能用不同的方法给你排序。

3. **促销活动计算：**
    - 比如购物满减、打折、买一送一、积分抵扣等，每种促销规则都是一种策略。
    - 结算时，根据用户符合的条件，选择对应的策略来计算最终价格。

4. **文件导出/导入格式：**
    - 导出数据可以选择导出为 CSV、Excel、PDF 等格式，每种格式对应一种导出策略。
    - 导入数据可以选择从不同格式的文件导入，每种格式对应一种导入策略。

5. **不同税率计算：**
    - 针对不同地区或不同商品类型，税率计算方式不同，每种计算方式是一种策略。

**核心思想**：把“变”的部分（具体的算法实现）封装起来，把“不变”的部分（调用算法的接口）固定下来。这样，当你需要增加新的算法时，只需要增加一个新的策略类，而不需要修改原有的代码。这符合“开闭原则”（对扩展开放，对修改关闭）。

**示例代码：**

我们以“计算器操作”为例，实现加法、减法、乘法等不同的计算策略。

1. 策略接口（Strategy Interface）

    定义一个公共的接口，所有的具体策略都必须实现这个接口。

    ```java
    // Step 1: 定义策略接口
    public interface OperationStrategy {
        int doOperation(int num1, int num2);
    }
    ```

2. 具体策略类（Concrete Strategy Classes）

    实现策略接口，提供具体的算法或行为。

    ```java
    // Step 2: 实现具体的策略类 - 加法
    public class AddOperation implements OperationStrategy {
        @Override
        public int doOperation(int num1, int num2) {
            return num1 + num2;
        }
    }

    // Step 2: 实现具体的策略类 - 减法
    public class SubtractOperation implements OperationStrategy {
        @Override
        public int doOperation(int num1, int num2) {
            return num1 - num2;
        }
    }

    // Step 2: 实现具体的策略类 - 乘法
    public class MultiplyOperation implements OperationStrategy {
        @Override
        public int doOperation(int num1, int num2) {
            return num1 * num2;
        }
    }
    ```

3. 上下文类（Context Class）

    持有策略接口的引用，客户端通过上下文类来使用具体的策略。

    ```java
    // Step 3: 创建上下文类
    public class CalculatorContext {
        private OperationStrategy strategy;

        public CalculatorContext(OperationStrategy strategy) {
            this.strategy = strategy;
        }

        public int executeOperation(int num1, int num2) {
            return strategy.doOperation(num1, num2);
        }

        // 也可以提供一个方法来动态改变策略
        public void setStrategy(OperationStrategy strategy) {
            this.strategy = strategy;
        }
    }
    ```

4. 客户端（Client）

    使用上下文类和具体的策略来执行操作。

    ```java
    // Step 4: 客户端代码
    public class StrategyPatternDemo {
        public static void main(String[] args) {
            // 使用加法策略
            CalculatorContext context = new CalculatorContext(new AddOperation());
            System.out.println("10 + 5 = " + context.executeOperation(10, 5)); // 输出：10 + 5 = 15

            // 切换到减法策略
            context.setStrategy(new SubtractOperation()); // 或者直接 new CalculatorContext(new SubtractOperation())
            System.out.println("10 - 5 = " + context.executeOperation(10, 5)); // 输出：10 - 5 = 5

            // 切换到乘法策略
            context.setStrategy(new MultiplyOperation());
            System.out.println("10 * 5 = " + context.executeOperation(10, 5)); // 输出：10 * 5 = 50

            // 也可以直接创建新的上下文
            CalculatorContext multiplyContext = new CalculatorContext(new MultiplyOperation());
            System.out.println("20 * 3 = " + multiplyContext.executeOperation(20, 3)); // 输出：20 * 3 = 60
        }
    }
    ```

**代码解释：**

- `OperationStrategy` 是策略接口，定义了所有计算操作的共同行为。
- `AddOperation`、`SubtractOperation`、`MultiplyOperation` 是具体策略，分别实现了加、减、乘的具体算法。
- `CalculatorContext` 是上下文类，它持有一个 `OperationStrategy` 对象的引用。客户端通过 `CalculatorContext` 来执行操作，而不需要知道具体的策略类是哪个，实现了策略与客户端的解耦。
- 客户端可以根据需要，传入不同的策略对象给 `CalculatorContext`，从而在运行时改变其行为。

:::

::: details 什么是模板方法模式？一般用在什么场景？

想象一下，你有一张做菜的通用食谱。比如“做一道家常菜”：

1. 准备食材
2. 切菜
3. 下锅炒
4. 调味出锅

这个流程是固定的，但具体到“准备什么食材”、“怎么切”、“炒什么菜”、“放什么调料”，每个人家可以有不同的做法。比如，做番茄炒蛋，准备番茄鸡蛋；做青椒肉丝，准备青椒肉。

模板方法模式就是这个意思：**在一个抽象类中定义一个操作中的算法骨架（模板），而将一些步骤延迟到子类中去实现。这使得子类可以在不改变算法结构的情况下，重新定义该算法的某些特定步骤。**

它解决的问题是：当多个类有共同的算法骨架，但其中某些步骤的实现方式不同时。

**一般用在哪些场景？**

1. **通用算法框架：**
    - 比如一个框架，定义了数据处理的通用流程：`读取数据 -> 预处理 -> 核心业务逻辑 -> 保存结果`。
    - “读取数据”和“保存结果”可能是固定的（比如都从数据库读写），但“预处理”和“核心业务逻辑”可以由不同的子类来实现（比如一个子类做数据清洗，另一个做数据加密；一个子类是报表生成，另一个是数据分析）。

2. **报表生成：**
    - 生成报表通常有固定步骤：`连接数据库 -> 查询数据 -> 格式化数据 -> 输出报表`。
    - 但不同的报表（比如销售报表、财务报表）在“查询数据”和“格式化数据”上会有差异，这些差异的部分就可以由子类去实现。

3. **算法骨架，具体实现交给子类：**
    - 比如一个游戏，定义了“玩游戏”的通用步骤：`开始游戏 -> 进行中 -> 结束游戏`。
    - 但“进行中”的具体玩法（比如玩象棋、玩扑克）可以由不同的子类来实现。

4. **Web 开发中的请求处理：**
    - 比如一个 Spring MVC 控制器，它的请求处理流程可以看作是模板方法：`接收请求 -> 参数绑定 -> 业务逻辑处理 -> 视图渲染`。
    - 其中“业务逻辑处理”就是留给开发者实现的“具体步骤”。

5. **构建工具的编译/打包流程：**
    - 比如 Maven 或 Gradle，它们定义了构建项目的标准生命周期（`validate -> compile -> test -> package -> install -> deploy`）。
    - 这些阶段是固定的，但每个阶段的具体执行（比如用什么编译器编译、如何打包）可以有不同的插件（子类）来实现。

**核心思想**：封装“不变”的部分（算法骨架），把“可变”的部分（特定步骤的实现）留给子类。这样，当你需要改变某个步骤的实现时，只需要修改或创建新的子类，而不需要动到算法的整体结构。这也符合“开闭原则”。

**示例代码：**

我们以“构建房子”为例，房子建造有固定的步骤，但不同类型的房子（木屋、砖房）在某些步骤的实现上有所不同。

1. 抽象模板类（Abstract Template Class）

    定义算法的骨架（模板方法），并声明一些抽象方法，供子类实现。也可以包含一些具体方法和钩子方法。

    ```java
    // Step 1: 定义抽象模板类
    public abstract class HouseBuilder {

        // 模板方法：定义了建造房子的通用算法骨架
        public final void buildHouse() { // 使用 final 关键字防止子类修改模板方法的执行顺序
            layFoundation();      // 步骤 1: 打地基 (具体方法)
            buildWalls();         // 步骤 2: 建造墙壁 (抽象方法，子类实现)
            buildRoof();          // 步骤 3: 建造屋顶 (抽象方法，子类实现)
            decorateHouse();      // 步骤 4: 装修房子 (钩子方法，子类可选实现)
            System.out.println("房子建造完成！");
            System.out.println("--------------------");
        }

        // 具体方法：所有房子都一样，无需子类修改
        private void layFoundation() {
            System.out.println("打地基：挖掘地基，浇筑混凝土。");
        }

        // 抽象方法：留给子类实现，不同类型的房子墙壁建造方式不同
        protected abstract void buildWalls();

        // 抽象方法：留给子类实现，不同类型的房子屋顶建造方式不同
        protected abstract void buildRoof();

        // 钩子方法：子类可以选择是否实现（重写），提供默认的空实现或通用实现
        // 比如：不是所有房子都需要装修，或者默认是简单装修
        protected void decorateHouse() {
            System.out.println("装修房子：进行基础装修。");
        }
    }
    ```

2. 具体模板实现类（Concrete Template Classes）

    实现抽象类中定义的抽象方法，完成算法的具体步骤。

    ```java
    // Step 2: 实现具体的模板子类 - 木屋
    public class WoodenHouseBuilder extends HouseBuilder {
        @Override
        protected void buildWalls() {
            System.out.println("建造墙壁：使用木头和木板搭建墙壁。");
        }

        @Override
        protected void buildRoof() {
            System.out.println("建造屋顶：铺设木质瓦片屋顶。");
        }

        // 可以选择性地重写钩子方法，进行特定的装修
        @Override
        protected void decorateHouse() {
            System.out.println("装修房子：进行木质风格的内外装修。");
        }
    }

    // Step 2: 实现具体的模板子类 - 砖房
    public class BrickHouseBuilder extends HouseBuilder {
        @Override
        protected void buildWalls() {
            System.out.println("建造墙壁：使用砖块和水泥砌墙。");
        }

        @Override
        protected void buildRoof() {
            System.out.println("建造屋顶：铺设陶瓷瓦片屋顶。");
        }

        // 这个砖房就不重写 decorateHouse，使用父类的默认装修方法
    }
    ```

3. 客户端（Client）

    使用具体模板实现类来执行模板方法。

    ```java
    // Step 3: 客户端代码
    public class TemplateMethodPatternDemo {
        public static void main(String[] args) {
            System.out.println("--- 建造木屋 ---");
            HouseBuilder woodenHouse = new WoodenHouseBuilder();
            woodenHouse.buildHouse(); // 调用模板方法

            System.out.println("\n--- 建造砖房 ---");
            HouseBuilder brickHouse = new BrickHouseBuilder();
            brickHouse.buildHouse(); // 调用模板方法
        }
    }
    ```

**代码解释：**

- `HouseBuilder` 是抽象模板类，它定义了 `buildHouse()` 这个模板方法。这个方法包含了建造房子的固定步骤顺序。
- `layFoundation()` 是一个具体方法，所有房子打地基的方式都一样，所以在父类中直接实现。
- `buildWalls()` 和 `buildRoof()` 是抽象方法，它们的具体实现留给子类 `WoodenHouseBuilder` 和 `BrickHouseBuilder` 去完成。
- `decorateHouse()` 是一个钩子方法。它在父类中有一个默认的（可能是空的或通用的）实现，子类可以选择性地重写它来添加自己的特定行为。
- `buildHouse()` 方法被声明为 `final`，这是为了防止子类修改算法的骨架，保证了算法的稳定性和一致性。
- 客户端通过创建具体子类的实例，然后调用它们的模板方法 `buildHouse()` 来启动整个建造流程。

:::
