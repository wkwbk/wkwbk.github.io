# Java 面试题

::: details 接口和抽象类有什么区别？

在 Java 中，接口和抽象类都是实现抽象的机制，但它们在设计动机、功能和使用方式上存在显著差异。

**设计动机和理念：**

1. **接口的设计是自顶向下的：**
    - **理念**：我们首先从高层次考虑“**某种行为规范**”或“**契约**”。我们预先知道或约定某一组行为（即“能力”），然后基于这些行为来定义接口。任何需要具备这些行为的类，就去实现对应的接口。
    - **思考过程**：“我需要一个能跑（`Runnable`）的对象”、“我需要一个能比较（`Comparable`）的对象”、“我需要一个能连接数据库（`Connection`）的对象”。我们先定义这个“能做什么”的规范，再去考虑“谁来实现”以及“怎么实现”。
    - **目的**：主要用于定义**行为契约**，实现**多态**，解决**多重继承**问题，强调**能力**。

2. **抽象类的设计是自底向上的：**
    - **理念**：我们通常是先写了许多具体的类，在这些类的开发过程中，我们发现它们之间存在**共同的属性和行为**，有很多代码是可以复用的。为了消除代码冗余、提高代码复用性并提供一个统一的父类模板，我们将这些公共的逻辑和成员抽象封装到一个抽象类中。
    - **思考过程**：“我有很多形状类（`Circle`, `Rectangle`, `Triangle`），它们都有计算面积的方法，也有共同的颜色属性。我可以把这些共同的东西抽象成一个 `AbstractShape` 类。”
    - **目的**：主要用于提供一个**通用实现模板**，共享代码，实现**部分功能**，并强制子类完成未实现的抽象部分，强调**父子关系**。在实际项目开发中，很多时候抽象类是重构的产物。

**总结自顶向下与自底向上：**

- **自顶向下**：先约定接口（规范），再由不同的类去实现它。关注点在“能做什么”。
- **自底向上**：先有一些具体的类，发现共性后，将共性抽象成一个父类（抽象类）。关注点在“是什么”和“共同之处”。

**其他主要区别：**

除了设计理念上的差异，还有以下几个关键的技术区别：

1. **方法实现：**
    - **接口：**
      - 在 Java 8 之前，接口中的方法默认是 `public abstract`，不允许有方法实现。
      - 从 Java 8 开始，接口可以包含 `default` 方法（有默认实现）和 `static` 方法（静态实现）。
      - Java 9 以后还允许 `private` 方法和 `private static` 方法。
    - **抽象类**：
      - 抽象类可以包含 `abstract` 方法（没有实现，必须由子类实现）和具体方法（有实现，子类可以直接继承或覆盖）。
      - 允许子类继承并重用抽象类中的方法实现。

2. **构造函数和成员变量：**
    - **接口：**
      - 接口**不能**包含构造函数。
      - 接口中的成员变量默认是 `public static final`，即常量。
    - **抽象类：**
      - 抽象类**可以**包含构造函数。虽然抽象类不能直接实例化，但它的构造函数会在子类实例化时被调用，用于初始化抽象类中定义的成员变量。
      - 成员变量可以有不同的访问修饰符（如 `private`, `protected`, `public`），并且可以不是常量。

3. **多重继承：**
    - **接口**：一个类可以**实现多个接口**。这是 Java 实现多重行为（多重实现）的关键机制，因为 Java 不支持类的多重继承。
    - **抽象类**：一个类**只能继承一个抽象类**（遵循 Java 的单继承原则）。

**总结对比表：**

| 特性           | 接口 (Interface)                                      | 抽象类 (Abstract Class)                                     |
| :------------- | :---------------------------------------------------- | :---------------------------------------------------------- |
| **设计理念**   | **自顶向下**：先定义行为规范/契约                     | **自底向上**：先有具体类，再抽取共性作为模板                |
| **定义关键字** | `interface`                                           | `abstract class`                                            |
| **方法实现**   | Java 8 前无实现；Java 8+ 可有 `default`/`static` 方法 | 可有抽象方法 (无实现) 和具体方法 (有实现)                   |
| **构造器**     | **不能**有                                            | **可以**有                                                  |
| **成员变量**   | 默认 `public static final` (常量)                     | 可有各种修饰符 (`private`, `protected`, `public`)，可变变量 |
| **多重继承**   | 一个类可**实现多个**接口                              | 一个类**只能继承一个**抽象类                                |
| **强调**       | 行为、能力、契约、多态                                | 模板、父子关系、代码复用                                    |
| **实例化**     | 不能直接实例化                                        | 不能直接实例化 (但有构造器供子类调用)                       |

:::

::: details JDK 动态代理和 CGLIB 动态代理有什么区别？

- **JDK 动态代理：**
  - **实现方式**：基于 Java 的反射机制，在运行时为接口生成代理类。
  - **要求**：目标对象必须实现一个或多个接口。代理类会实现这些相同的接口。
  - **优点**：Java 原生支持，无需引入第三方库。
  - **缺点**：只能代理接口，无法代理没有实现接口的普通类或最终类（final class）。
- **CGLIB 动态代理：**
  - **实现方式**：基于 ASM 字节码生成库，在运行时动态生成目标类的子类。
  - **要求**：目标对象不能是 final 类或 final 方法（因为无法被继承和覆盖）。
  - **优点**：可以代理没有实现接口的普通类，以及最终类中非 final 方法。
  - **缺点**：需要引入第三方库（CGLIB 或 Spring AOP 内部集成的 ASM）。对于 final 类和 final 方法无能为力。

**总结**：JDK 代理是面向接口的代理，CGLIB 代理是面向类的代理（通过继承）。

:::

::: details 你使用过 Java 的反射机制吗？如何应用反射？

反射机制允许程序在运行时检查或修改类的结构、方法和属性，而无需在编译时就知道这些信息。

**具体应用举例：**

1. **框架开发**：Spring 通过反射创建 Bean 实例，并调用其 setter 方法注入依赖。
2. **动态代理**：JDK 动态代理就是基于反射实现。
3. **单元测试框架**：JUnit 等框架通过反射来查找和执行测试方法。
4. **序列化和反序列化**：JSON 库（如 Gson、Jackson）通过反射来将 Java 对象转换为 JSON 字符串，或将 JSON 字符串解析为 Java 对象。
5. **插件化开发**：允许程序动态加载并执行外部定义的类。
6. **配置文件解析**：读取配置文件后，通过反射来调用相应的方法或设置属性。

**如何应用反射：**

要应用反射，通常涉及以下核心 API：

- **获取 Class 对象**：`Class.forName("com.example.MyClass")` 或 `myObject.getClass()` 或 `MyClass.class`。
- **获取构造器并创建实例**：`Class.getConstructor()` / `getConstructors()`，然后 `Constructor.newInstance()`。
- **获取方法并调用**：`Class.getMethod("methodName", paramTypes...)` / `getMethods()`，然后 `Method.invoke(object, args...)`。
- **获取字段并操作**：`Class.getField("fieldName")` / `getFields()`，然后 `Field.get(object)` / `Field.set(object, value)`。

:::
