# Java 面试题

::: details 接口和抽象类有什么区别？

在 Java 中，接口和抽象类都是实现抽象的机制，但它们在设计动机、功能和使用方式上存在显著差异。

**设计动机和理念：**

1. **接口的设计是自顶向下的：**
    - **理念**：我们首先从高层次考虑“**某种行为规范**”或“**契约**”。我们预先知道或约定某一组行为（即“能力”），然后基于这些行为来定义接口。任何需要具备这些行为的类，就去实现对应的接口。
    - **思考过程**：“我需要一个能跑（`Runnable`）的对象”、“我需要一个能比较（`Comparable`）的对象”、“我需要一个能连接数据库（`Connection`）的对象”。我们先定义这个“能做什么”的规范，再去考虑“谁来实现”以及“怎么实现”。
    - **目的**：主要用于定义**行为契约**，实现**多态**，解决**多重继承**问题，强调**能力**。

2. **抽象类的设计是自底向上的：**
    - **理念**：我们通常是先写了许多具体的类，在这些类的开发过程中，我们发现它们之间存在**共同的属性和行为**，有很多代码是可以复用的。为了消除代码冗余、提高代码复用性并提供一个统一的父类模板，我们将这些公共的逻辑和成员抽象封装到一个抽象类中。
    - **思考过程**：“我有很多形状类（`Circle`, `Rectangle`, `Triangle`），它们都有计算面积的方法，也有共同的颜色属性。我可以把这些共同的东西抽象成一个 `AbstractShape` 类。”
    - **目的**：主要用于提供一个**通用实现模板**，共享代码，实现**部分功能**，并强制子类完成未实现的抽象部分，强调**父子关系**。在实际项目开发中，很多时候抽象类是重构的产物。

**总结自顶向下与自底向上：**

- **自顶向下**：先约定接口（规范），再由不同的类去实现它。关注点在“能做什么”。
- **自底向上**：先有一些具体的类，发现共性后，将共性抽象成一个父类（抽象类）。关注点在“是什么”和“共同之处”。

**其他主要区别：**

除了设计理念上的差异，还有以下几个关键的技术区别：

1. **方法实现：**
    - **接口：**
      - 在 Java 8 之前，接口中的方法默认是 `public abstract`，不允许有方法实现。
      - 从 Java 8 开始，接口可以包含 `default` 方法（有默认实现）和 `static` 方法（静态实现）。
      - Java 9 以后还允许 `private` 方法和 `private static` 方法。
    - **抽象类**：
      - 抽象类可以包含 `abstract` 方法（没有实现，必须由子类实现）和具体方法（有实现，子类可以直接继承或覆盖）。
      - 允许子类继承并重用抽象类中的方法实现。

2. **构造函数和成员变量：**
    - **接口：**
      - 接口**不能**包含构造函数。
      - 接口中的成员变量默认是 `public static final`，即常量。
    - **抽象类：**
      - 抽象类**可以**包含构造函数。虽然抽象类不能直接实例化，但它的构造函数会在子类实例化时被调用，用于初始化抽象类中定义的成员变量。
      - 成员变量可以有不同的访问修饰符（如 `private`, `protected`, `public`），并且可以不是常量。

3. **多重继承：**
    - **接口**：一个类可以**实现多个接口**。这是 Java 实现多重行为（多重实现）的关键机制，因为 Java 不支持类的多重继承。
    - **抽象类**：一个类**只能继承一个抽象类**（遵循 Java 的单继承原则）。

**总结对比表：**

| 特性           | 接口 (Interface)                                      | 抽象类 (Abstract Class)                                     |
| :------------- | :---------------------------------------------------- | :---------------------------------------------------------- |
| **设计理念**   | **自顶向下**：先定义行为规范/契约                     | **自底向上**：先有具体类，再抽取共性作为模板                |
| **定义关键字** | `interface`                                           | `abstract class`                                            |
| **方法实现**   | Java 8 前无实现；Java 8+ 可有 `default`/`static` 方法 | 可有抽象方法 (无实现) 和具体方法 (有实现)                   |
| **构造器**     | **不能**有                                            | **可以**有                                                  |
| **成员变量**   | 默认 `public static final` (常量)                     | 可有各种修饰符 (`private`, `protected`, `public`)，可变变量 |
| **多重继承**   | 一个类可**实现多个**接口                              | 一个类**只能继承一个**抽象类                                |
| **强调**       | 行为、能力、契约、多态                                | 模板、父子关系、代码复用                                    |
| **实例化**     | 不能直接实例化                                        | 不能直接实例化 (但有构造器供子类调用)                       |

:::

::: details JDK 动态代理和 CGLIB 动态代理有什么区别？

- **JDK 动态代理：**
  - **实现方式**：基于 Java 的反射机制，在运行时为接口生成代理类。
  - **要求**：目标对象必须实现一个或多个接口。代理类会实现这些相同的接口。
  - **优点**：Java 原生支持，无需引入第三方库。
  - **缺点**：只能代理接口，无法代理没有实现接口的普通类或最终类（final class）。
- **CGLIB 动态代理：**
  - **实现方式**：基于 ASM 字节码生成库，在运行时动态生成目标类的子类。
  - **要求**：目标对象不能是 final 类或 final 方法（因为无法被继承和覆盖）。
  - **优点**：可以代理没有实现接口的普通类，以及最终类中非 final 方法。
  - **缺点**：需要引入第三方库（CGLIB 或 Spring AOP 内部集成的 ASM）。对于 final 类和 final 方法无能为力。

**总结**：JDK 代理是面向接口的代理，CGLIB 代理是面向类的代理（通过继承）。

:::

::: details 你使用过 Java 的反射机制吗？如何应用反射？

反射机制允许程序在运行时检查或修改类的结构、方法和属性，而无需在编译时就知道这些信息。

**具体应用举例：**

1. **框架开发**：Spring 通过反射创建 Bean 实例，并调用其 setter 方法注入依赖。
2. **动态代理**：JDK 动态代理就是基于反射实现。
3. **单元测试框架**：JUnit 等框架通过反射来查找和执行测试方法。
4. **序列化和反序列化**：JSON 库（如 Gson、Jackson）通过反射来将 Java 对象转换为 JSON 字符串，或将 JSON 字符串解析为 Java 对象。
5. **插件化开发**：允许程序动态加载并执行外部定义的类。
6. **配置文件解析**：读取配置文件后，通过反射来调用相应的方法或设置属性。

**如何应用反射：**

要应用反射，通常涉及以下核心 API：

- **获取 Class 对象**：`Class.forName("com.example.MyClass")` 或 `myObject.getClass()` 或 `MyClass.class`。
- **获取构造器并创建实例**：`Class.getConstructor()` / `getConstructors()`，然后 `Constructor.newInstance()`。
- **获取方法并调用**：`Class.getMethod("methodName", paramTypes...)` / `getMethods()`，然后 `Method.invoke(object, args...)`。
- **获取字段并操作**：`Class.getField("fieldName")` / `getFields()`，然后 `Field.get(object)` / `Field.set(object, value)`。

:::

::: details 说说 Java 中 HashMap 的原理？

想象一下你有一个巨大的衣柜，里面有很多抽屉，每个抽屉上都贴着一个标签（这个标签就是**键**，Key），你把衣服（这个衣服就是**值**，Value）放进对应的抽屉里。

`HashMap` 的原理也差不多：

1. **标签变数字（哈希函数）**：当你给 `HashMap` 一个 `Key`（比如你要存一件红色的 T 恤，`Key` 就是“红色 T 恤”），它会先对这个 `Key` 进行一番计算，把这个 `Key` 变成一个数字（这个计算过程就叫做**哈希函数**，结果叫**哈希值**）。
    - **例子**：“红色 T 恤”计算后可能变成数字 `5`。

2. **找抽屉位置（索引）**：这个数字可能很大，但你的衣柜抽屉是有限的。所以 `HashMap` 会用这个数字再做一次运算（通常是取模运算），把它映射到衣柜里某个具体的抽屉位置上。
    - **例子**：数字 `5` 在你的 `HashMap` 里可能对应第 `5` 号抽屉。

3. **放衣服进去（存储）：**
    - **空抽屉**：如果这个抽屉是空的，那太好了，直接把你的衣服放进去（`Key-Value` 对）。
    - **已有衣服（碰撞）**：如果这个抽屉里已经有衣服了（比如“蓝色衬衫”也计算到了第 `5` 号抽屉，这就叫**哈希碰撞**），`HashMap` 不会直接覆盖掉。它会把新的衣服挂到这个抽屉里已经有的衣服的**后面**，形成一个链子。这个链子可以是**链表**（早期版本）或者**红黑树**（当链子太长时，为了提高查找效率，JDK8 及以后会转换）。
        - **例子**：第 `5` 号抽屉里本来有“蓝色衬衫”，现在“红色 T 恤”也来了，它们就会排队，比如“蓝色衬衫” → “红色 T 恤”。

4. **找衣服（查找）**：当你想要找“红色 T 恤”的时候，`HashMap` 也会对“红色 T 恤”这个 `Key` 进行同样的计算，得到同样的抽屉位置（第 `5` 号）。然后它会到第 `5` 号抽屉里，沿着链子一条一条地比对，直到找到“红色 T 恤”为止。

**核心思想就是：**

- **快速定位**：通过 `Key` 算出哈希值，再映射到数组索引，大大提高了查找效率，不用一个一个地遍历所有元素。
- **解决冲突**：用链表（或红黑树）来处理不同 `Key` 算出相同索引的情况。

:::

::: details Java 中有哪些集合类？请简单介绍

想象一下你有很多东西要管理，比如一堆照片、一份购物清单、一套学生花名册。Java 为了帮你管理这些东西，提供了各种“容器”，这些容器就是**集合类**。它们主要分成几大家族：

1. **List (列表) 家族：**
    - **特点**：有序（你放进去的顺序就是它存储的顺序），可重复（可以放两个一模一样的元素）。
    - **类比**：你的购物清单。买了重复的东西没关系，物品的顺序也很重要。
    - **常见成员：**
      - `ArrayList`：基于数组实现。**查改快，增删慢**（特别是中间位置）。就像一排整齐的格子，找东西方便，但中间加东西要挪动后面的所有格子。
      - `LinkedList`：基于链表实现。**增删快，查改慢**。就像一串手拉手的人，加个人很容易插队，但找人要一个一个问过去。

2. **Set (集合) 家族：**
    - **特点**：无序（你放进去的顺序不一定是你取出来的顺序），不可重复（只能放一个，重复的会被忽略）。
    - **类比**：你的收藏品清单。收藏品不会重复，你也不关心它们摆放的先后顺序。
    - **常见成员：**
      - `HashSet`：基于 `HashMap` 实现。**查找、添加、删除都很快**。它利用了哈希表的快速查找特性。
      - `LinkedHashSet`：继承 `HashSet`，内部用链表维护插入顺序。**既保证不重复，又能记住你添加的顺序**。
      - `TreeSet`：基于红黑树实现。**能自动排序**（自然顺序或自定义顺序）。

3. **Map (映射) 家族：**
    - **特点**：存储 **键值对 (Key-Value Pair)**。`Key` 唯一（就像抽屉标签不能重复），`Value` 可以重复。
    - **类比**：学校的花名册。每个学生学号（Key）唯一对应一个学生姓名（Value），通过学号快速找到学生，但不同的学号可能对应相同的姓名（重名）。
    - **常见成员：**
      - `HashMap`：基于哈希表实现。**查找、添加、删除都很快**（我们上面原理讲的就是它）。**无序**。
      - `LinkedHashMap`：继承 `HashMap`，内部用链表维护插入顺序。**既能快速查找，又能记住你添加的顺序**。
      - `TreeMap`：基于红黑树实现。**能自动按 `Key` 排序**。

**总结：**

- **List**：存一堆东西，讲究顺序，允许重复。
- **Set**：存一堆不重复的东西，不讲究顺序。
- **Map**：存一对一对的东西（Key-Value），Key 不能重复。

:::

::: details Java 中 HashMap 的扩容机制是怎样的？

想象你的衣柜一开始只有 `16` 个抽屉。你不断往里放衣服，直到抽屉越来越满，或者因为哈希碰撞导致链子越来越长，找衣服越来越慢。

`HashMap` 也一样，当它达到一定程度时，为了保持效率，它会进行**扩容**：

1. **触发条件：**
    - **装载因子（Load Factor）**：`HashMap` 有一个“装载因子”，默认是 `0.75`。意思是当抽屉里衣服的数量（也就是 `HashMap` 里的元素个数）达到抽屉总数的 `75%` 时，就触发扩容。
        - **例子**：如果有 `16` 个抽屉，当放了 `16 * 0.75 = 12` 件衣服时，就会开始考虑扩容。
    - **链表过长（JDK8+）**：在 JDK8 以后，如果某个抽屉里的链子长度超过一个阈值（默认是 `8`），并且总抽屉数量还不够大（默认是 `64`），也会触发扩容（或者将链表转为红黑树）。

2. **扩容操作：**
    - **翻倍**：`HashMap` 扩容时，通常会将抽屉的总数翻倍。
        - **例子**：从 `16` 个抽屉变成 `32` 个抽屉。
    - **重新分配**：这不是简单地把旧抽屉里的衣服搬到新衣柜里，而是需要**重新计算所有衣服的哈希值和它们在新衣柜里的抽屉位置**。因为抽屉总数变了，`Key` 映射到索引的计算方式（通常是取模）也会变。
        - **例子**：“红色 T 恤”原来在 `16` 个抽屉的衣柜里对应第 `5` 号抽屉，现在变成 `32` 个抽屉的衣柜，它可能就要去第 `21` 号抽屉了。所有的衣服都要重新计算一遍，搬到新位置。
    - **为什么是翻倍？** 主要是为了利用位运算（`&` 运算）来提高计算新索引的效率，因为 `HashMap` 的容量总是 `2` 的幂次方。

3. **优点和缺点：**
    - **优点**：保证了 `HashMap` 在元素增多的情况下依然能保持较高的查找效率。
    - **缺点**：扩容是一个**比较耗时**的操作，因为它需要重新计算所有元素的哈希值和索引，并重新放置。所以如果能预估 `HashMap` 的大小，最好在创建时就指定一个合适的初始容量，减少扩容次数。

**简单来说**：`HashMap` 会观察自己有多满。当它觉得太挤了，就会造一个更大的衣柜（通常是原来的两倍大），然后把所有衣服都拿出来，重新计算它们在新衣柜里的位置，再全部放进去。这样虽然麻烦一点，但确保了以后还能继续快速找衣服。

:::

::: details 你了解 Java 线程池的原理吗？

想象你是一个餐馆老板，生意很好，经常有客人来点餐。如果你每次有客人来都临时找一个厨师来做菜，做完就让他走，这样太麻烦了，而且招人、培训人都需要时间，效率很低。

**线程池**就相当于你的这个餐馆的“专属厨师团队”：

1. **开门营业（创建线程池）**：你一开始就雇佣了一定数量的厨师（**核心线程**）。即使没有客人，他们也会待命。
2. **客人点餐（提交任务）**：客人来了，点了一道菜（一个**任务**）。
    - **有空闲厨师**：如果有空闲的厨师，他们就立刻接单做菜。
    - **没有空闲厨师，但有等候区**：如果所有核心厨师都在忙，但餐馆里有等待区（**任务队列**），客人就在等待区排队，等着有厨师忙完。
    - **等候区也满了，需要临时加人**：如果等待区也满了，厨师团队会考虑临时再雇佣一些**临时厨师**（**非核心线程/最大线程数**）。
    - **人满为患（拒绝策略）**：如果临时厨师也雇满了，等待区也满了，餐馆实在忙不过来，就只能对新来的客人说“抱歉，我们现在无法接单”（**拒绝策略**）。
3. **厨师工作（执行任务）**：厨师们拿到任务后就开始处理，处理完一个任务后，他们不会立即走人，而是会回到“待命状态”，等待下一个任务。
4. **临时厨师下班（线程回收）**：如果临时厨师长时间没事做，餐馆就会让他们下班回家（**线程回收**），只留下核心厨师继续待命。

**线程池的优点：**

- **降低资源消耗**：避免了频繁创建和销毁线程的开销。
- **提高响应速度**：任务来了可以直接使用已有的线程，不用等待线程创建。
- **提高线程的可管理性**：可以统一管理、分配、监控和调整线程。
- **避免线程过多**：防止大量线程同时运行导致系统资源耗尽。

**核心组件：**

- **`ThreadPoolExecutor`**：Java 中实现线程池的类。
- **核心线程数 (`corePoolSize`)**：即使没有任务也会保留的最小线程数。
- **最大线程数 (`maximumPoolSize`)**：允许创建的最大线程数。
- **任务队列 (`BlockingQueue`)**：存放待执行任务的队列。
- **空闲线程存活时间 (`keepAliveTime`)**：当线程数大于核心线程数时，多余的空闲线程在终止前等待新任务的最长时间。
- **拒绝策略 (`RejectedExecutionHandler`)**：当线程池和任务队列都满时，如何处理新提交的任务。

:::

::: details 你使用过哪些 Java 并发工具类？

在多线程编程中，为了让多个线程和谐、高效地工作，Java 提供了很多“工具”，可以帮助我们管理和协调线程。我主要使用过以下这些：

1. **`ConcurrentHashMap` (并发哈希表)：**
    - **作用**：是一个**线程安全且高效的哈希表**，支持并发访问。解决了传统 `HashMap` 在多线程环境下不安全的问题，同时性能比 `Hashtable` 等加锁的 Map 更好。
    - **用法**：多个线程可以同时对它进行读写操作，而不会导致线程安全问题。
    - **类比**：就像一个有多个收银台的超市，不同收银员（线程）可以同时处理顾客（操作数据），互不干扰，大大提高了效率。

        ```java
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

        map.put("key1", 1); // 存入 key1-1
        System.out.println("存入 key1 -> " + map.get("key1")); // 读取 key1

        // 如果 key2 不存在，则存入 k -> 2 的结果 (即 2)
        map.computeIfAbsent("key2", k -> {
            System.out.println("'key2' 不存在，计算并存入 2");
            return 2;
        });
        System.out.println("第一次 computeIfAbsent 后 key2 的值：" + map.get("key2"));

        // 再次使用 computeIfAbsent。
        // 因为 key2 已经存在，k -> 3 的逻辑不会执行，map 中的值也不会改变
        map.computeIfAbsent("key2", k -> {
            System.out.println("'key2' 已经存在，k -> 3 的逻辑不会执行");
            return 3; // 此值不会被存入
        });
        System.out.println("第二次 computeIfAbsent 后 key2 的值：" + map.get("key2"));
        ```

2. **`AtomicInteger` (原子整数)：**

    - **作用**：提供一种**线程安全的方式对 `int` 类型进行原子操作**，如增减、比较并设置。避免了使用 `synchronized` 关键字带来的性能开销。
    - **用法**：适用于需要频繁对数值进行**无锁**操作的场景。
    - **类比**：就像一个显示实时人数的计数器，多个人同时点击“进入”或“离开”，计数器也能准确、安全地更新，不需要排队等待。

        ```java
        AtomicInteger atomicInt = new AtomicInteger(0);
        atomicInt.incrementAndGet(); // 线程安全地递增
        atomicInt.decrementAndGet(); // 线程安全地递减
        atomicInt.compareAndSet(1, 2); // 比较并设置 (CAS 操作)
        ```

3. **`Semaphore` (信号量)：**

    - **作用**：控制访问资源的线程数量，可以用来实现**限流或访问控制**。
    - **用法**：在资源有限的情况下，控制同时访问的线程数量。
    - **类比**：就像一个有固定车位的停车场。每次有车（线程）想进入，就得先拿一个停车许可。停车位满了，后面的车就得等着。

        ```java
        Semaphore semaphore = new Semaphore(3); // 最多允许 3 个线程同时访问
        try {
            semaphore.acquire(); // 获取许可，如果许可不够则阻塞
            // 执行任务（例如访问数据库连接、文件等有限资源）
        } finally {
            semaphore.release(); // 释放许可
        }
        ```

4. **`CyclicBarrier` (循环屏障)：**

    - **作用**：让一组线程到达一个共同的同步点，然后一起继续执行。常用于**分阶段任务执行**。
    - **用法**：适用于需要所有线程在某个点都完成再继续的场景。
    - **类比**：就像一次团队协作的闯关游戏。设定 3 人一组，只有当所有 3 名队员都到达当前关卡的集合点时，大家才能一起通过，进入下一关。

        ```java
        CyclicBarrier barrier = new CyclicBarrier(3, () -> {
            System.out.println("所有线程都到达了屏障点，开始下一阶段任务");
        });
        Runnable task = () -> {
            try {
                // 执行任务的第一阶段
                System.out.println(Thread.currentThread().getName() + "完成第一阶段任务");
                barrier.await(); // 等待其他线程到达屏障
                // 执行任务的第二阶段
                System.out.println(Thread.currentThread().getName() + "完成第二阶段任务");
            } catch (Exception e) {
                e.printStackTrace();
            }
        };
        new Thread(task, "线程 A").start();
        new Thread(task, "线程 B").start();
        new Thread(task, "线程 C").start();
        ```

5. **`CountDownLatch` (倒计时门闩)：**

    - **作用**：一个线程（或多个）等待其他线程完成操作。
    - **用法**：适用于主线程需要等待多个子线程完成任务的场景。
    - **类比**：就像一个项目的验收。项目经理（主线程）需要等待 3 个小组（子线程）各自完成他们的模块开发（`countDown()`），当所有模块都完成时，项目经理才能宣布项目完成（`await()`）。

        ```java
        CountDownLatch latch = new CountDownLatch(3); // 设置计数器为 3
        Runnable task = () -> {
            try {
                // 执行任务
                System.out.println(Thread.currentThread().getName() + "完成任务");
            } finally {
                latch.countDown(); // 任务完成，计数器减一
            }
        };
        new Thread(task, "子线程 1").start();
        new Thread(task, "子线程 2").start();
        new Thread(task, "子线程 3").start();

        latch.await(); // 主线程等待所有任务完成，计数器归零时才继续
        System.out.println("所有任务都完成了，主线程继续执行");
        ```

6. **`BlockingQueue` (阻塞队列)：**

    - **作用**：是一个**线程安全的队列**，支持阻塞操作。适用于**生产者 - 消费者模式**。
    - **用法**：生产者线程将元素放入队列，队列为满时生产者线程阻塞；消费者线程从队列中取出元素，队列为空时消费者线程阻塞。
    - **类比**：就像一个有限容量的生产线传送带。生产工人（生产者线程）往上传送产品，如果传送带满了，他就得等等；质检工人（消费者线程）从传送带上取产品，如果传送带空了，他也得等等。

        ```java
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(2); // 容量为 2 的阻塞队列
        // 生产者线程
        Runnable producer = () -> {
            try {
                queue.put("item1"); // 放入元素，如果队列满则阻塞
                System.out.println("生产者放入 item1");
                queue.put("item2");
                System.out.println("生产者放入 item2");
                queue.put("item3"); // 队列已满，生产者将在此阻塞，直到有消费者取出元素
                System.out.println("生产者放入 item3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        // 消费者线程
        Runnable consumer = () -> {
            try {
                Thread.sleep(1000); // 模拟消费者处理需要时间
                String item = queue.take(); // 取出元素，如果队列空则阻塞
                System.out.println("消费者取出 " + item);
                item = queue.take();
                System.out.println("消费者取出 " + item);
                item = queue.take();
                System.out.println("消费者取出 " + item);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        new Thread(producer, "生产者").start();
        new Thread(consumer, "消费者").start();
        ```

:::

::: details 什么是 Java 的 CAS（Compare-And-Swap）操作？

CAS 是一种非常巧妙且高效的并发操作，它避免了传统锁机制（比如 `synchronized`）带来的性能开销。

**CAS 的核心思想：**

- 它包含三个操作数：

    1. **内存位置 (V)**：你要操作的变量在内存中的位置。
    2. **预期旧值 (A)**：你认为这个变量现在应该是什么值。
    3. **新值 (B)**：如果变量的值符合你的预期，你想把它改成什么值。

**操作过程：**

1. **线程 A 说**：“我打算把内存中 `X` 位置的值从 `旧值1` 改成 `新值2`。”
2. **CAS 操作**：它会去检查 `X` 位置的值是不是真的还是 `旧值1`。
    - **如果是 `旧值1`**：说明在线程 A 检查到它并打算修改的这段时间里，没有其他线程动过它，那么 CAS 操作就成功，把 `X` 位置的值改成 `新值2`。
    - **如果不是 `旧值1`**：说明有其他线程在我不知情的情况下，已经把 `X` 位置的值改掉了。CAS 操作就失败，不进行任何修改。
3. **线程 A 的后续**：如果 CAS 失败，线程 A 通常会选择**重试**（重新读取当前值，再次尝试 CAS），或者**放弃**。

**类比：**

- 想象你正在买一件限量版 T 恤，只剩最后一件了。

  - **内存位置 (V)**：就是“这件 T 恤是否还有货”的状态，比如用数字 `1` 表示有货，`0` 表示没货。
  - **预期旧值 (A)**：你去买的时候，你心想这件 T 恤“应该还有货”（预期旧值是 `1`）。
  - **新值 (B)**：如果有货，你就把它买走，状态变成“没货”（新值是 `0`）。

- 你拿着钱去柜台：

  1. **你（线程 A）对店员（CAS 操作）说**：“如果这件 T 恤还有货（当前是 `1`），我就把它买走，变成没货（改成 `0`）。”
  2. **店员（CAS）立刻看一眼货架：**
      - **如果真的还有货（是 `1`）**：那么你买成功了，T 恤变成没货（改成 `0`），交易完成。
      - **如果已经没货了（是 `0`）**：说明在你来之前，别人已经买走了。你的交易失败。
  3. 你买失败后，通常会选择**再看一眼其他款式的 T 恤（重试其他操作）**，或者**干脆不买了（放弃）**。

**CAS 的优点：**

- **非阻塞**：不会像锁一样导致其他线程阻塞等待，而是失败后重试，减少了上下文切换的开销。
- **原子性**：比较和交换是硬件层面提供的原子操作，要么都成功，要么都失败，不会出现中间状态。
- **适用于竞争不激烈的情况**：在线程冲突较少的情况下，CAS 的性能通常优于锁。

**CAS 的缺点：**

- **ABA 问题**：如果一个值从 `A` 变成 `B`，又从 `B` 变回 `A`，那么 CAS 会认为没有发生变化，但实际上已经变过了。这个问题可以通过引入版本号（`AtomicStampedReference`）来解决。
- **循环时间长开销大**：如果 CAS 操作总是失败，会不断自旋重试，浪费 CPU 资源。
- **只能保证一个共享变量的原子操作**：如果需要同时操作多个共享变量，CAS 就无能为力了，需要使用锁或者 `AtomicReference`。

Java 中的 `java.util.concurrent.atomic` 包下的类（如 `AtomicInteger`、`AtomicLong`）就是基于 CAS 实现的，它们提供了一些基本类型的原子操作。

:::
