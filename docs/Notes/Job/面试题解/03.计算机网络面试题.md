# 计算机网络面试题

::: details 常见的 HTTP 状态码有哪些？

HTTP 状态码是服务器对请求的响应结果，由三位数字组成，第一位数字定义了响应的类别。以下是一些最常见和重要的 HTTP 状态码：

- **1xx - 信息响应（Informational responses）**：表示请求已被接收，继续处理。

  | 状态码  | 名称                | 描述                 | 常见应用场景                               |
  | ------- | ------------------- | -------------------- | ------------------------------------------ |
  | **100** | Continue            | 客户端应继续发送请求 | 大文件上传前，客户端检查服务器是否接受请求 |
  | **101** | Switching Protocols | 服务器已切换协议     | WebSocket 连接建立                         |

- **2xx - 成功响应（Successful responses）**：表示请求已被成功接收、理解、接受。

  | 状态码  | 名称            | 描述                                                    | 常见应用场景                     |
  | ------- | --------------- | ------------------------------------------------------- | -------------------------------- |
  | **200** | OK              | 请求成功，最常见的状态码                                | 页面加载、API 请求成功           |
  | **201** | Created         | 请求已成功，并创建了新的资源                            | 创建用户、提交文章等 POST 请求   |
  | **202** | Accepted        | 请求已接受处理，但处理尚未完成                          | 异步处理，如排队任务             |
  | **204** | No Content      | 请求成功，但响应报文不含实体的主体部分                  | 删除操作、PUT 更新后无新内容返回 |
  | **206** | Partial Content | 客户端进行了范围请求，服务器成功执行了这部分的 GET 请求 | 文件断点续传、视频分段加载       |

- **3xx - 重定向（Redirection messages）**：表示需要采取进一步操作才能完成请求。

  | 状态码  | 名称               | 描述                                                          | 常见应用场景                       |
  | ------- | ------------------ | ------------------------------------------------------------- | ---------------------------------- |
  | **301** | Moved Permanently  | 永久重定向。资源已永久地移动到新 URI                          | 网站域名变更、HTTP 到 HTTPS 重定向 |
  | **302** | Found              | 临时重定向。资源临时地移动到新 URI                            | 临时页面调整、负载均衡             |
  | **303** | See Other          | 告知客户端使用 GET 方法访问另一个 URI 来获取资源              | POST 请求后，引导用户查看结果页面  |
  | **304** | Not Modified       | 协商缓存命中。资源未修改，客户端可使用缓存版本                | 浏览器缓存优化                     |
  | **307** | Temporary Redirect | 临时重定向。与 302 类似，但要求客户端继续使用相同的 HTTP 方法 | 临时页面调整（保留方法）           |
  | **308** | Permanent Redirect | 永久重定向。与 301 类似，但要求客户端继续使用相同的 HTTP 方法 | 域名变更（保留方法）               |

- **4xx - 客户端错误（Client error responses）**：表示客户端发送的请求包含错误或无法完成。

  | 状态码  | 名称                   | 描述                                                     | 常见应用场景                         |
  | ------- | ---------------------- | -------------------------------------------------------- | ------------------------------------ |
  | **400** | Bad Request            | 客户端请求有语法错误，不能被服务器理解                   | 请求参数错误、格式不正确             |
  | **401** | Unauthorized           | 请求需要用户认证                                         | 访问受保护资源未提供认证信息         |
  | **403** | Forbidden              | 服务器已理解请求，但拒绝执行（通常是权限问题）           | 无权访问、IP 被禁止                  |
  | **404** | Not Found              | 请求的资源不存在。最常见的错误状态码                     | URL 路径错误、资源已被删除           |
  | **405** | Method Not Allowed     | 请求方法（如 GET, POST）不被允许用于请求的资源           | 对不支持 POST 的接口发送 POST 请求   |
  | **408** | Request Timeout        | 客户端在服务器等待请求时，没有在允许的时间内完成发送请求 | 客户端网络问题，请求发送超时         |
  | **409** | Conflict               | 请求与服务器的当前状态冲突                               | 并发修改冲突（如乐观锁）、资源已存在 |
  | **413** | Payload Too Large      | 请求的实体过大，服务器无法处理                           | 上传文件过大                         |
  | **415** | Unsupported Media Type | 请求的媒体类型（Content-Type）不被服务器支持             | 发送了服务器不支持的 Content-Type    |
  | **429** | Too Many Requests      | 客户端在给定时间内发送了太多请求（速率限制）             | 短时间内大量请求，被服务器限流       |

- **5xx - 服务器错误（Server error responses）**：表示服务器在尝试处理请求时发生了错误。

  | 状态码  | 名称                  | 描述                                                                   | 常见应用场景                     |
  | ------- | --------------------- | ---------------------------------------------------------------------- | -------------------------------- |
  | **500** | Internal Server Error | 服务器遇到了一个意外情况，阻止其完成请求。最常见的服务器端错误         | 后端代码错误、服务器配置问题     |
  | **501** | Not Implemented       | 服务器不支持请求的功能，无法完成请求                                   | 请求了服务器未实现的 API         |
  | **502** | Bad Gateway           | 作为网关或代理工作的服务器收到了上游服务器的无效响应                   | 网关与后端服务通信失败           |
  | **503** | Service Unavailable   | 服务器目前无法处理请求，通常是由于服务器过载或停机维护                 | 服务器维护、流量高峰导致服务崩溃 |
  | **504** | Gateway Timeout       | 作为网关或代理工作的服务器未能及时从上游服务器或某些辅助服务器接收响应 | 网关等待后端服务响应超时         |

:::

::: details HTTP 请求包含哪些内容，请求头和请求体有哪些类型？

HTTP 请求由三个主要部分组成：

- **请求行 (Request Line)**：包含**请求方法**、**请求 URI** 和 **HTTP 协议版本**。`GET /index.html HTTP/1.1`
- **请求头 (Request Headers)**：包含客户端环境信息、请求体信息、认证信息等。键值对形式。
- **空行 (Blank Line)**：用于分隔请求头和请求体。
- **请求体 (Request Body)**：包含客户端发送给服务器的数据，通常在 POST、PUT 等方法中出现。

**请求头 (Request Headers) 的类型**

请求头包含各种元数据，用于描述请求的上下文。一些常见的请求头类型：

- **通用头 (General Headers)**：既可用于请求又可用于响应，例如
  - `Connection: keep-alive` (保持连接)
  - `Cache-Control: no-cache` (不使用缓存)
- **请求头 (Request Headers)**：仅用于请求，提供更多关于请求或客户端的信息，例如
  - `Host: www.example.com` (请求的目标主机)
  - `User-Agent: Mozilla/5.0 (...)` (客户端代理信息，通常是浏览器信息)
  - `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8` (客户端可接受的媒体类型)
  - `Accept-Language: zh-CN,zh;q=0.8` (客户端可接受的语言)
  - `Accept-Encoding: gzip, deflate, sdch` (客户端可接受的编码方式)
  - `Cookie: key=value` (客户端发送给服务器的 Cookie)
  - `Referer: http://www.example.com/previous-page.html` (请求的来源页面)
  - `Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==` (认证信息，如 Basic Auth, Bearer Token)
  - `If-Modified-Since: Tue, 15 Nov 1994 12:45:26 GMT` (用于条件请求，协商缓存)
- **实体头 (Entity Headers)**：描述请求体或响应体的资源信息，例如
  - `Content-Type: application/json` (请求体的媒体类型)
  - `Content-Length: 123` (请求体的字节长度)

**请求体 (Request Body) 的类型**

请求体用于承载客户端需要发送给服务器的数据。其类型主要由 `Content-Type` 请求头指定。常见的请求体类型包括：

1. **`application/x-www-form-urlencoded`:**
    - **描述**：最常见的表单提交方式。数据被编码成键值对，用 `&` 分隔，键和值之间用 `=` 连接，特殊字符会被编码。
    - **示例**：`name=Alice&age=30`
    - **场景**：传统的 HTML 表单 `method="POST"` 且不指定 `enctype` 时的默认类型。

2. **`multipart/form-data`:**
    - **描述**：用于提交包含文件（二进制数据）的表单。每个表单字段或文件都被分成独立的部分（part），用一个分隔符（boundary）隔开。
    - **示例:**

      ```txt
      Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
      ------WebKitFormBoundary7MA4YWxkTrZu0gW
      Content-Disposition: form-data; name="username"

      Alice
      ------WebKitFormFormBoundary7MA4YWxkTrZu0gW
      Content-Disposition: form-data; name="profile_picture"; filename="me.jpg"
      Content-Type: image/jpeg

      ... (binary image data) ...
      ------WebKitFormBoundary7MA4YWxkTrZu0gW--
      ```

    - **场景**：HTML 表单 `method="POST"` 且 `enctype="multipart/form-data"` 时，常用于文件上传。

3. **`application/json`:**
    - **描述**：以 JSON 格式传输数据。这是现代 Web API 和前后端分离应用中最常用的数据交换格式。
    - **示例**：`{"name": "Bob", "age": 25}`
    - **场景**：RESTful API 调用，前端（如 React, Vue, Angular）通过 AJAX/Fetch 发送数据到后端。

4. **`text/plain`:**
    - **描述**：纯文本数据，不进行任何特殊编码或格式化。
    - **示例**：`Hello, this is plain text.`
    - **场景**：不常用，有时用于发送简单的文本信息，或者调试。

5. **`application/xml` 或 `text/xml`:**
    - **描述**：以 XML 格式传输数据。在某些传统企业级应用或 SOAP 服务中仍有使用。
    - **示例**：`<user><name>Charlie</name><age>35</age></user>`
    - **场景**：老旧的 Web Service (SOAP)。

6. **二进制数据 (Binary Data):**
    - **描述**：直接传输原始的二进制数据，没有特定的结构，`Content-Type` 会是具体的媒体类型，如 `image/jpeg`, `audio/mpeg`, `application/octet-stream` (通用二进制流)。
    - **示例**：直接的图片、音频、视频文件内容。
    - **场景**：直接上传文件内容，而不是通过 `multipart/form-data` 封装。

:::

::: details HTTP 中 GET 和 POST 的区别是什么？

GET 和 POST 是 HTTP 协议中最常用的两种请求方法，它们在语义、用途、数据传输方式、安全性等方面存在显著区别：

| 特性              | GET 请求                                                                                                                        | POST 请求                                                                                                            |
| :---------------- | :------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------- |
| **语义/用途*-     | **获取/检索** 资源。通常用于从服务器请求数据。                                                                                  | **提交/创建/更新** 资源。通常用于向服务器发送数据以进行处理。                                                        |
| **幂等性*-        | **幂等**：多次请求同一个 GET URL，只要资源未改变，结果都是相同的，不会对服务器状态造成副作用。                                  | **非幂等**：多次提交相同的 POST 请求可能会导致不同的结果（例如，每次提交都会创建新的资源）。                         |
| **安全性*-        | **不安全**：不是指数据加密，而是数据以明文显示在 URL 中，容易被浏览器历史记录、服务器日志、代理服务器缓存。不适合传输敏感信息。 | **相对安全**：数据放在请求体中，URL 中不显示，因此不会被浏览器历史记录、服务器日志直接记录，但数据本身也不是加密的。 |
| **可见性*-        | 参数通过 **URL 的查询字符串** 传输，在地址栏可见。                                                                              | 参数通过 **请求体** 传输，在地址栏不可见。                                                                           |
| **数据长度限制**  | **有限制**：URL 的长度通常有浏览器和服务器的限制（通常在 2KB - 8KB 之间）。                                                     | **无限制**：请求体的大小理论上没有限制，只受服务器处理能力和内存的限制。                                             |
| **缓存*-          | **可以缓存**：浏览器和代理服务器可以缓存 GET 请求的响应，以提高性能。                                                           | **不能缓存**：POST 请求的响应默认不能被缓存。                                                                        |
| **历史记录/收藏** | **可以收藏/添加到书签**：因为请求参数包含在 URL 中。                                                                            | **不能收藏/添加到书签**：因为请求体中的数据不会被保存。                                                              |
| **回退/刷新*-     | 回退和刷新页面无副作用。                                                                                                        | 回退或刷新页面时，浏览器通常会提示用户是否重新提交表单，因为重复提交可能导致副作用。                                 |

**总结：**

- **GET** 主要用于**获取**数据，不应改变服务器状态，数据放在 URL 中。适合查询、获取列表、查看详情等操作。
- **POST** 主要用于**提交**数据，通常会改变服务器状态（如创建新用户、提交订单），数据放在请求体中。适合创建、更新、删除等操作。

:::

::: details HTTP 1.0 和 2.0 有什么区别？

HTTP/1.0 是一个连接在每次请求/响应后都会关闭的协议。这意味着如果客户端请求了网页及其所有图片，它将为每个图片文件建立一个新的连接。

HTTP/2.0 是基于 SPDY 协议的，旨在解决 HTTP/1.x 的性能瓶颈。它引入了多项关键特性来提高 Web 性能。

**主要区别：**

1. **多路复用（Multiplexing）：**
    - **HTTP/1.0**：一次连接只能处理一个请求。如果需要发送多个请求，就必须建立多个 TCP 连接，或者等待当前请求响应后才能发送下一个请求（队头阻塞）。
    - **HTTP/2.0**：引入了二进制分帧层。它允许在同一个 TCP 连接上同时发送多个请求和响应。每个请求/响应都被分成更小的帧，可以独立发送、乱序到达，然后在另一端重新组装，这解决了队头阻塞（Head-of-Line Blocking）问题。

2. **二进制分帧（Binary Framing）：**
    - **HTTP/1.0**：基于文本协议，头部信息冗余且解析效率低。
    - **HTTP/2.0**：采用二进制协议，所有通信都是二进制帧，更紧凑、更高效，解析也更快。

3. **头部压缩（Header Compression）：**
    - **HTTP/1.0**：每次请求都会发送完整的头部信息，即使很多头部字段都是重复的，浪费带宽。
    - **HTTP/2.0**：使用 HPACK 算法对头部进行压缩。它维护一个共享的静态和动态表，只发送头部字段的增量或索引，大大减少了头部开销。

4. **服务器推送（Server Push）：**
    - **HTTP/1.0**：客户端发起请求后，服务器只能返回所请求的资源。如果该资源依赖其他资源（如 HTML 文件依赖 CSS 和 JS），客户端需要解析完 HTML 后再发起额外的请求。
    - **HTTP/2.0**：服务器可以在客户端明确请求之前，主动将一些它预测客户端会需要的资源（如 CSS、JS、图片）推送给客户端。这减少了客户端 - 服务器往返次数，提高了加载速度。

5. **请求优先级（Request Prioritization）：**
    - **HTTP/1.0**：无法为请求设置优先级。
    - **HTTP/2.0**：客户端可以为请求设置优先级，服务器可以根据这些优先级决定发送响应的顺序，确保关键资源优先传输。

6. **连接管理：**
    - **HTTP/1.0**：短连接，每个请求都会建立新的 TCP 连接，开销大。
    - **HTTP/2.0**：长连接，一个 TCP 连接可以承载多个并发请求，减少了 TCP 连接的建立和关闭开销。

**总结表格：**

| 特性           | HTTP/1.0                 | HTTP/2.0                                   |
| :------------- | :----------------------- | :----------------------------------------- |
| **连接模型**   | 短连接（每个请求新连接） | 长连接（单一连接多请求）                   |
| **传输方式**   | 文本协议                 | 二进制分帧                                 |
| **并发性**     | 串行请求，队头阻塞       | 多路复用，并行请求，解决队头阻塞（应用层） |
| **头部开销**   | 无压缩，重复发送         | HPACK 压缩，减少开销                       |
| **服务器推送** | 不支持                   | 支持                                       |
| **请求优先级** | 不支持                   | 支持                                       |
| **性能**       | 较低                     | 较高                                       |

:::

::: details HTTP 2.0 和 3.0 有什么区别？

HTTP/3.0 是 HTTP/2.0 的演进版本，其最显著的变化是放弃了 TCP 协议，转而使用基于 UDP 的 **QUIC (Quick UDP Internet Connections)** 协议。

**主要区别：**

1. **底层传输协议：**
    - **HTTP/2.0**：基于 **TCP** 协议。
    - **HTTP/3.0**：基于 **UDP** 协议，并在此基础上实现了 **QUIC** 协议。

2. **TCP 队头阻塞（Head-of-Line Blocking）的根本解决：**
    - **HTTP/2.0**：虽然通过多路复用解决了**应用层**的队头阻塞（一个连接上可以并行发送多个请求），但如果底层的 TCP 丢包，所有通过该 TCP 连接传输的数据流都会受影响，因为它必须等待丢失的包被重传，这就是 **TCP 层面的队头阻塞**。
    - **HTTP/3.0**：QUIC 协议在 UDP 之上实现了自己的可靠传输、流量控制和拥塞控制。QUIC 的一个核心特性是它支持**独立的流**。即使一个流的某个数据包丢失，也只会影响这一个流，而不会阻塞同一连接上的其他流。这彻底解决了 TCP 带来的队头阻塞问题。

3. **连接建立时间（握手延迟）：**
    - **HTTP/2.0**：需要进行 TCP 三次握手，如果是 HTTPS，还需要额外的 TLS 握手（通常是 2-RTT 或 3-RTT）。
    - **HTTP/3.0**：QUIC 协议将握手过程简化。
        - **首次连接**：可以一次性完成加密和传输协议的握手（1-RTT），甚至在某些情况下，如果客户端已经与服务器建立过连接，可以实现 **0-RTT** 握手（类似 TCP Fast Open），大大减少了连接建立时间。
        - QUIC 的加密是内置的，它总是加密的。

4. **连接迁移（Connection Migration）：**
    - **HTTP/2.0**：TCP 连接是基于 IP 地址和端口号的。如果客户端的网络发生变化（例如从 Wi-Fi 切换到蜂窝网络，IP 地址会改变），TCP 连接会断开并需要重新建立，导致服务中断。
    - **HTTP/3.0**：QUIC 连接是基于一个 Connection ID 的。客户端的 IP 地址或端口号变化时，只要 Connection ID 不变，连接就可以维持，而不需要重新建立连接，这对于移动设备尤其重要。

5. **安全性：**
    - **HTTP/2.0**：通常与 TLS/SSL 结合使用，但 TLS 是一个独立层。
    - **HTTP/3.0**：QUIC 协议本身就集成了 TLS 1.3 的加密能力，默认就是加密的，增强了安全性。

**总结表格：**

| 特性           | HTTP/2.0                    | HTTP/3.0                                           |
| :------------- | :-------------------------- | :------------------------------------------------- |
| **底层协议**   | TCP                         | UDP (基于 QUIC)                                    |
| **队头阻塞**   | 应用层解决，但 TCP 层仍存在 | 根本解决（QUIC 的独立流）                          |
| **连接建立**   | TCP + TLS 握手（2-3 RTT）   | QUIC 握手（1-RTT，甚至 0-RTT）                     |
| **连接迁移**   | 不支持（IP/端口改变需重连） | 支持（基于 Connection ID）                         |
| **安全性**     | TLS 独立于 HTTP/2.0 实现    | QUIC 内置 TLS 1.3，默认加密                        |
| **多路复用**   | 支持（基于帧）              | 支持（基于 QUIC 流）                               |
| **服务器推送** | 支持                        | 支持                                               |
| **头部压缩**   | HPACK                       | QPACK（基于 HPACK 改进，更适合乱序交付的 QUIC 流） |
| **应用场景**   | 大部分 Web 服务             | 对延迟敏感、移动设备频繁切换网络的场景更优         |

:::

::: details HTTP 和 HTTPS 有什么区别？

HTTP 是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是万维网数据通信的基础，以明文方式发送数据。

HTTPS 是 HTTP 的安全版本，通过在 HTTP 层和 TCP 层之间添加一个安全层（SSL/TLS），对通信数据进行加密，保证数据的完整性和隐私性。

**主要区别：**

1. **安全性：**
    - **HTTP**：数据传输是**明文**的，不加密。这意味着传输的数据（如用户名、密码、信用卡信息）可以被第三方截获并直接读取，存在**数据泄露和篡改**的风险。
    - **HTTPS**：数据传输是**加密**的。通过 SSL/TLS 协议对数据进行加密，即使数据被截获，也无法直接读取其内容，大大提高了数据传输的安全性、完整性和隐私性。

2. **默认端口：**
    - **HTTP**：默认使用端口 **80**。
    - **HTTPS**：默认使用端口 **443**。

3. **连接方式：**
    - **HTTP**：直接与 TCP 连接。
    - **HTTPS**：在 TCP 握手完成后，需要额外的 SSL/TLS 握手过程来建立加密通道。

4. **证书：**
    - **HTTP**：不需要任何证书。
    - **HTTPS**：需要 **SSL/TLS 证书**。这个证书由权威的第三方机构（CA，Certificate Authority）颁发，用于验证服务器的身份。客户端在访问 HTTPS 网站时，会验证服务器的证书是否合法有效，防止中间人攻击。

5. **成本：**
    - **HTTP**：通常没有额外成本（除了域名和服务器）。
    - **HTTPS**：需要购买和维护 SSL/TLS 证书（尽管现在有很多免费证书如 Let's Encrypt），并且服务器需要额外的计算资源进行加密解密，可能会略微增加服务器负载（但现代硬件影响很小）。

6. **SEO（搜索引擎优化）：**
    - **HTTP**：搜索引擎（尤其是 Google）会优先收录和排名使用 HTTPS 的网站，因为它们更安全，用户体验更好。HTTP 网站可能会被标记为“不安全”。
    - **HTTPS**：对 SEO 友好，有助于提高网站的搜索排名。

7. **显示方式：**
    - **HTTP**：浏览器地址栏通常显示为 `http://`，并且可能会显示“不安全”的警告。
    - **HTTPS**：浏览器地址栏通常显示为 `https://`，并伴随一个锁形图标，表示连接是安全的。

**SSL/TLS 握手过程简述（HTTPS 的核心）：**

1. **客户端发起 Client Hello**：客户端向服务器发送支持的 SSL/TLS 版本、加密算法套件列表、随机数等。
2. **服务器响应 Server Hello**：服务器从客户端提供的列表中选择一个最佳的加密套件、返回服务器的随机数、以及服务器的数字证书（包含公钥和服务器信息）。
3. **客户端验证证书**：客户端验证服务器证书的合法性、有效性（是否过期、是否由信任的 CA 颁发等）。如果验证失败，会发出警告。
4. **客户端生成预主密钥**：客户端生成一个随机的预主密钥（Pre-Master Secret），并使用服务器证书中的公钥对其进行加密。
5. **客户端发送加密的预主密钥**：客户端将加密后的预主密钥发送给服务器。
6. **服务器解密预主密钥**：服务器使用自己的私钥解密预主密钥。
7. **生成会话密钥**：客户端和服务器都使用客户端随机数、服务器随机数和预主密钥通过协商的算法生成相同的**会话密钥（Session Key）**。
8. **加密通信**：客户端和服务器后续的所有通信都将使用这个会话密钥进行对称加密和解密。

**总结表格：**

| 特性         | HTTP                         | HTTPS                                                |
| :----------- | :--------------------------- | :--------------------------------------------------- |
| **安全性**   | 明文传输，不安全             | 加密传输，安全（SSL/TLS）                            |
| **默认端口** | 80                           | 443                                                  |
| **证书**     | 不需要                       | 需要 SSL/TLS 证书                                    |
| **成本**     | 低                           | 相对高（证书费用，但有免费证书）                     |
| **SEO**      | 不利                         | 有利                                                 |
| **速度**     | 理论上略快（无加密解密开销） | 理论上略慢（加密解密和握手开销），但现代硬件影响很小 |
| **身份验证** | 无                           | 服务器身份验证（通过证书）                           |

:::
