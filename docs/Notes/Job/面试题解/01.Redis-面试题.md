# Redis 面试题

::: details Redis 中常见的数据类型有哪些？

Redis 常见的五种基本数据类型：

1. **String（字符串）**
    - **大白话**：最简单的，就是存文本、数字什么的。可以是一个单词，一句话，一个 JSON 字符串，或者一个整数。
    - **能干啥**：存用户信息（用户名、年龄）、文章内容、计数器（点赞数、访问量）。
    - **特点**：可以存二进制数据，最大 512MB。对整数有专门的优化，进行加减操作时很快。

2. **Hash（哈希）**
    - **大白话**：就像一个“字典”或者“对象”。一个键（key）对应一个哈希，这个哈希里又有很多“字段 - 值”对。
    - **能干啥**：存一个对象的多个属性，比如用户的 `ID` 对应一个 `Hash`，这个 `Hash` 里有 `name`、`age`、`email` 等字段。
    - **特点**：适合存储对象数据，可以一次性获取或修改对象的某个字段，节省内存。

3. **List（列表）**
    - **大白话**：就像一个“双向链表”或者“队列”。可以从两头（左边或右边）添加或删除元素。
    - **能干啥：**
        - **消息队列**：生产者往列表右边添加消息，消费者从左边取消息。
        - **最新动态**：记录用户最新发布的几条微博、新闻列表。
        - **任务队列**：先进先出的任务排队。
    - **特点**：顺序存储，可以实现栈、队列等功能。

4. **Set（集合）**
    - **大白话**：就像数学里的“集合”。里面存了一堆不重复的元素，而且这些元素是无序的。
    - **能干啥：**
        - **好友关系**：共同好友、关注的人。
        - **抽奖活动**：存储参与抽奖的用户 ID，自动去重。
        - **标签系统**：一篇文章有多个标签，一个标签对应多篇文章。
    - **特点**：元素唯一，支持集合运算（交集、并集、差集）。

5. **ZSet / Sorted Set（有序集合）**
    - **大白话**：类似于 Set，也是存不重复的元素，但每个元素都会关联一个“分数”（score），然后根据这个分数来排序。分数相同就按字典序排。
    - **能干啥：**
        - **排行榜**：游戏积分榜、微博热搜榜（分数是热度）。
        - **带权重的任务队列**：优先级高的任务先执行。
    - **特点**：元素唯一且有序，可以根据分数范围查询。

:::

::: details Redis 为什么这么快？

主要有以下几个关键原因：

1. **基于内存操作：**
    - **大白话**：就像你把所有要用的文件都提前放到电脑内存里，而不是每次都去硬盘里找。
    - **解释**：Redis 的所有数据都存储在内存中，而内存的读写速度比硬盘快好几个数量级。这是 Redis 高性能的根本原因。

2. **高效的数据结构：**
    - **大白话**：Redis 不只是简单地把数据放进内存，它还为每种数据类型设计了非常适合快速操作的“容器”。
    - **解释**：Redis 内部使用了如跳跃表（skiplist）、哈希表、压缩列表等经过精心优化的数据结构。这些数据结构在进行增删改查操作时，效率非常高，通常能达到 O(1) 或 O(logN) 的时间复杂度。

3. **单线程模型（核心处理部分）：**
    - **大白话**：就像一个厨房里只有一位顶尖大厨，他做菜速度飞快，而且不用担心和别人抢炉子。
    - **解释**：Redis 的核心处理（处理客户端请求、读写数据）是单线程的。这意味着它省去了多线程场景下常见的上下文切换开销、锁竞争问题、死锁等复杂问题。这简化了设计，避免了同步开销，使得操作流程非常顺畅和高效。
    - **误区**：虽然核心是单线程，但 Redis 在处理持久化（RDB/AOF）、异步删除等后台任务时，会使用子进程或额外的线程来处理，避免阻塞主线程。

4. **非阻塞 I/O 多路复用：**
    - **大白话**：就像餐馆里只有一个服务员，但他非常聪明，他不是等一个客人点完菜才去服务下一个客人，而是同时留意所有客人的状态，谁叫他他就去谁那里。
    - **解释**：Redis 使用 I/O 多路复用技术（如 epoll/kqueue/select）来处理网络连接。它可以在一个线程中同时监听多个客户端连接的 I/O 事件。当某个连接有数据可读或可写时，Redis 才会去处理，而不是为每个连接创建一个线程去等待，从而避免了大量线程创建和上下文切换的开销。

5. **C 语言编写：**
    - **大白话**：用最高效的语言写的，底层优化做得好。
    - **解释**：Redis 使用 C 语言编写，C 语言对内存和系统资源的控制力更强，运行效率更高。

:::

::: details 为什么 Redis 设计为单线程？6.0 版本为何引入多线程？

**为什么 Redis 早期设计为单线程？**

Redis 早期（直到 6.0 版本之前，核心处理部分）设计为单线程，主要基于以下几点考虑：

1. **避免并发控制开销：**
    - **大白话**：单线程就不用操心多个员工同时操作一个文件时，怎么防止他们互相覆盖、互相打架的问题了。
    - **解释**：多线程编程最大的挑战就是并发控制，需要引入锁、信号量等机制来保护共享资源，而这些机制会带来额外的开销（上下文切换、锁竞争、死锁等），并且会增加程序的复杂性。单线程模型避免了这些问题，代码更简洁，执行效率更高。

2. **内存访问速度快：**
    - **大白话**：Redis 最大的瓶颈不是 CPU，而是内存。
    - **解释**：Redis 的数据全部在内存中，内存的访问速度非常快。在这种情况下，CPU 往往不是瓶颈，I/O 操作（网络请求、持久化）才是。单线程通过 I/O 多路复用技术，已经能够很好地处理并发连接，避免了不必要的 CPU 等待。

3. **更强的可维护性：**
    - **大白话**：一个人干活，出错了更容易排查。
    - **解释**：单线程模型使得 Redis 的代码逻辑更简单，更容易理解和维护，也减少了出现复杂并发 Bug 的可能性。

4. **CPU 瓶颈不是主要限制：**
    - **大白话**：Redis 的速度太快了，一般情况下，CPU 还没忙完，网络和内存就已经把数据准备好了。
    - **解释**：对于 Redis 这种内存型数据库，它的瓶颈通常在于内存容量、网络带宽，而非 CPU 的计算能力。单线程足以应对绝大多数场景，而且可以通过部署多个 Redis 实例（Redis Cluster）来利用多核 CPU。

**Redis 6.0 版本为何引入多线程？**

虽然单线程有很多优点，但随着网络硬件的升级（万兆网卡普及）和 CPU 核心数的增加，**网络 I/O 的处理逐渐成为了 Redis 单线程模型的瓶颈**。

- **大白话**：以前网速慢，一个大厨就能忙过来。现在网速太快了，数据像洪水一样涌进来，大厨一个人处理网络请求和数据操作就有点忙不过来了，尤其是在数据量特别大、网络带宽又充足的情况下。
- **解释**：以前 Redis 瓶颈更多是 CPU 核数不够用或网络带宽不足。但现在，CPU 核心数普遍增多，网卡性能大幅提升，导致主线程在处理网络读写（数据包解析、发送）时，成为了新的性能瓶颈。

**Redis 6.0 引入多线程的目的：**

Redis 6.0 引入的多线程**不是为了让数据操作（命令执行）变成多线程**，而是为了**分担网络 I/O 读写和解析的工作**。

1. **多线程处理网络 I/O**：Redis 6.0 将网络数据的读写和解析任务，从主线程中剥离出来，交给**多个 I/O 线程**去处理。
2. **主线程依然处理核心命令**：主线程依然负责执行 Redis 命令（例如 `SET`, `GET`, `LPUSH` 等），这意味着数据结构的访问和操作仍然是单线程的，这继续保留了单线程模型简单、无锁竞争的优点。
3. **提升吞吐量**：通过将网络 I/O 任务并行化，Redis 可以在处理相同数量的客户端连接时，显著提高吞吐量，尤其是在高并发和大数据量传输的场景下。

**总结**：Redis 6.0 引入多线程是对单线程模型的一种**优化和增强**，旨在解决**网络 I/O 瓶颈**，而不是改变其核心命令执行的单线程特性。它在保持原有的简单高效优势的同时，更好地利用了现代多核 CPU 的性能。

:::

::: details Redis 中跳表的实现原理是什么？

**大白话理解：**

想象一下你有一本厚厚的、按字母顺序排列的电话簿。如果你要找一个人的电话，你当然可以从头开始一页一页翻（这就是普通链表）。但这太慢了！

为了加速查找，你在电话簿上加了几层目录：

- **第一层目录**：最详细的目录，就是电话簿本身，按字母顺序排列所有名字。
- **第二层目录**：粗略目录，每隔几页标上“A 字头”、“B 字头”等等。
- **第三层目录**：更粗略的目录，可能只有“A-D”、“E-H”这样的范围。
- **第四层目录**：最粗略的，比如“上册”、“下册”。

当你要找一个名字时，你不是从头翻，而是先从最粗略的目录开始，快速跳到大概的范围，然后进入下一层目录，再跳到更小的范围，直到最终在最详细的目录中找到。

**Redis 跳表（SkipList）的实现原理就是这个思想：**

Redis 的 ZSet (有序集合) 底层就是用跳表来实现的。

1. **数据结构：**
    - **节点 (Node)**：跳表由多个节点组成，每个节点存储：
        - **值 (value/member)**：ZSet 中实际存储的元素（比如排行榜上的用户名称）。
        - **分数 (score)**：决定排序的数值（比如积分）。
        - **层 (level)**：每个节点都有一个随机生成的层数（高度）。层数越高，这个节点在“目录”中出现的频率就越低（跳跃的距离就越大）。
        - **前进指针 (forward pointer)**：每个节点在每一层都有一个指向下一个节点的指针。
    - **头节点 (Header)**：一个特殊的节点，不存储实际数据，它的层数是跳表的最高层数。
    - **尾节点 (Nil)**：一个特殊的节点，表示跳表的结束。

2. **查找过程：**
    - 当查找一个元素时，从跳表的**最高层**开始。
    - 在当前层，沿着前进指针向右遍历，如果当前节点的分数小于或等于要查找的分数，就继续向右。
    - 如果当前节点的分数大于要查找的分数，或者已经到了当前层的末尾，就**向下**一层。
    - 重复这个过程，直到到达最底层，就能找到目标元素或其插入位置。

3. **插入过程：**
    - 首先通过查找过程，找到新元素在每一层应该插入的位置。
    - 随机生成新节点的层数。
    - 修改相关层中节点的前进指针，将新节点插入到相应的位置。

4. **删除过程：**
    - 通过查找过程定位到要删除的节点。
    - 更新受影响的层中节点的前进指针，跳过要删除的节点。
    - 释放被删除节点的内存。

**跳表的优点：**

- **查找、插入、删除的平均时间复杂度都是 O(logN)。** 和红黑树、B+ 树等平衡二叉树类似，但实现起来更简单。
- **维护简单**：相比平衡二叉树，跳表的插入和删除操作只需要修改局部指针，不需要进行复杂的旋转或重新平衡操作。
- **空间换时间**：通过增加额外的指针（层数），来减少查找时遍历的节点数量。

**为什么 Redis 不用红黑树而用跳表？**

虽然红黑树的性能和跳表类似，但跳表在以下方面可能更具优势：

- **实现简单**：跳表的实现比红黑树更简单、更直观，Bug 更少。
- **范围查找**：跳表在进行范围查找时非常高效，例如查找分数在某个范围内的所有元素，只需在最底层遍历。红黑树需要中序遍历，效率可能略低。
- **并发性能**：在多线程环境下，跳表的并发性能可能更好，因为其局部性更强，加锁粒度可以更小（但 Redis 是单线程处理命令，这点不明显）。

:::

::: details Redis 的 hash 是什么？

**大白话理解：**

Redis 的 Hash 类型就像一个“哈希表”或者“字典”（在编程语言中常被称为 Map 或 Dictionary）。你可以把它想象成一个箱子，这个箱子有自己的名字（Redis key），箱子里面又分了很多小格子，每个小格子都有自己的标签（field）和里面放的东西（value）。

**结构：**

`key` (顶层 Redis key) → `Hash` (哈希表)

- `field1` → `value1`
- `field2` → `value2`
- `field3` → `value3`
- ...

**能干啥？**

最典型的应用是存储**对象**。

- **传统方式（String）**：存储一个用户对象，你可能需要存多个 String key：
  - `user:1:name` → `Alice`
  - `user:1:age` → `30`
  - `user:1:email` → `alice@example.com`
  - 这样不仅占用了更多 Redis key，而且获取用户所有信息需要多次网络请求。

- **Redis Hash 方式**：存储一个用户对象：
  - `user:1` (Hash key)
    - `name` → `Alice`
    - `age` → `30`
    - `email` → `alice@example.com`
  - 一次 `HGETALL user:1` 就能获取用户所有信息，大大减少了网络开销。

**底层实现：**

Redis 的 Hash 类型底层使用了两种数据结构来优化存储，会根据存储的数据量和字段长度自动切换：

1. **`ziplist` (压缩列表)：**
    - **大白话**：如果你箱子里的小格子（field-value 对）很少，而且格子里的东西也不大，Redis 会把它们紧凑地挨在一起放，非常省空间。
    - **条件**：当 Hash 存储的字段数量较少（`hash-max-ziplist-entries` 配置，默认 512）且所有字段和值的大小都较小（`hash-max-ziplist-value` 配置，默认 64 字节）时，Redis 会使用 `ziplist`。
    - **特点**：内存效率极高，但在增删改时可能需要重新分配内存，效率会略低。

2. **`hashtable` (哈希表)：**
    - **大白话**：如果箱子里的小格子很多，或者格子里的东西很大，Redis 就会用一个真正的哈希表（像 Java 的 HashMap），这样查找速度更快。
    - **条件**：当 Hash 满足不了 `ziplist` 的使用条件时（字段数量或字段值大小超过阈值），Redis 会将底层存储从 `ziplist` 转换为 `hashtable`。
    - **特点**：查找效率高（O(1)），但会占用更多内存。

**优点：**

- **节省内存**：尤其在存储大量小对象时，使用 Hash 比多个 String 更节省内存，因为每个 Hash 只需要一个顶层 Key。
- **减少网络开销**：获取或修改对象的多个属性时，一次操作就能完成，减少了客户端与 Redis 服务器之间的网络往返次数。

:::

::: details Redis Zset 的实现原理是什么？

**大白话理解：**

Redis 的 ZSet（有序集合）就像一个**带分数的排行榜**。每个榜单项目（member）都有一个独一无二的名字，并且有一个对应的分数（score）。Redis 会根据这个分数把它们从小到大排好。分数相同的话，就按名字的字母顺序排。

**结构：**

`key` (顶层 Redis key) → `ZSet` (有序集合)

- `member1` (score1)
- `member2` (score2)
- `member3` (score3)
- ... (按 score 排序)

**能干啥？**

最典型的应用就是各种**排行榜**，比如游戏积分榜、商品销售榜、微博热搜榜等等。你还可以根据分数范围查询，比如找出积分在 100 到 200 之间的玩家。

**底层实现：**

Redis 的 ZSet 也是根据存储的数据量和元素大小，以及 ZSet 的具体操作特点，自动切换底层的数据结构：

1. **`ziplist` (压缩列表)：**
    - **大白话**：当你的排行榜项目很少，而且每个项目的名字和分数也都不长时，Redis 会把它们紧凑地放在一起，非常省内存。
    - **条件**：当 ZSet 存储的元素数量较少（`zset-max-ziplist-entries` 配置，默认 128）且每个元素的值和分数都较小（`zset-max-ziplist-value` 配置，默认 64 字节）时，Redis 会使用 `ziplist`。
    - **存储方式**：在 `ziplist` 中，member 和 score 是紧挨着存放的，通过有序插入保证了顺序。
    - **特点**：内存效率高，但在元素较多时，增删改查需要移动大量数据，效率会下降。

2. **`skiplist` (跳表) + `hashtable` (哈希表)：**
    - **大白话**：当排行榜项目增多，或者单个项目内容变大时，Redis 会切换到更强大的组合拳：**跳表用来快速查找和范围查询，哈希表用来快速根据项目名字找到它的分数。**
    - **条件**：当 ZSet 不满足 `ziplist` 的条件时，Redis 会转换为 `skiplist` 和 `hashtable` 的组合结构。
    - **`skiplist` (跳表)**：负责根据 `score` 来排序和查找。它能以 O(logN) 的时间复杂度进行插入、删除、查找和范围查找（通过分数）。
    - **`hashtable` (哈希表)**：负责根据 `member`（元素名称）快速查找其对应的 `score`。这样，你可以根据元素名直接获取其分数，时间复杂度为 O(1)。
    - **特点**：这种组合实现了高效的插入、删除、查找和范围查询。跳表保证了有序性，哈希表保证了根据 `member` 的快速访问。

**总结：**

Redis 巧妙地利用了多种底层数据结构，并根据数据的特性和操作的频繁程度进行自动切换，以达到在不同场景下内存占用和性能的最佳平衡。这种设计是 Redis 如此高效和灵活的关键之一。

:::
