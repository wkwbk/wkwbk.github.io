# 双指针

## 移动零

::: code-group

```java [额外数组]
/**
 * <p>此方法使用一个额外数组，不满足原地操作的要求，但有助于理解逻辑。</p>
 *
 * <h3>算法思路：</h3>
 * <ol>
 *   <li>创建一个与原数组大小相同的新数组 {@code result}，并默认填充 0。</li>
 *   <li>使用一个指针 {@code nonZeroIdx} 追踪 {@code result} 数组中下一个可放置非零元素的索引。</li>
 *   <li>遍历原数组 {@code nums}：
 *     <ul>
 *       <li>如果遇到非零元素，将其复制到 {@code result[nonZeroIdx]}，并递增 {@code nonZeroIdx}。</li>
 *     </ul>
 *   </li>
 *   <li>遍历结束后，{@code result} 数组的前半部分是非零元素（保持相对顺序），后半部分是 0。</li>
 *   <li>将 {@code result} 数组的内容复制回原数组 {@code nums}。</li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n)} - 遍历 {@code nums} 一次，然后复制 {@code result} 回 {@code nums} 一次。</li>
 *   <li><strong>空间复杂度：</strong> {@code O(n)} - 使用了一个与原数组大小相同的额外数组。</li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 */
public void moveZeroes(int[] nums) {
    if (nums == null || nums.length == 0) {
        return;
    }

    int n = nums.length;
    int[] result = new int[n]; // 创建一个新数组，默认元素为 0
    int nonZeroIdx = 0;        // 指向 result 数组中下一个非零元素应该放置的位置

    // 遍历原数组，将所有非零元素按顺序填充到 result 数组的前面
    for (int num : nums) {
        if (num != 0) {
            result[nonZeroIdx] = num;
            nonZeroIdx++;
        }
    }

    // 将 result 数组的内容复制回 nums 数组
    // 由于 result 数组默认初始化为 0，并且 nonZeroIdx 之后的元素保持为 0，
    // 这样就完成了将所有 0 移动到末尾的操作。
    for (int i = 0; i < n; i++) {
        nums[i] = result[i];
    }
}
```

```java [双指针两阶段法]
/**
 * <p>此方法使用双指针（{@code writePointer} 和 {@code readPointer}），在原地进行操作，不使用额外空间，满足题目要求。</p>
 *
 * <h3>算法思路（两阶段法）：</h3>
 * <ol>
 *   <li><strong>阶段一：移动非零元素。</strong>
 *     <ul>
 *       <li>定义一个 {@code writePointer} (写入指针)，初始为 0。它指向数组中下一个非零元素应该放置的位置。</li>
 *       <li>定义一个 {@code readPointer} (读取指针)，初始为 0。它用于遍历数组 {@code nums} 中的所有元素。</li>
 *       <li>使用一个 {@code while} 循环，当 {@code readPointer} 未越界时：
 *         <ul>
 *           <li>如果当前元素 {@code nums[readPointer]} 是非零元素，将其复制到 {@code nums[writePointer]}，然后递增 {@code writePointer}。</li>
 *           <li>无论元素是否为零，都递增 {@code readPointer}，继续向后遍历。</li>
 *         </ul>
 *       </li>
 *       <li>此阶段结束后，数组的前 {@code writePointer} 个位置已经填充了所有非零元素，并且它们的相对顺序得以保持。而 {@code writePointer} 正好指向第一个 0 应该开始填充的位置。</li>
 *     </ul>
 *   </li>
 *   <li><strong>阶段二：填充剩余位置为零。</strong>
 *     <ul>
 *       <li>使用另一个 {@code while} 循环，从 {@code writePointer} 开始到数组的末尾，将所有元素都设置为 0。</li>
 *       <li>递增 {@code writePointer} 直到遍历完剩余所有位置。</li>
 *       <li>这些被填充为 0 的位置，要么原本就是 0，要么是被阶段一中的非零元素覆盖后，其原值（零）被移到了后面。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>优化关键点：</h3>
 * <ul>
 *   <li><strong>原地操作：</strong> 不使用任何额外数组，直接在原数组上修改。</li>
 *   <li><strong>双指针：</strong> {@code readPointer} 负责高效地读取元素，{@code writePointer} 负责精确地写入非零元素，确保非零元素的相对顺序。</li>
 *   <li><strong>清晰的两阶段：</strong> 明确分离了“移动非零元素”和“填充零”两个职责，使得逻辑更易于理解和实现。</li>
 *   <li><strong>高效填充：</strong> 将非零元素集中到前面，然后一次性填充后面的零，避免了不必要的元素移动或交换操作。</li>
 * </ul>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n)}
 *     <ul>
 *       <li>第一个 {@code while} 循环（移动非零元素）：{@code readPointer} 从 0 到 {@code n-1} 遍历一次，{@code O(n)}。</li>
 *       <li>第二个 {@code while} 循环（填充零）：{@code writePointer} 从某个位置（最坏情况为 0，最好情况为 {@code n}）遍历到 {@code n-1}，最多 {@code O(n)}。</li>
 *       <li>总时间复杂度为 {@code O(n)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)} - 仅使用了常数个额外变量（两个指针）。</li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 */
public void moveZeroes(int[] nums) {
    if (nums == null || nums.length == 0) {
        return;
    }

    int n = nums.length;
    int writePointer = 0; // writePointer 指向下一个非零元素应该写入的位置
    int readPointer = 0;  // readPointer 用于遍历数组，读取当前元素

    // 阶段一：将所有非零元素移动到数组的前面，同时保持相对顺序
    while (readPointer < n) {
        if (nums[readPointer] != 0) {
            nums[writePointer] = nums[readPointer];
            writePointer++;
        }
        readPointer++; // readPointer 总是前进
    }

    // 阶段二：从 writePointer 开始，将数组的剩余部分填充为 0
    // 此时 writePointer 指向第一个 0 应该放置的位置
    while (writePointer < n) {
        nums[writePointer] = 0;
        writePointer++; // 填充下一个 0
    }
}
```

```java [双指针交换法]
/**
 * <p>此方法采用双指针（{@code left} 和 {@code right}）和交换策略进行原地操作，不使用额外空间。</p>
 *
 * <h3>算法思路（双指针交换法）：</h3>
 * <ol>
 *   <li><strong>定义双指针：</strong>
 *     <ul>
 *       <li>{@code left} 指针：始终指向当前第一个 0 元素的位置（或即将放置非零元素的位置）。它将用于与 {@code right} 指针指向的非零元素进行交换。</li>
 *       <li>{@code right} 指针：负责遍历整个数组，寻找非零元素。</li>
 *     </ul>
 *   </li>
 *   <li><strong>遍历与交换：</strong>
 *     <ul>
 *       <li>当 {@code right} 指针遍历数组时：
 *         <ul>
 *           <li>如果 {@code nums[right]} 是<strong>非零元素</strong>：
 *             <ul>
 *               <li>这意味着我们找到了一个非零元素，它需要被移动到 {@code left} 指针指向的位置（该位置要么是 0，要么是其自身）。</li>
 *               <li>执行交换操作，将 {@code nums[right]} 处的非零元素与 {@code nums[left]} 处的元素交换。</li>
 *               <li>然后将 {@code left} 指针向右移动一位，准备寻找下一个需要放置非零元素的位置。</li>
 *             </ul>
 *           </li>
 *           <li>如果 {@code nums[right]} 是<strong>零元素</strong>：
 *             <ul>
 *               <li>不需要进行交换，因为我们希望 0 留在后面。</li>
 *               <li>{@code left} 指针保持不变，继续指向当前或之前的 0。</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *       <li>无论 {@code nums[right]} 是零还是非零，{@code right} 指针都会向右移动一位，继续遍历数组。</li>
 *     </ul>
 *   </li>
 *   <li><strong>最终状态：</strong> 当 {@code right} 遍历完整个数组后，所有非零元素都被移动到了数组的前部（通过交换操作），并且它们的相对顺序得以保持。而所有 0 都被“推”到了数组的末尾。</li>
 * </ol>
 *
 * <h3>优化关键点：</h3>
 * <ul>
 *   <li><strong>原地操作：</strong> 不使用任何额外数组，直接在原数组上修改。</li>
 *   <li><strong>双指针策略：</strong> 通过 {@code left} 和 {@code right} 两个指针协同工作，{@code right} 负责寻找非零元素，{@code left} 负责标记非零元素应该放置的位置。</li>
 *   <li><strong>保持相对顺序：</strong> 只有当 {@code nums[right]} 是非零元素时才进行交换，且 {@code left} 总是小于或等于 {@code right}，确保非零元素之间的相对顺序不会改变。</li>
 *   <li><strong>避免不必要的交换：</strong> 当 {@code nums[right]} 为零时，{@code left} 不动，{@code right} 继续前进，有效地将零跳过。当 {@code nums[right]} 非零且 {@code left == right} 时，虽然也执行了交换，但实际上是自己与自己交换，没有改变值，只是形式上保持了逻辑一致性。</li>
 * </ul>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n)}
 *     <ul>
 *       <li>两个指针都只遍历数组一次（{@code right} 完整遍历，{@code left} 最多移动 {@code n} 次）。</li>
 *       <li>每次遍历中的操作（比较、交换）都是常数时间操作。</li>
 *       <li>因此，总时间复杂度为 {@code O(n)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)} - 仅使用了常数个额外变量（指针和交换时的临时变量）。</li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 */
public void moveZeroes(int[] nums) {
    int n = nums.length;
    int left = 0;   // left 指针，指向当前第一个 0 出现的位置，或下一个非零元素应放置的位置
    int right = 0;  // right 指针，用于遍历数组，寻找非零元素

    // 当 right 指针没有越界时，持续遍历
    while (right < n) {
        // 如果 right 指针指向的元素是非零元素
        if (nums[right] != 0) {
            // 将 nums[right]（非零元素）与 nums[left] 处的元素进行交换
            // 这样就把非零元素移到了前面，同时把 0 移到了后面（或非零元素自身位置）
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++; // left 指针向右移动，准备放置下一个非零元素
        }
        right++; // right 指针总是向右移动，继续寻找
    }
}
```

:::

## 盛最多水的容器

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 三数之和

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 接雨水

::: code-group

```java []
/**
 * TODO
 */
```

:::
