# 矩阵

## 矩阵置零

::: code-group

```java [原地算法]
/**
 * <p>此方法解决“矩阵置零”问题，要求使用原地算法 (O(1) 额外空间) 和 O(M*N) 时间复杂度。</p>
 * <p>核心思想：利用矩阵的第一行和第一列来充当“标记数组”，记录哪些行和列需要被置为零。
 * 为了处理第一行和第一列本身可能需要被置零的情况，使用两个额外的布尔变量来记录它们的状态。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化标记变量和获取维度：</strong>
 *     <ul>
 *       <li>{@code boolean rowZero = false;}: 记录第一行是否需要被置零。</li>
 *       <li>{@code boolean colZero = false;}: 记录第一列是否需要被置零。</li>
 *       <li>获取矩阵的行数 {@code m = matrix.length} 和列数 {@code n = matrix[0].length}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>检查第一行和第一列是否包含 0：</strong>
 *     <ul>
 *       <li>遍历第一行（{@code matrix[0][j]}），如果发现任何一个元素为 0，则将 {@code rowZero} 设为 {@code true}。</li>
 *       <li>遍历第一列（{@code matrix[i][0]}），如果发现任何一个元素为 0，则将 {@code colZero} 设为 {@code true}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>使用第一行和第一列作为标记 (处理内部区域)：</strong>
 *     <ul>
 *       <li>遍历矩阵的内部区域（从 {@code i = 1} 到 {@code m-1}，从 {@code j = 1} 到 {@code n-1}）。</li>
 *       <li>如果 {@code matrix[i][j] == 0}：
 *         <ul>
 *           <li>将 {@code matrix[i][0]} 置为 {@code 0} (标记第 {@code i} 行需要置零)。</li>
 *           <li>将 {@code matrix[0][j]} 置为 {@code 0} (标记第 {@code j} 列需要置零)。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>根据标记将内部区域置零：</strong>
 *     <ul>
 *       <li>再次遍历矩阵的内部区域（从 {@code i = 1} 到 {@code m-1}，从 {@code j = 1} 到 {@code n-1}）。</li>
 *       <li>如果 {@code matrix[i][0] == 0} (表示第 {@code i} 行需要置零) 或者 {@code matrix[0][j] == 0} (表示第 {@code j} 列需要置零)：
 *         <ul>
 *           <li>将 {@code matrix[i][j]} 置为 {@code 0}。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>根据初始布尔变量处理第一行和第一列：</strong>
 *     <ul>
 *       <li>如果 {@code rowZero} 为 {@code true}，遍历第一行，将其所有元素置为 {@code 0}。</li>
 *       <li>如果 {@code colZero} 为 {@code true}，遍历第一列，将其所有元素置为 {@code 0}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(M*N)}。
 *     <ul>
 *       <li>有多次遍历矩阵的操作，每次遍历的复杂度都是 {@code O(M*N)}。
 *           因此总时间复杂度为 {@code O(M*N)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了几个常数级别的额外变量（{@code rowZero}, {@code colZero}, {@code m}, {@code n}）。
 *           对矩阵本身进行的修改不计入额外空间。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public void setZeroes(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return;
    }

    int m = matrix.length;
    int n = matrix[0].length;

    boolean rowZero = false; // 标记第一行是否需要被置零
    boolean colZero = false; // 标记第一列是否需要被置零

    // 1. 检查第一行是否包含 0
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) {
            rowZero = true;
            break; // 只要找到一个 0 即可
        }
    }

    // 2. 检查第一列是否包含 0
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) {
            colZero = true;
            break; // 只要找到一个 0 即可
        }
    }

    // 3. 使用第一行和第一列作为标记 (处理内部区域：从 [1][1] 开始)
    // 如果 matrix[i][j] 为 0，则将其对应的第一行元素和第一列元素置 0
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // 标记第 i 行
                matrix[0][j] = 0; // 标记第 j 列
            }
        }
    }

    // 4. 根据标记将内部区域置零 (从 [1][1] 开始)
    // 注意：这里要先处理内部区域，否则如果先处理了第一行/列，
    // 那么内部区域的标记可能会被覆盖，导致错误。
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // 5. 根据 rowZero 和 colZero 标记，处理第一行和第一列
    // 这一步必须在最后执行，以避免影响对内部区域的标记判断。
    if (rowZero) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }

    if (colZero) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
}
```

:::

## 螺旋矩阵

::: code-group

```java [模拟螺旋遍历]
/**
 * <p>此方法解决“螺旋矩阵”问题，按照顺时针螺旋顺序返回矩阵中的所有元素。</p>
 * <p>核心思想是模拟螺旋遍历的过程，通过维护四个边界变量 (上、下、左、右) 来控制遍历的范围，
 * 每次遍历完一个方向后收缩相应的边界，直到所有元素都被遍历。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个 {@link java.util.ArrayList} {@code result} 用于存储螺旋顺序的元素。</li>
 *       <li>获取矩阵的行数 {@code m = matrix.length} 和列数 {@code n = matrix[0].length}。
 *           如果矩阵为空，直接返回空列表。</li>
 *       <li>初始化边界变量：
 *         <ul>
 *           <li>{@code int top = 0; } (当前层的上边界行索引)</li>
 *           <li>{@code int bottom = m - 1; } (当前层的下边界行索引)</li>
 *           <li>{@code int left = 0; } (当前层的左边界列索引)</li>
 *           <li>{@code int right = n - 1; } (当前层的右边界列索引)</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环：</strong> 当 {@code top <= bottom} 并且 {@code left <= right} 时，循环继续。
 *       这确保了还有未遍历的区域。
 *     <ul>
 *       <li><strong>从左到右遍历上边界：</strong>
 *         <ul>
 *           <li>遍历 {@code j} 从 {@code left} 到 {@code right}，将 {@code matrix[top][j]} 添加到 {@code result}。</li>
 *           <li>{@code top++} (上边界下移，缩小范围)。</li>
 *         </ul>
 *       </li>
 *       <li><strong>从上到下遍历右边界：</strong>
 *         <ul>
 *           <li>在执行前，检查是否还有剩余行可以遍历 (即 {@code top <= bottom})。</li>
 *           <li>遍历 {@code i} 从 {@code top} 到 {@code bottom}，将 {@code matrix[i][right]} 添加到 {@code result}。</li>
 *           <li>{@code right--} (右边界左移，缩小范围)。</li>
 *         </ul>
 *       </li>
 *       <li><strong>从右到左遍历下边界：</strong>
 *         <ul>
 *           <li>在执行前，检查是否还有剩余行和列可以遍历 (即 {@code top <= bottom && left <= right})。
 *               这是为了处理单行或单列矩阵的情况，避免重复遍历。</li>
 *           <li>遍历 {@code j} 从 {@code right} 到 {@code left} (注意是递减)，将 {@code matrix[bottom][j]} 添加到 {@code result}。</li>
 *           <li>{@code bottom--} (下边界上移，缩小范围)。</li>
 *         </ul>
 *       </li>
 *       <li><strong>从下到上遍历左边界：</strong>
 *         <ul>
 *           <li>在执行前，检查是否还有剩余列可以遍历 (即 {@code top <= bottom && left <= right})。</li>
 *           <li>遍历 {@code i} 从 {@code bottom} 到 {@code top} (注意是递减)，将 {@code matrix[i][left]} 添加到 {@code result}。</li>
 *           <li>{@code left++} (左边界右移，缩小范围)。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回 {@code result} 列表。</strong></li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(M*N)}。
 *     <ul>
 *       <li>每个元素恰好被访问一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)} (不包括返回结果列表)。
 *     <ul>
 *       <li>我们只使用了常数个额外变量来控制边界和循环。</li>
 *       <li>如果将结果列表计算在内，则为 {@code O(M*N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();

    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return result;
    }

    int m = matrix.length;
    int n = matrix[0].length;

    int top = 0;        // 上边界行索引
    int bottom = m - 1; // 下边界行索引
    int left = 0;       // 左边界列索引
    int right = n - 1;  // 右边界列索引

    while (top <= bottom && left <= right) {
        // 1. 从左到右遍历上边界
        for (int j = left; j <= right; j++) {
            result.add(matrix[top][j]);
        }
        top++; // 上边界下移

        // 检查是否还有剩余行可以遍历
        if (top > bottom) break;

        // 2. 从上到下遍历右边界
        for (int i = top; i <= bottom; i++) {
            result.add(matrix[i][right]);
        }
        right--; // 右边界左移

        // 检查是否还有剩余列可以遍历
        if (left > right) break;

        // 3. 从右到左遍历下边界
        // 只有当有多个行时才需要向左遍历，避免单行重复
        for (int j = right; j >= left; j--) {
            result.add(matrix[bottom][j]);
        }
        bottom--; // 下边界上移

        // 检查是否还有剩余行可以遍历
        if (top > bottom) break;

        // 4. 从下到上遍历左边界
        // 只有当有多个列时才需要向上遍历，避免单列重复
        for (int i = bottom; i >= top; i--) {
            result.add(matrix[i][left]);
        }
        left++; // 左边界右移

        // 检查是否还有剩余列可以遍历
        if (left > right) break;
    }
    return result;
}
```

:::

## 旋转图像

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 搜索二维矩阵 II

::: code-group

```java []
/**
 * TODO
 */
```

:::
