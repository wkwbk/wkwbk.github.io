# 回溯

## 全排列

::: code-group

```java [回溯]
/**
 * <p>此方法解决“全排列”问题，采用经典的<strong>回溯算法</strong>。</p>
 * <p>核心思想：全排列问题是一个典型的组合搜索问题。我们可以通过深度优先搜索 (DFS) 的方式，
 * 在每一步尝试将一个未使用的数字添加到当前排列中。当排列的长度达到原始数组的长度时，
 * 就找到了一个完整的排列，将其加入结果集。之后，通过“回溯”操作（撤销之前的选择），
 * 探索其他可能的路径。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>主函数 {@code permute(nums)}：</strong>
 *     <ul>
 *       <li>{@code List<List<Integer>> result = new ArrayList<>();}：用于存储所有找到的全排列。</li>
 *       <li>{@code List<Integer> path = new ArrayList<>();}：用于存储当前正在构建的排列。</li>
 *       <li>{@code boolean[] used = new boolean[nums.length];}：一个布尔数组，用于标记 {@code nums} 数组中对应位置的元素是否已经在当前 {@code path} 中被使用过。初始全部为 {@code false}。</li>
 *       <li>调用辅助的回溯函数 {@code backtrack(nums, path, used, result)}。</li>
 *       <li>返回 {@code result}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>回溯辅助函数 {@code backtrack(nums, path, used, result)}：</strong>
 *     <ul>
 *       <li><strong>参数：</strong>
 *         <ul>
 *           <li>{@code nums}: 原始整数数组。</li>
 *           <li>{@code path}: 当前正在构建的排列。</li>
 *           <li>{@code used}: 标记 {@code nums} 中元素是否已使用的布尔数组。</li>
 *           <li>{@code result}: 存储所有完整排列的列表。</li>
 *         </ul>
 *       </li>
 *       <li><strong>递归终止条件 (Base Case)：</strong>
 *         <ul>
 *           <li>{@code if (path.size() == nums.length)}：如果当前 {@code path} 的长度等于原始数组 {@code nums} 的长度，说明已经构建了一个完整的排列。
 *             <ul>
 *               <li>{@code result.add(new ArrayList<>(path));}：将当前 {@code path} 的一个<strong>副本</strong>添加到 {@code result} 中。
 *                 <strong>注意：</strong> 必须是副本，因为 {@code path} 在后续的回溯过程中会被修改。</li>
 *               <li>{@code return;}：终止当前递归分支。</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *       <li><strong>递归选择与探索：</strong>
 *         <ul>
 *           <li>{@code for (int i = 0; i < nums.length; i++)}：遍历原始数组 {@code nums} 中的所有元素。
 *             <ul>
 *               <li>{@code if (!used[i])}：如果 {@code nums[i]} 还没有被使用过 (即 {@code used[i]} 为 {@code false})：
 *                 <ul>
 *                   <li><strong>选择 (Choose)：</strong>
 *                     <ul>
 *                       <li>{@code path.add(nums[i]);}：将 {@code nums[i]} 加入当前排列。</li>
 *                       <li>{@code used[i] = true;}：标记 {@code nums[i]} 为已使用。</li>
 *                     </ul>
 *                   </li>
 *                   <li><strong>探索 (Explore)：</strong>
 *                     <ul>
 *                       <li>{@code backtrack(nums, path, used, result);}：递归调用，继续构建排列的下一个位置。</li>
 *                     </ul>
 *                   </li>
 *                   <li><strong>撤销 (Unchoose/Backtrack)：</strong> 这是回溯的核心。当{@code backtrack}函数返回时，表示以当前选择{@code nums[i]}开头的路径已经探索完毕（或者已经找到了所有排列）。为了探索其他分支，需要撤销之前的选择，恢复到上一个状态。
 *                     <ul>
 *                       <li>{@code used[i] = false;}：将 {@code nums[i]} 的使用标记解除，使其在其他路径中可以被选择。</li>
 *                       <li>{@code path.remove(path.size() - 1);}：将 {@code nums[i]} 从当前排列中移除，尝试下一个可能的选择。</li>
 *                     </ul>
 *                   </li>
 *                 </ul>
 *               </li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N * N!)}。
 *     <ul>
 *       <li>其中 {@code N} 是数组 {@code nums} 的长度。</li>
 *       <li>生成 {@code N} 个数字的全排列有 {@code N!} 种。</li>
 *       <li>对于每一种排列，我们将其添加到结果列表中，这个操作需要 {@code O(N)} 的时间（复制 {@code path} 到 {@code ArrayList}）。</li>
 *       <li>因此，总时间复杂度是 {@code O(N * N!)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>{@code path} 列表的深度（即递归栈的深度）最大为 {@code N}。</li>
 *       <li>{@code used} 数组占用 {@code O(N)} 空间。</li>
 *       <li>{@code result} 列表存储了 {@code N!} 个排列，每个排列长度为 {@code N}。所以，如果把 {@code result} 算作额外空间的话，是 {@code O(N * N!)}。
 *         但在多数算法题的语境中，输出列表不计入空间复杂度，或者只计入存储单个排列的空间。这里的 {@code O(N)} 指的是递归栈和辅助 {@code used} 数组的空间。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>(); // 存储所有找到的全排列
    List<Integer> path = new ArrayList<>();         // 存储当前正在构建的排列
    boolean[] used = new boolean[nums.length];      // 标记每个数字是否已在当前排列中使用
    // 调用回溯辅助函数
    backtrack(nums, path, used, result);
    return result;
}

/**
 * 回溯辅助函数，用于生成全排列。
 *
 * @param nums   原始数组
 * @param path   当前正在构建的排列
 * @param used   布尔数组，标记 nums 中元素是否已使用
 * @param result 存储所有完整排列的列表
 */
private void backtrack(int[] nums, List<Integer> path, boolean[] used, List<List<Integer>> result) {
    // 递归终止条件：如果当前路径的长度等于原始数组的长度，说明已构建一个完整的排列
    if (path.size() == nums.length) {
        // 将当前路径的一个副本添加到结果列表中
        // 必须是副本，因为 path 在后续回溯中会被修改
        result.add(new ArrayList<>(path));
        return; // 终止当前递归分支
    }
    // 遍历所有数字，尝试将其加入当前排列
    for (int i = 0; i < nums.length; i++) {
        // 如果 nums[i] 还没有被使用过
        if (!used[i]) {
            // 1. 选择：将 nums[i] 加入当前排列
            path.add(nums[i]);
            used[i] = true; // 标记 nums[i] 为已使用
            // 2. 探索：递归调用，继续构建下一个位置
            backtrack(nums, path, used, result);
            // 3. 撤销：回溯，撤销 nums[i] 的使用标记，并从路径中移除
            // 恢复到上一个状态，以便尝试其他选择
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

:::

## 子集

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 电话号码的字母组合

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 组合总和

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 括号生成

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 单词搜索

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 分割回文串

::: code-group

```java []
/**
 * TODO
 */
```

:::

## N 皇后

::: code-group

```java []
/**
 * TODO
 */
```

:::
