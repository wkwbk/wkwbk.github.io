# 链表

## 相交链表

::: code-group

```java [双指针法]
/**
 * <p>此方法解决“相交链表”问题，旨在找出两个单链表相交的起始节点。</p>
 * <p>核心思想是使用“双指针法”，通过巧妙地将指针重定向到另一个链表的头部，
 * 使得两个指针最终走过相同的总距离，从而在相交点相遇。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化指针：</strong>
 *     <ul>
 *       <li>初始化两个指针 {@code pA = headA} 和 {@code pB = headB}。</li>
 *       <li>处理特殊情况：如果任何一个链表为空，它们不可能相交（除非两者都为空且被认为是相交在 null），
 *           但问题要求返回相交节点，所以如果有一个为 null，直接返回 null 即可。</li>
 *     </ul>
 *   </li>
 *   <li><strong>循环查找相交点：</strong>
 *     <ul>
 *       <li>进入一个 {@code while (pA != pB)} 循环。
 *           <ul>
 *             <li>如果 {@code pA} 不为 {@code null}，则 {@code pA = pA.next}。</li>
 *             <li>否则 (即 {@code pA} 到达链表 A 的末尾)，将 {@code pA} 重新指向链表 B 的头部 ({@code pA = headB})。</li>
 *             <li>如果 {@code pB} 不为 {@code null}，则 {@code pB = pB.next}。</li>
 *             <li>否则 (即 {@code pB} 到达链表 B 的末尾)，将 {@code pB} 重新指向链表 A 的头部 ({@code pB = headA})。</li>
 *           </ul>
 *       </li>
 *       <li>循环会一直进行，直到 {@code pA == pB}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当循环结束时，{@code pA} (或 {@code pB}) 就是相交节点。
 *           <ul>
 *             <li>如果链表相交，{@code pA} 和 {@code pB} 会在相交点相遇。</li>
 *             <li>如果链表不相交，它们最终都会同时变为 {@code null}，此时 {@code pA == pB} ({@code null == null})。</li>
 *           </ul>
 *           因此，直接返回 {@code pA} 即可。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>原理详解：</h3>
 * <p>假设链表 A 独有部分长度为 {@code a}，链表 B 独有部分长度为 {@code b}，相交部分长度为 {@code c}。</p>
 * <p>指针 {@code pA} 走的路径：{@code a -> c -> b -> c} (总长度 {@code a + c + b + c})</p>
 * <p>指针 {@code pB} 走的路径：{@code b -> c -> a -> c} (总长度 {@code b + c + a + c})</p>
 * <p>两个指针最终走过的总距离是相同的。当它们都走了 {@code a + b + c} 距离时：</p>
 * <ul>
 *   <li>如果链表相交，它们会在相交点（共同部分 {@code c} 的起点）相遇。</li>
 *   <li>如果链表不相交 (即 {@code c = 0})，它们最终会同时到达两个链表的末尾，即都变为 {@code null}，从而相遇。</li>
 * </ul>
 * <p>因此，无论是否相交，{@code pA} 和 {@code pB} 最终会在同一个节点 (相交节点或 {@code null}) 相遇。</p>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(M + N)}。
 *     <ul>
 *       <li>其中 M 和 N 分别是两个链表的长度。每个节点最多被访问两次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了常数个额外指针。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // 如果任何一个链表为空，则不可能相交，直接返回 null
    if (headA == null || headB == null) {
        return null;
    }

    ListNode pA = headA;
    ListNode pB = headB;

    // 循环直到 pA == pB
    // 两种情况会使 pA == pB 终止循环：
    // 1. 它们在相交节点相遇
    // 2. 它们都变为 null (表示不相交)
    while (pA != pB) {
        // 如果 pA 到达链表 A 的末尾，则将其指向链表 B 的头部
        // 否则，pA 继续向前移动
        pA = (pA == null) ? headB : pA.next;

        // 如果 pB 到达链表 B 的末尾，则将其指向链表 A 的头部
        // 否则，pB 继续向前移动
        pB = (pB == null) ? headA : pB.next;
    }

    // 此时 pA (或 pB) 就是相交节点，如果它们不相交，则 pA 此时为 null
    return pA;
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}
```

:::

## 反转链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 回文链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 环形链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 环形链表 II

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 合并两个有序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 两数相加

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 删除链表的倒数第 N 个结点

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 两两交换链表中的节点

::: code-group

```java []
/**
 * TODO
 */
```

:::

## K 个一组翻转链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 随机链表的复制

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 排序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 合并 K 个升序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## LRU 缓存

::: code-group

```java []
/**
 * TODO
 */
```

:::
