# 链表

## 相交链表

::: code-group

```java [双指针法]
/**
 * <p>此方法解决“相交链表”问题，旨在找出两个单链表相交的起始节点。</p>
 * <p>核心思想是使用“双指针法”，通过巧妙地将指针重定向到另一个链表的头部，
 * 使得两个指针最终走过相同的总距离，从而在相交点相遇。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化指针：</strong>
 *     <ul>
 *       <li>初始化两个指针 {@code pA = headA} 和 {@code pB = headB}。</li>
 *       <li>处理特殊情况：如果任何一个链表为空，它们不可能相交（除非两者都为空且被认为是相交在 null），
 *           但问题要求返回相交节点，所以如果有一个为 null，直接返回 null 即可。</li>
 *     </ul>
 *   </li>
 *   <li><strong>循环查找相交点：</strong>
 *     <ul>
 *       <li>进入一个 {@code while (pA != pB)} 循环。
 *           <ul>
 *             <li>如果 {@code pA} 不为 {@code null}，则 {@code pA = pA.next}。</li>
 *             <li>否则 (即 {@code pA} 到达链表 A 的末尾)，将 {@code pA} 重新指向链表 B 的头部 ({@code pA = headB})。</li>
 *             <li>如果 {@code pB} 不为 {@code null}，则 {@code pB = pB.next}。</li>
 *             <li>否则 (即 {@code pB} 到达链表 B 的末尾)，将 {@code pB} 重新指向链表 A 的头部 ({@code pB = headA})。</li>
 *           </ul>
 *       </li>
 *       <li>循环会一直进行，直到 {@code pA == pB}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当循环结束时，{@code pA} (或 {@code pB}) 就是相交节点。
 *           <ul>
 *             <li>如果链表相交，{@code pA} 和 {@code pB} 会在相交点相遇。</li>
 *             <li>如果链表不相交，它们最终都会同时变为 {@code null}，此时 {@code pA == pB} ({@code null == null})。</li>
 *           </ul>
 *           因此，直接返回 {@code pA} 即可。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>原理详解：</h3>
 * <p>假设链表 A 独有部分长度为 {@code a}，链表 B 独有部分长度为 {@code b}，相交部分长度为 {@code c}。</p>
 * <p>指针 {@code pA} 走的路径：{@code a -> c -> b -> c} (总长度 {@code a + c + b + c})</p>
 * <p>指针 {@code pB} 走的路径：{@code b -> c -> a -> c} (总长度 {@code b + c + a + c})</p>
 * <p>两个指针最终走过的总距离是相同的。当它们都走了 {@code a + b + c} 距离时：</p>
 * <ul>
 *   <li>如果链表相交，它们会在相交点（共同部分 {@code c} 的起点）相遇。</li>
 *   <li>如果链表不相交 (即 {@code c = 0})，它们最终会同时到达两个链表的末尾，即都变为 {@code null}，从而相遇。</li>
 * </ul>
 * <p>因此，无论是否相交，{@code pA} 和 {@code pB} 最终会在同一个节点 (相交节点或 {@code null}) 相遇。</p>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(M + N)}。
 *     <ul>
 *       <li>其中 M 和 N 分别是两个链表的长度。每个节点最多被访问两次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了常数个额外指针。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // 如果任何一个链表为空，则不可能相交，直接返回 null
    if (headA == null || headB == null) {
        return null;
    }

    ListNode pA = headA;
    ListNode pB = headB;

    // 循环直到 pA == pB
    // 两种情况会使 pA == pB 终止循环：
    // 1. 它们在相交节点相遇
    // 2. 它们都变为 null (表示不相交)
    while (pA != pB) {
        // 如果 pA 到达链表 A 的末尾，则将其指向链表 B 的头部
        // 否则，pA 继续向前移动
        pA = (pA == null) ? headB : pA.next;

        // 如果 pB 到达链表 B 的末尾，则将其指向链表 A 的头部
        // 否则，pB 继续向前移动
        pB = (pB == null) ? headA : pB.next;
    }

    // 此时 pA (或 pB) 就是相交节点，如果它们不相交，则 pA 此时为 null
    return pA;
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}
```

:::

## 反转链表

::: code-group

```java [迭代法]
/**
 * <p>此方法通过<strong>迭代法</strong>反转单链表。</p>
 * <p>核心思想是使用三个指针：
 *   <ul>
 *     <li>`prev`: 指向当前节点的前一个节点，初始化为 `null`。</li>
 *     <li>`curr`: 指向当前正在处理的节点，初始化为链表的头节点 `head`。</li>
 *     <li>`nextTemp`: 临时存储 `curr` 的下一个节点，以防在修改 `curr.next` 后丢失后续链表的引用。</li>
 *   </ul>
 * </p>
 * <p>在每次迭代中，我们做三件事：
 *   1. 保存 `curr` 的下一个节点。
 *   2. 将 `curr.next` 指向 `prev`，完成当前节点的反转。
 *   3. 更新 `prev` 和 `curr`，为下一次迭代做准备。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li>初始化 `prev = null` 和 `curr = head`。</li>
 *   <li>进入 `while (curr != null)` 循环：
 *     <ol type="a">
 *       <li>`ListNode nextTemp = curr.next;` (保存 `curr` 的下一个节点)</li>
 *       <li>`curr.next = prev;` (将 `curr` 的 `next` 指针指向 `prev`，完成反转)</li>
 *       <li>`prev = curr;` (更新 `prev` 为当前节点，为下一次迭代做准备)</li>
 *       <li>`curr = nextTemp;` (更新 `curr` 为下一个节点，继续遍历)</li>
 *     </ol>
 *   </li>
 *   <li>循环结束后，`curr` 会变为 `null`，而 `prev` 会指向原链表的最后一个节点，即反转后链表的头节点。</li>
 *   <li>返回 `prev`。</li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 N 是链表的节点数量。我们遍历链表一次，每个节点的操作都是常数时间。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了几个常数个额外指针变量。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        ListNode nextTemp = curr.next; // 1. 保存下一个节点
        curr.next = prev;              // 2. 当前节点指向前一个节点 (反转操作)
        prev = curr;                   // 3. prev 移动到当前节点
        curr = nextTemp;               // 4. curr 移动到下一个节点
    }

    return prev; // prev 最终会是反转后链表的头节点
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

```java [递归法]
/**
 * <p>此方法通过<strong>递归法</strong>反转单链表。</p>
 * <p>核心思想是：将问题分解为“反转子链表”和“将当前节点连接到反转后的子链表末尾”。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>基本情况 (Base Case)：</strong>
 *     <ul>
 *       <li>如果链表为空 (`head == null`) 或者链表只有一个节点 (`head.next == null`)，
 *           说明已经到达链表末尾或者链表无需反转，直接返回 `head`。</li>
 *     </ul>
 *   </li>
 *   <li><strong>递归调用：</strong>
 *     <ul>
 *       <li>递归地调用 `reverseListRecursive(head.next)` 来反转 `head` 之后的子链表。
 *           将返回的结果存储在 `newHead` 中。此时 `newHead` 是整个反转后链表的头节点。</li>
 *     </ul>
 *   </li>
 *   <li><strong>连接当前节点：</strong>
 *     <ul>
 *       <li>在 `reverseListRecursive(head.next)` 调用返回后：
 *         <ul>
 *           <li>`head.next` 指向的是原链表的第二个节点。在递归调用中，这个第二个节点已经成为了反转后子链表的尾节点。</li>
 *           <li>所以，我们让 `head.next.next = head;`，即将原链表的第二个节点的 `next` 指针指向 `head`。
 *               这样，`head` 就被连接到了反转后的子链表的末尾。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>断开旧连接：</strong>
 *     <ul>
 *       <li>将 `head.next = null;`。这是因为 `head` 节点现在是反转后链表的尾节点，它的 `next` 应该指向 `null`。</li>
 *     </ul>
 *   </li>
 *   <li><strong>返回：</strong>
 *     <ul>
 *       <li>返回 `newHead`。这个 `newHead` 是从最深层递归（原链表最后一个节点）返回的，它始终是整个反转后链表的头节点。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 N 是链表的节点数量。每个节点被访问一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>这是由于递归调用栈的深度，最坏情况下（链表没有环）会达到 N。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public ListNode reverseList(ListNode head) {
    // 基本情况：链表为空或只有一个节点
    if (head == null || head.next == null) {
        return head;
    }

    // 递归反转 head 之后的子链表
    ListNode newHead = reverseList(head.next);

    // 将当前节点 head 连接到反转后的子链表的末尾
    // 此时 head.next 是原链表的第二个节点，也是反转后子链表的尾节点
    head.next.next = head;

    // 当前节点 head 变为反转后链表的尾节点，其 next 指向 null
    head.next = null;

    // 返回反转后链表的头节点
    return newHead;
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

:::

## 回文链表

::: code-group

```java [使用 ArrayList]
/**
 * <p>此方法使用 {@code ArrayList} 来判断链表是否为回文链表。</p>
 * <p>核心思想是将链表的所有节点值复制到一个列表中，然后使用双指针法判断列表是否为回文。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理空链表：</strong>如果 `head` 为 `null`，空链表是回文，返回 `true`。</li>
 *   <li><strong>遍历链表并存储元素：</strong>
 *     <ul>
 *       <li>创建一个 {@code ArrayList<Integer> list}。</li>
 *       <li>使用一个 `current` 指针从 `head` 开始遍历链表。</li>
 *       <li>将每个节点的 `val` 添加到 `list` 中。</li>
 *     </ul>
 *   </li>
 *   <li><strong>双指针判断回文：</strong>
 *     <ul>
 *       <li>初始化两个指针 `left = 0` 和 `right = list.size() - 1`。</li>
 *       <li>进入 `while (left < right)` 循环：
 *         <ul>
 *           <li>如果 `list.get(left)` 不等于 `list.get(right)`，则不是回文，返回 `false`。</li>
 *           <li>否则，`left++`，`right--`。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>如果循环完成，说明是回文，返回 `true`。</li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>遍历链表并添加到列表需要 O(N) 时间。</li>
 *       <li>双指针判断列表回文需要 O(N) 时间。</li>
 *       <li>总计 O(N)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>{@code ArrayList} 需要存储链表中所有 N 个节点的值。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean isPalindrome(ListNode head) {
    if (head == null) {
        return true; // 空链表是回文
    }

    List<Integer> list = new ArrayList<>();
    ListNode current = head;
    while (current != null) {
        list.add(current.val);
        current = current.next;
    }

    int left = 0;
    int right = list.size() - 1;
    while (left < right) {
        if (!list.get(left).equals(list.get(right))) {
            return false;
        }
        left++;
        right--;
    }

    return true;
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

```java [使用 StringBuilder]
/**
 * <p>此方法使用 {@code StringBuilder} 来判断链表是否为回文链表。</p>
 * <p>核心思想是将链表的所有节点值连接成一个字符串，然后判断该字符串是否为回文。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理空链表：</strong>如果 `head` 为 `null`，空链表是回文，返回 `true`。</li>
 *   <li><strong>遍历链表并构建字符串：</strong>
 *     <ul>
 *       <li>创建一个 {@code StringBuilder sb}。</li>
 *       <li>使用一个 `current` 指针从 `head` 开始遍历链表。</li>
 *       <li>将每个节点的 `val` 追加到 `sb` 中。</li>
 *     </ul>
 *   </li>
 *   <li><strong>判断回文：</strong>
 *     <ul>
 *       <li>将 `sb` 转换为 {@code String originalString = sb.toString()}。</li>
 *       <li>创建 {@code StringBuilder} 的反转版本并转换为字符串：
 *           {@code String reversedString = sb.reverse().toString()}。</li>
 *       <li>比较 `originalString` 和 `reversedString` 是否相等。</li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>根据比较结果返回 `true` 或 `false`。</li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>遍历链表并构建字符串需要 O(N) 时间。</li>
 *       <li>字符串反转和比较需要 O(N) 时间。</li>
 *       <li>总计 O(N)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>{@code StringBuilder} 需要存储链表中所有 N 个节点值转换成的字符串。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean isPalindrome(ListNode head) {
    if (head == null) {
        return true; // 空链表是回文
    }

    StringBuilder sb = new StringBuilder();
    ListNode current = head;
    while (current != null) {
        sb.append(current.val);
        current = current.next;
    }

    String originalString = sb.toString();
    String reversedString = sb.reverse().toString(); // sb 已经被修改，直接反转即可

    return originalString.equals(reversedString);
}

// ListNode 类的定义 (与上面相同)
public static class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

```java [快慢指针 + 反转链表]
/**
 * <p>此方法使用<strong>快慢指针 + 反转链表</strong>的策略，以 O(1) 空间复杂度判断链表是否为回文链表。</p>
 * <p>核心思想是：
 * 1. 使用快慢指针找到链表的中间节点。
 * 2. 反转链表的后半部分。
 * 3. 比较链表的前半部分和反转后的后半部分。
 * 4. (可选) 恢复链表原始结构。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理特殊情况：</strong>如果 `head` 为 `null` 或只有一个节点，返回 `true`。</li>
 *   <li><strong>寻找中点：</strong>
 *     <ul>
 *       <li>使用 `slow` 和 `fast` 指针，都从 `head` 开始。</li>
 *       <li>`slow` 每次走一步，`fast` 每次走两步。</li>
 *       <li>当 `fast` 到达链表末尾时 (`fast == null` 或 `fast.next == null`)，`slow` 恰好在中点。
 *           具体来说，`slow` 停在前半部分的最后一个节点，或者中间偏左的那个节点。</li>
 *     </ul>
 *   </li>
 *   <li><strong>反转后半部分链表：</strong>
 *     <ul>
 *       <li>调用辅助函数 `reverseList(slow.next)` 来反转从 `slow.next` 开始的链表后半部分。</li>
 *       <li>将返回的头节点保存为 `secondHalfHead`。</li>
 *       <li>**注意：** 此时 `slow` 节点是前半部分的末尾。我们将其 `next` 设置为 `null` 以暂时断开两部分，方便比较。
 *           `slow.next = null;` (这个断开操作很重要，否则前半部分会继续指向反转前的后半部分，导致混乱)</li>
 *     </ul>
 *   </li>
 *   <li><strong>比较前半部分和反转后的后半部分：</strong>
 *     <ul>
 *       <li>初始化 `p1 = head` 和 `p2 = secondHalfHead`。</li>
 *       <li>同时遍历 `p1` 和 `p2`，比较它们的值。</li>
 *       <li>如果发现任何一对不相等，立即返回 `false`。</li>
 *     </ul>
 *   </li>
 *   <li><strong>（可选）恢复链表：</strong>
 *     <ul>
 *       <li>如果题目要求不修改原链表，需要在比较完成后将 `secondHalfHead` 再次反转，
 *           然后将 `slow.next` 重新指向恢复后的后半部分的头节点。</li>
 *       <li>`ListNode originalSecondHalfHead = reverseList(secondHalfHead);`</li>
 *       <li>`slow.next = originalSecondHalfHead;`</li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>如果所有比较都通过，返回 `true`。</li>
 * </ol>
 *
 * <h3>辅助函数 `reverseList(ListNode head)`：</h3>
 * <p>这是一个标准的迭代反转链表函数，在上面的 206 题中已经实现过。</p>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>寻找中点、反转后半部分、比较、恢复链表（如果需要）都各自需要 O(N/2) 的时间。</li>
 *       <li>总计 O(N)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了常数个额外指针。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true; // 空链表或单节点链表是回文
    }

    // 1. 使用快慢指针找到链表的中间节点
    ListNode slow = head;
    ListNode fast = head;
    // fast 走到末尾时，slow 走到中点。
    // 如果链表是奇数长，fast 停在最后一个节点，slow 停在正中间。
    // 如果链表是偶数长，fast 停在 null，slow 停在前半部分的最后一个节点。
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 此时 slow 指向前半部分的末尾节点 (或中间节点)

    // 2. 反转后半部分链表
    // 从 slow.next 开始反转，得到反转后的后半部分的头节点
    ListNode secondHalfHead = reverseList(slow.next);

    // 3. 将前半部分和反转后的后半部分进行比较
    ListNode p1 = head; // 前半部分头
    ListNode p2 = secondHalfHead; // 反转后的后半部分头

    boolean isPalindrome = true; // 默认是回文

    while (p1 != null && p2 != null) { // 遍历直到其中一个指针到达末尾
        if (p1.val != p2.val) {
            isPalindrome = false;
            break; // 不匹配，不是回文
        }
        p1 = p1.next;
        p2 = p2.next;
    }

    // 4. (可选) 恢复链表原始结构 - 如果不允许修改原链表
    // 先将反转的后半部分再次反转
    // 再将前半部分和恢复后的后半部分连接起来
    slow.next = reverseList(secondHalfHead);

    return isPalindrome;
}

/**
 * 辅助函数：反转链表 (迭代法)
 * 在 206 题中已实现
 */
private ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

// ListNode 类的定义 (与上面相同)
public static class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

:::

## 环形链表

::: code-group

```java [快慢指针]
/**
 * <p>此方法解决“环形链表”问题，旨在判断链表中是否存在环。</p>
 * <p>核心思想是使用<strong>快慢指针法</strong>（Floyd's Cycle-Finding Algorithm）。
 * 一个慢指针 `slow` 每次走一步，一个快指针 `fast` 每次走两步。
 * 如果链表有环，`fast` 指针最终会追上 `slow` 指针。
 * 如果链表无环，`fast` 指针会先到达链表的末尾（`null`）。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理特殊情况：</strong>
 *     <ul>
 *       <li>如果链表为空 (`head == null`) 或者链表只有一个节点 (`head.next == null`)，
 *           那么肯定不存在环，直接返回 `false`。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化指针：</strong>
 *     <ul>
 *       <li>初始化慢指针 `slow = head`。</li>
 *       <li>初始化快指针 `fast = head.next`。
 *           （这里让 `fast` 比 `slow` 先走一步，是为了确保它们不会在环的入口处就因为初始位置相同而立即判定为相遇，
 *           避免误判，因为在 `while` 循环中会先进行判断 `slow == fast`。）</li>
 *     </ul>
 *   </li>
 *   <li><strong>循环判断：</strong>
 *     <ul>
 *       <li>进入一个 `while (fast != null && fast.next != null)` 循环。
 *           这个条件确保 `fast` 在每次移动两步前都有足够的节点。</li>
 *       <li>在循环内部：
 *         <ul>
 *           <li>首先，检查 `slow == fast`。如果相等，则说明快慢指针相遇，链表存在环，返回 `true`。</li>
 *           <li>然后，移动指针：
 *             <ul>
 *               <li>`slow = slow.next` (慢指针向前移动一步)</li>
 *               <li>`fast = fast.next.next` (快指针向前移动两步)</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>如果循环结束（即 `fast` 或 `fast.next` 变为 `null`），
 *           说明快指针已到达链表末尾，链表中不存在环，返回 `false`。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>在没有环的情况下，快指针最多遍历 N 个节点，慢指针最多遍历 N/2 个节点。</li>
 *       <li>在有环的情况下，当快慢指针都进入环后，它们之间的距离会不断缩小，最终会在环内相遇。
 *           快指针最多走两圈就能追上慢指针。总的遍历次数仍是链表长度的常数倍。</li>
 *       <li>因此，总时间复杂度为 O(N)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了两个额外指针变量。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean hasCycle(ListNode head) {
    // 特殊情况：空链表或只有一个节点的链表不可能有环
    if (head == null || head.next == null) {
        return false;
    }

    ListNode slow = head;
    ListNode fast = head.next; // fast 比 slow 先走一步

    // 循环条件：fast 和 fast.next 都不能为 null
    // 确保 fast 每次都能移动两步
    while (fast != null && fast.next != null) {
        // 如果快慢指针相遇，则存在环
        if (slow == fast) {
            return true;
        }
        // 慢指针走一步
        slow = slow.next;
        // 快指针走两步
        fast = fast.next.next;
    }

    // 循环结束，fast 到达链表末尾，没有环
    return false;
}

// ListNode 类的定义 (通常是给定的)
public static class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}
```

:::

## 环形链表 II

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 合并两个有序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 两数相加

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 删除链表的倒数第 N 个结点

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 两两交换链表中的节点

::: code-group

```java []
/**
 * TODO
 */
```

:::

## K 个一组翻转链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 随机链表的复制

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 排序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 合并 K 个升序链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## LRU 缓存

::: code-group

```java []
/**
 * TODO
 */
```

:::
