# 二分查找

## 搜索插入位置

::: code-group

```java [二分查找]
/**
 * <p>此方法解决“搜索插入位置”问题，采用经典的<strong>二分查找（Binary Search）算法</strong>。</p>
 * <p>核心思想：题目要求时间复杂度为 O(log n)，且数组已排序，这明确指示我们要使用二分查找。
 * 这个问题的本质是找到第一个大于或等于 {@code target} 的元素的索引。如果 {@code target} 不存在，
 * 这个索引就是它的插入位置；如果 {@code target} 存在，这个索引就是它第一次出现的（或唯一存在的）位置。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化指针和答案变量：</strong>
 *     <ul>
 *       <li>{@code left = 0}：查找范围的左边界，初始为数组的第一个索引。</li>
 *       <li>{@code right = nums.length - 1}：查找范围的右边界，初始为数组的最后一个索引。</li>
 *       <li>{@code ans = nums.length}：用于记录最终的插入位置。初始化为 {@code nums.length}，
 *         这是为了处理 {@code target} 大于数组中所有元素的情况（即 {@code target} 应插入到数组末尾）。</li>
 *     </ul>
 *   </li>
 *   <li><strong>二分查找循环：</strong>
 *     <ul>
 *       <li>{@code while (left <= right)}：当左边界小于或等于右边界时，循环继续。
 *         这个条件保证了我们能够检查到 {@code left == right} 这种情况，甚至在 {@code left} 最终指向插入位置后 {@code left > right} 才结束。</li>
 *       <li>{@code mid = left + (right - left) / 2;}：计算中间索引。这种写法可以避免 {@code left + right} 溢出。</li>
 *       <li><strong>比较 {@code nums[mid]} 与 {@code target}：</strong>
 *         <ul>
 *           <li>{@code if (nums[mid] >= target)}：
 *             <ul>
 *               <li>这表示 {@code nums[mid]} <strong>可能</strong>是 {@code target} 的插入位置，或者 {@code target} 在 {@code mid} 之前（包括 {@code mid} 本身）。
 *                 我们找到了一个候选值，所以更新 {@code ans = mid}。</li>
 *               <li>由于我们寻找的是“第一个”大于或等于 {@code target} 的位置，所以我们需要尝试在左半部分继续查找更小的索引。
 *                 {@code right = mid - 1;}</li>
 *             </ul>
 *           </li>
 *           <li>{@code else (nums[mid] < target)}：
 *             <ul>
 *               <li>这表示 {@code nums[mid]} 太小了，{@code target} 肯定在 {@code mid} 之后。
 *                 所以，在右半部分查找。</li>
 *               <li>{@code left = mid + 1;}</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>循环结束后，{@code ans} 变量将存储 {@code target} 的正确插入位置。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(log n)}。
 *     <ul>
 *       <li>二分查找在每次迭代中将搜索空间减半，因此对数时间复杂度。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了几个常数级别的变量，没有额外的数据结构。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int searchInsert(int[] nums, int target) {
    int n = nums.length;
    int left = 0;
    int right = n - 1;
    // 目标值不存在时，返回它将会被按顺序插入的位置
    // 这个变量 ans 用来记录可能插入的位置，初始值设为 n
    // 应对 target 大于所有元素的情况
    int ans = n;
    while (left <= right) {
        int mid = left + (right - left) / 2; // 防止 left + right 溢出
        if (nums[mid] >= target) {
            // 当前 mid 位置的元素大于或等于 target
            // 说明 mid 可能是插入位置，或者 target 应该在 mid 的左边（包括 mid 本身）
            ans = mid; // 记录当前 mid 为一个可能的答案
            right = mid - 1; // 继续向左半部分查找更小的索引
        } else {
            // 当前 mid 位置的元素小于 target
            // 说明 target 肯定在 mid 的右边
            left = mid + 1; // 在右半部分查找
        }
    }
    return ans; // 循环结束后，ans 就是目标值的插入位置
}
```

:::

## 搜索二维矩阵

::: code-group

```java [两次二分查找]
/**
 * <p>此方法解决“搜索二维矩阵”问题，采用<strong>两次二分查找</strong>的策略。</p>
 * <p>核心思想：由于矩阵具备两条关键属性：
 * <ol>
 *     <li>每行从左到右递增。</li>
 *     <li>每行的第一个元素大于前一行的最后一个元素。</li>
 * </ol>
 * <p>
 * 这允许我们首先通过二分查找确定 {@code target} 可能存在于哪一行，
 * 然后在该行内再进行一次二分查找来确定 {@code target} 是否存在。
 * </p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理边界情况：</strong>
 *     <ul>
 *       <li>如果 {@code matrix} 为空或尺寸为 {@code 0}，直接返回 {@code false}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>第一次二分查找 (定位行)：</strong>
 *     <ul>
 *       <li>目标：找到 {@code target} 可能所在的行。我们寻找的是第一个行首元素小于等于 {@code target} 的行。</li>
 *       <li>{@code m = matrix.length} (行数), {@code n = matrix[0].length} (列数)。</li>
 *       <li>{@code top = 0}, {@code bottom = m - 1}。</li>
 *       <li>{@code candidateRow = -1}：用于记录最有可能的行索引。</li>
 *       <li>{@code while (top <= bottom)}：
 *         <ul>
 *           <li>{@code midRow = top + (bottom - top) / 2}。</li>
 *           <li>{@code if (matrix[midRow][0] == target)}：如果找到，直接返回 {@code true}。</li>
 *           <li>{@code else if (matrix[midRow][0] < target)}：{@code target} 可能在 {@code midRow} 或其下方的行。
 *             <ul>
 *               <li>{@code candidateRow = midRow;}：记录当前行作为可能的候选行。</li>
 *               <li>{@code top = midRow + 1;}：继续向下方查找。</li>
 *             </ul>
 *           </li>
 *           <li>{@code else (matrix[midRow][0] > target)}：{@code target} 肯定在 {@code midRow} 的上方。
 *             <ul>
 *               <li>{@code bottom = midRow - 1;}：向上方查找。</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *       <li><strong>检查 {@code candidateRow} 的有效性：</strong>
 *         <ul>
 *           <li>{@code if (candidateRow == -1)}：如果没有找到任何行首元素小于 {@code target} 的行，说明 {@code target} 比所有行的首元素都小，不可能存在。返回 {@code false}。</li>
 *           <li>如果 {@code target} 比 {@code candidateRow} 这一行的最后一个元素都大 ({@code matrix[candidateRow][n-1] < target})，也说明 {@code target} 不可能存在于该行。返回 {@code false}。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>第二次二分查找 (在确定行内定位元素)：</strong>
 *     <ul>
 *       <li>确定要在 {@code matrix[candidateRow]} 这一行中搜索。</li>
 *       <li>{@code rowArray = matrix[candidateRow]}。</li>
 *       <li>{@code left = 0}, {@code right = n - 1}。</li>
 *       <li>{@code while (left <= right)}：
 *         <ul>
 *           <li>{@code mid = left + (right - left) / 2}。</li>
 *           <li>{@code if (rowArray[mid] == target)}：找到，返回 {@code true}。</li>
 *           <li>{@code else if (rowArray[mid] < target)}：向右查找 {@code left = mid + 1}。</li>
 *           <li>{@code else (rowArray[mid] > target)}：向左查找 {@code right = mid - 1}。</li>
 *         </ul>
 *       </li>
 *       <li>如果循环结束仍未找到，返回 {@code false}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(log m + log n)}。
 *     <ul>
 *       <li>第一次二分查找（定位行）需要 {@code O(log m)} 的时间。</li>
 *       <li>第二次二分查找（定位列）需要 {@code O(log n)} 的时间。</li>
 *       <li>总时间复杂度是两者的和。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了几个常数级别的变量。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int m = matrix.length;    // 行数
    int n = matrix[0].length; // 列数
    // --- 第一次二分查找：定位 target 可能所在的行 ---
    int top = 0;
    int bottom = m - 1;
    int candidateRow = -1; // 记录最有可能的行索引
    while (top <= bottom) {
        int midRow = top + (bottom - top) / 2;
        if (matrix[midRow][0] == target) {
            return true; // 目标值就是某行第一个元素
        } else if (matrix[midRow][0] < target) {
            // 当前行首元素小于 target，target 可能在当前行或下方的行
            candidateRow = midRow; // 记录当前行作为可能的候选行
            top = midRow + 1;      // 继续向下方查找
        } else {
            // 当前行首元素大于 target，target 肯定在当前行的上方
            bottom = midRow - 1;   // 向上方查找
        }
    }
    // 检查 candidateRow 的有效性
    if (candidateRow == -1) {
        // 如果 candidateRow 仍为 -1，说明 target 比所有行的首元素都小，不可能存在
        return false;
    }
    // 如果 target 比我们定位到的这一行的最后一个元素都大，也不可能存在于该行
    if (matrix[candidateRow][n - 1] < target) {
        return false;
    }
    // --- 第二次二分查找：在确定的行（candidateRow）内查找 target ---
    int[] rowArray = matrix[candidateRow]; // 获取目标行
    int left = 0;
    int right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (rowArray[mid] == target) {
            return true; // 找到目标值
        } else if (rowArray[mid] < target) {
            left = mid + 1; // 向右查找
        } else {
            right = mid - 1; // 向左查找
        }
    }
    return false; // 如果都没有找到，返回 false
}
```

```java [一次模拟二分查找]
/**
 * <p>此方法解决“搜索二维矩阵”问题，采用<strong>一次模拟二分查找</strong>的更高效策略。</p>
 * <p>核心思想：利用矩阵的两条属性（每行递增，以及每行首元素大于前一行尾元素），
 * 我们可以将整个 {@code m x n} 的二维矩阵逻辑上视为一个长度为 {@code m * n} 的一维有序数组。
 * 然后，我们在这个虚拟的一维数组上执行标准的二分查找。
 * 关键在于，需要将一维数组的索引映射回二维矩阵的 {@code (row, col)} 坐标。</p>
 *
 * <h3>索引映射关系：</h3>
 * <p>对于一个 {@code m x n} 的矩阵，如果将其展平为一维数组，其索引 {@code k} (从 {@code 0} 到 {@code m*n - 1}) 与二维坐标 {@code (row, col)} 的关系为：</p>
 * <ul>
 *   <li>{@code row = k / n} (整数除法，{@code n} 是矩阵的列数)</li>
 *   <li>{@code col = k % n} (取模运算，{@code n} 是矩阵的列数)</li>
 * </ul>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>处理边界情况：</strong>
 *     <ul>
 *       <li>如果 {@code matrix} 为空或尺寸为 {@code 0}，直接返回 {@code false}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化二分查找范围：</strong>
 *     <ul>
 *       <li>{@code m = matrix.length} (行数)</li>
 *       <li>{@code n = matrix[0].length} (列数)</li>
 *       <li>{@code left = 0}：虚拟一维数组的起始索引。</li>
 *       <li>{@code right = m * n - 1}：虚拟一维数组的结束索引。</li>
 *     </ul>
 *   </li>
 *   <li><strong>二分查找循环：</strong> {@code while (left <= right)}
 *     <ul>
 *       <li>{@code mid = left + (right - left) / 2;}：计算虚拟一维数组的中间索引。</li>
 *       <li><strong>将 {@code mid} 映射到二维坐标：</strong>
 *         <ul>
 *           <li>{@code midRow = mid / n;}</li>
 *           <li>{@code midCol = mid % n;}</li>
 *         </ul>
 *       </li>
 *       <li><strong>比较 {@code matrix[midRow][midCol]} 与 {@code target}：</strong>
 *         <ul>
 *           <li>{@code if (matrix[midRow][midCol] == target)}：找到目标值，返回 {@code true}。</li>
 *           <li>{@code else if (matrix[midRow][midCol] < target)}：中间元素太小，{@code target} 肯定在 {@code mid} 的右侧。
 *             <ul>
 *               <li>{@code left = mid + 1;}</li>
 *             </ul>
 *           </li>
 *           <li>{@code else (matrix[midRow][midCol] > target)}：中间元素太大，{@code target} 肯定在 {@code mid} 的左侧。
 *             <ul>
 *               <li>{@code right = mid - 1;}</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>如果循环结束仍未找到目标值，返回 {@code false}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(log(m * n))}。
 *     <ul>
 *       <li>二分查找的搜索空间是 {@code m * n} 个元素，因此时间复杂度是 {@code O(log(m*n))}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>只使用了几个常数级别的变量。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }

    int m = matrix.length;    // 行数
    int n = matrix[0].length; // 列数

    // 将二维矩阵看作一个展平的一维有序数组进行二分查找
    int left = 0;              // 虚拟一维数组的起始索引
    int right = m * n - 1;     // 虚拟一维数组的结束索引

    while (left <= right) {
        int mid = left + (right - left) / 2; // 计算虚拟一维数组的中间索引

        // 将一维索引 mid 映射回二维矩阵的 (row, col) 坐标
        int midRow = mid / n; // 行索引
        int midCol = mid % n; // 列索引

        if (matrix[midRow][midCol] == target) {
            return true; // 找到目标值
        } else if (matrix[midRow][midCol] < target) {
            // 中间元素小于 target，说明 target 在 mid 的右侧
            left = mid + 1;
        } else {
            // 中间元素大于 target，说明 target 在 mid 的左侧
            right = mid - 1;
        }
    }

    return false; // 循环结束仍未找到目标值
}
```

::

## 在排序数组中查找元素的第一个和最后一个位置

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 搜索旋转排序数组

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 寻找旋转排序数组中的最小值

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 寻找两个正序数组的中位数

::: code-group

```java []
/**
 * TODO
 */
```

:::
