# 二叉树

## 二叉树的中序遍历

::: code-group

```java [递归]
/**
 * <p>此方法解决“二叉树的中序遍历”问题，采用<strong>递归 (Recursion)</strong> 的方式。</p>
 * <p>这是最自然、最简洁的实现方式，直接体现了中序遍历“左 -> 根 -> 右”的定义。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>主函数 {@code inorderTraversal(root)}：</strong>
 *     <ul>
 *       <li>创建一个空的 {@code List<Integer>} 来存储遍历结果。</li>
 *       <li>调用辅助函数 {@code inorder(root, resultList)} 开始递归遍历。</li>
 *       <li>返回 {@code resultList}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>辅助函数 {@code inorder(node, resultList)}：</strong>
 *     <ul>
 *       <li><strong>基本情况 (Base Case)：</strong> 如果当前节点 {@code node} 为 {@code null}，则说明到达叶子节点以下，直接返回，停止进一步的递归。</li>
 *       <li><strong>递归左子树：</strong> 调用 {@code inorder(node.left, resultList)}。这会确保左子树中的所有节点都按照中序顺序被访问并添加到 {@code resultList} 中。</li>
 *       <li><strong>访问根节点：</strong> 将当前节点 {@code node.val} 添加到 {@code resultList} 中。这是中序遍历的核心步骤。</li>
 *       <li><strong>递归右子树：</strong> 调用 {@code inorder(node.right, resultList)}。这会确保右子树中的所有节点都按照中序顺序被访问并添加到 {@code resultList} 中。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次，并被添加到结果列表中一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树，所有节点都在一条线上），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> resultList = new ArrayList<>();
    inorder(root, resultList);
    return resultList;
}

/**
 * 递归辅助函数实现中序遍历
 *
 * @param node       当前访问的节点
 * @param resultList 存储遍历结果的列表
 */
private void inorder(TreeNode node, List<Integer> resultList) {
    // 基本情况：如果节点为空，则返回
    if (node == null) {
        return;
    }
    // 1. 递归遍历左子树
    inorder(node.left, resultList);
    // 2. 访问当前根节点
    resultList.add(node.val);
    // 3. 递归遍历右子树
    inorder(node.right, resultList);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代]
/**
 * <p>此方法解决“二叉树的中序遍历”问题，采用<strong>迭代 (Iteration)</strong> 的方式。</p>
 * <p>通过手动维护一个栈，模拟了递归调用的过程，从而避免了递归深度可能导致的栈溢出问题。</p>
 * <p>中序遍历的迭代实现核心是：先将所有左子节点压栈，直到没有左子节点，然后弹出栈顶元素访问，再转向处理右子树。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个 {@code List<Integer> resultList} 用于存储遍历结果。</li>
 *       <li>创建一个 {@code Stack<TreeNode> stack}。</li>
 *       <li>初始化一个 {@code curr} 指针指向根节点 {@code root} ({@code TreeNode curr = root;})。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环：</strong> {@code while (curr != null || !stack.isEmpty())}
 *     <ul>
 *       <li><strong>a. 向左子树深入 (压栈)：</strong>
 *         <ul>
 *           <li>{@code while (curr != null)}：</li>
 *           <li>将当前节点 {@code curr} 压入栈中：{@code stack.push(curr);}。</li>
 *           <li>将 {@code curr} 移动到其左子节点：{@code curr = curr.left;}。</li>
 *           <li>这个 {@code while} 循环会一直执行，直到 {@code curr} 变为 {@code null} (即到达了当前路径的最左边)。</li>
 *         </ul>
 *       </li>
 *       <li><strong>b. 访问节点并转向右子树 (弹栈)：</strong>
 *         <ul>
 *           <li>当上一个 {@code while} 循环结束后，{@code curr} 为 {@code null}，这意味着已经到达了某个子树的最左端。此时，栈顶元素就是下一个需要被访问的节点。</li>
 *           <li>从栈中弹出一个节点：{@code curr = stack.pop();}。</li>
 *           <li>将该节点的值添加到结果列表：{@code resultList.add(curr.val);} (这是中序遍历访问节点的时机)。</li>
 *           <li>将 {@code curr} 移动到其右子节点：{@code curr = curr.right;}。</li>
 *           <li>然后回到外层 {@code while} 循环的开始，继续处理这个右子树（可能会再次进入向左深入的阶段）。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当主循环结束时 (即 {@code curr} 为 {@code null} 且栈为空)，所有节点都已访问，返回 {@code resultList}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被压入栈一次，并弹出一次，并添加到结果列表中一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是栈在最坏情况下的最大深度（存储的节点数量）。</li>
 *       <li>在最坏情况（例如，倾斜树），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> resultList = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>(); // 或者使用 Deque<TreeNode> stack = new LinkedList<>();
    TreeNode curr = root; // 当前遍历的节点
    // 循环条件：当前节点不为空或者栈不为空，说明还有节点待处理
    while (curr != null || !stack.isEmpty()) {
        // 一直向左遍历并压栈，直到当前节点为空
        while (curr != null) {
            stack.push(curr); // 将当前节点压入栈中
            curr = curr.left;  // 移动到左子节点
        }
        // 此时 curr 为 null，说明已到达最左边，从栈中弹出一个节点
        curr = stack.pop();
        resultList.add(curr.val); // 访问节点（中序遍历的核心）
        // 转向处理右子树
        curr = curr.right;
    }
    return resultList;
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 二叉树的最大深度

::: code-group

```java [递归（深度优先）]
/**
 * <p>此方法解决“二叉树的最大深度”问题，采用<strong>递归 (Recursion)</strong> 的方式，
 * 本质上是深度优先搜索 (DFS)。</p>
 * <p>其核心思想是利用二叉树的递归定义：一个节点的深度等于其左右子树深度的最大值加 1。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>函数定义 {@code maxDepth(root)}：</strong>
 *     <ul>
 *       <li>这是一个递归函数，它接收一个 {@code TreeNode} (当前节点) 作为参数，并返回以该节点为根的子树的最大深度。</li>
 *     </ul>
 *   </li>
 *   <li><strong>基本情况 (Base Case / 递归终止条件)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 为 {@code null}：
 *         <ul>
 *           <li>这意味着我们已经到达了叶子节点的下方，或者处理的是一个空树。一个空节点的深度为 {@code 0}。</li>
 *           <li>{@code if (root == null) { return 0; }}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>递归关系 (Recursive Step)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 不为 {@code null}：
 *         <ul>
 *           <li>递归计算其左子树的最大深度：{@code int leftDepth = maxDepth(root.left);}</li>
 *           <li>递归计算其右子树的最大深度：{@code int rightDepth = maxDepth(root.right);}</li>
 *           <li>当前节点的深度等于 {@code 1} (当前节点自身) 加上其左右子树最大深度中的较大者。
 *             {@code return 1 + Math.max(leftDepth, rightDepth);}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次 (作为递归函数的参数)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树，所有节点都在一条线上），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log_2 N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int maxDepth(TreeNode root) {
    // 基本情况：如果当前节点为空，则其深度为 0
    if (root == null) {
        return 0;
    }
    // 递归计算左子树的最大深度
    int leftDepth = maxDepth(root.left);
    // 递归计算右子树的最大深度
    int rightDepth = maxDepth(root.right);
    // 当前节点的深度是 1 (自身) 加上左右子树深度中的较大者
    return 1 + Math.max(leftDepth, rightDepth);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代（广度优先）]
/**
 * <p>此方法解决“二叉树的最大深度”问题，采用<strong>迭代 (Iteration)</strong> 的方式，
 * 本质上是广度优先搜索 (BFS) 或层序遍历。</p>
 * <p>核心思想：通过逐层遍历二叉树，每遍历完一层，深度计数器加一，直到所有节点遍历完毕。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>特殊情况：</strong>
 *     <ul>
 *       <li>如果 {@code root} 为 {@code null}，意味着是空树，直接返回 {@code 0}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个队列 {@code Queue<TreeNode> queue} (推荐使用 {@code LinkedList} 或 {@code ArrayDeque}) 用于存储待访问的节点。</li>
 *       <li>将根节点 {@code root} 加入队列：{@code queue.offer(root);}。</li>
 *       <li>初始化深度计数器 {@code depth = 0;}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环 (层序遍历)：</strong> {@code while (!queue.isEmpty())}
 *     <ul>
 *       <li>每进入一层（即内层 {@code for} 循环开始前），深度 {@code depth} 加一：{@code depth++;}。</li>
 *       <li>获取当前队列中节点的数量 {@code int levelSize = queue.size();}。这个变量很重要，它代表当前层有多少个节点，我们需要在这一轮循环中全部处理掉它们，然后才能进入下一层。</li>
 *       <li><strong>遍历当前层的所有节点：</strong> {@code for (int i = 0; i < levelSize; i++)}
 *         <ul>
 *           <li>从队列中取出一个节点：{@code TreeNode node = queue.poll();}。</li>
 *           <li>如果该节点有左子节点，将其加入队列，准备在下一层处理：{@code if (node.left != null) { queue.offer(node.left); }}。</li>
 *           <li>如果该节点有右子节点，将其加入队列，准备在下一层处理：{@code if (node.right != null) { queue.offer(node.right); }}。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当主循环结束时 (队列为空)，所有节点都已访问，{@code depth} 存储的就是最大深度，返回 {@code depth}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被加入队列一次，并从队列中取出一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(W)}。
 *     <ul>
 *       <li>其中 {@code W} 是二叉树的最大宽度（即在同一层中节点最多的数量）。这是队列在最坏情况下需要存储的节点数量。</li>
 *       <li>在最坏情况（例如，完全平衡树的最后一层，或者满二叉树的倒数第二层），{@code W} 可以达到 {@code N/2}，所以空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，倾斜树），{@code W = 1}，空间复杂度为 {@code O(1)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int maxDepth(TreeNode root) {
    // 基本情况：如果根节点为空，则深度为 0
    if (root == null) {
        return 0;
    }
    // 使用队列进行广度优先搜索 (BFS)
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root); // 将根节点加入队列
    int depth = 0; // 初始化深度
    // 当队列不为空时，继续层序遍历
    while (!queue.isEmpty()) {
        depth++; // 每一层开始时，深度加 1
        int levelSize = queue.size(); // 获取当前层的节点数量
        // 遍历当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll(); // 取出当前层的节点
            // 将当前节点的左右子节点（如果存在）加入队列，为下一层做准备
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
    return depth; // 返回最大深度
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 翻转二叉树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 对称二叉树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的直径

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的层序遍历

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 将有序数组转换为二叉搜索树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 验证二叉搜索树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉搜索树中第 K 小的元素

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的右视图

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树展开为链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 从前序与中序遍历序列构造二叉树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 路径总和 III

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的最近公共祖先

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树中的最大路径和

::: code-group

```java []
/**
 * TODO
 */
```

:::
