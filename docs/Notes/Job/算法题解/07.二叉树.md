# 二叉树

## 二叉树的中序遍历

::: code-group

```java [递归]
/**
 * <p>此方法解决“二叉树的中序遍历”问题，采用<strong>递归 (Recursion)</strong> 的方式。</p>
 * <p>这是最自然、最简洁的实现方式，直接体现了中序遍历“左 -> 根 -> 右”的定义。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>主函数 {@code inorderTraversal(root)}：</strong>
 *     <ul>
 *       <li>创建一个空的 {@code List<Integer>} 来存储遍历结果。</li>
 *       <li>调用辅助函数 {@code inorder(root, resultList)} 开始递归遍历。</li>
 *       <li>返回 {@code resultList}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>辅助函数 {@code inorder(node, resultList)}：</strong>
 *     <ul>
 *       <li><strong>基本情况 (Base Case)：</strong> 如果当前节点 {@code node} 为 {@code null}，则说明到达叶子节点以下，直接返回，停止进一步的递归。</li>
 *       <li><strong>递归左子树：</strong> 调用 {@code inorder(node.left, resultList)}。这会确保左子树中的所有节点都按照中序顺序被访问并添加到 {@code resultList} 中。</li>
 *       <li><strong>访问根节点：</strong> 将当前节点 {@code node.val} 添加到 {@code resultList} 中。这是中序遍历的核心步骤。</li>
 *       <li><strong>递归右子树：</strong> 调用 {@code inorder(node.right, resultList)}。这会确保右子树中的所有节点都按照中序顺序被访问并添加到 {@code resultList} 中。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次，并被添加到结果列表中一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树，所有节点都在一条线上），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> resultList = new ArrayList<>();
    inorder(root, resultList);
    return resultList;
}

/**
 * 递归辅助函数实现中序遍历
 *
 * @param node       当前访问的节点
 * @param resultList 存储遍历结果的列表
 */
private void inorder(TreeNode node, List<Integer> resultList) {
    // 基本情况：如果节点为空，则返回
    if (node == null) {
        return;
    }
    // 1. 递归遍历左子树
    inorder(node.left, resultList);
    // 2. 访问当前根节点
    resultList.add(node.val);
    // 3. 递归遍历右子树
    inorder(node.right, resultList);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代]
/**
 * <p>此方法解决“二叉树的中序遍历”问题，采用<strong>迭代 (Iteration)</strong> 的方式。</p>
 * <p>通过手动维护一个栈，模拟了递归调用的过程，从而避免了递归深度可能导致的栈溢出问题。</p>
 * <p>中序遍历的迭代实现核心是：先将所有左子节点压栈，直到没有左子节点，然后弹出栈顶元素访问，再转向处理右子树。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个 {@code List<Integer> resultList} 用于存储遍历结果。</li>
 *       <li>创建一个 {@code Stack<TreeNode> stack}。</li>
 *       <li>初始化一个 {@code curr} 指针指向根节点 {@code root} ({@code TreeNode curr = root;})。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环：</strong> {@code while (curr != null || !stack.isEmpty())}
 *     <ul>
 *       <li><strong>a. 向左子树深入 (压栈)：</strong>
 *         <ul>
 *           <li>{@code while (curr != null)}：</li>
 *           <li>将当前节点 {@code curr} 压入栈中：{@code stack.push(curr);}。</li>
 *           <li>将 {@code curr} 移动到其左子节点：{@code curr = curr.left;}。</li>
 *           <li>这个 {@code while} 循环会一直执行，直到 {@code curr} 变为 {@code null} (即到达了当前路径的最左边)。</li>
 *         </ul>
 *       </li>
 *       <li><strong>b. 访问节点并转向右子树 (弹栈)：</strong>
 *         <ul>
 *           <li>当上一个 {@code while} 循环结束后，{@code curr} 为 {@code null}，这意味着已经到达了某个子树的最左端。此时，栈顶元素就是下一个需要被访问的节点。</li>
 *           <li>从栈中弹出一个节点：{@code curr = stack.pop();}。</li>
 *           <li>将该节点的值添加到结果列表：{@code resultList.add(curr.val);} (这是中序遍历访问节点的时机)。</li>
 *           <li>将 {@code curr} 移动到其右子节点：{@code curr = curr.right;}。</li>
 *           <li>然后回到外层 {@code while} 循环的开始，继续处理这个右子树（可能会再次进入向左深入的阶段）。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当主循环结束时 (即 {@code curr} 为 {@code null} 且栈为空)，所有节点都已访问，返回 {@code resultList}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被压入栈一次，并弹出一次，并添加到结果列表中一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是栈在最坏情况下的最大深度（存储的节点数量）。</li>
 *       <li>在最坏情况（例如，倾斜树），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> resultList = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>(); // 或者使用 Deque<TreeNode> stack = new LinkedList<>();
    TreeNode curr = root; // 当前遍历的节点
    // 循环条件：当前节点不为空或者栈不为空，说明还有节点待处理
    while (curr != null || !stack.isEmpty()) {
        // 一直向左遍历并压栈，直到当前节点为空
        while (curr != null) {
            stack.push(curr); // 将当前节点压入栈中
            curr = curr.left;  // 移动到左子节点
        }
        // 此时 curr 为 null，说明已到达最左边，从栈中弹出一个节点
        curr = stack.pop();
        resultList.add(curr.val); // 访问节点（中序遍历的核心）
        // 转向处理右子树
        curr = curr.right;
    }
    return resultList;
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 二叉树的最大深度

::: code-group

```java [递归（深度优先）]
/**
 * <p>此方法解决“二叉树的最大深度”问题，采用<strong>递归 (Recursion)</strong> 的方式，
 * 本质上是深度优先搜索 (DFS)。</p>
 * <p>其核心思想是利用二叉树的递归定义：一个节点的深度等于其左右子树深度的最大值加 1。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>函数定义 {@code maxDepth(root)}：</strong>
 *     <ul>
 *       <li>这是一个递归函数，它接收一个 {@code TreeNode} (当前节点) 作为参数，并返回以该节点为根的子树的最大深度。</li>
 *     </ul>
 *   </li>
 *   <li><strong>基本情况 (Base Case / 递归终止条件)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 为 {@code null}：
 *         <ul>
 *           <li>这意味着我们已经到达了叶子节点的下方，或者处理的是一个空树。一个空节点的深度为 {@code 0}。</li>
 *           <li>{@code if (root == null) { return 0; }}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>递归关系 (Recursive Step)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 不为 {@code null}：
 *         <ul>
 *           <li>递归计算其左子树的最大深度：{@code int leftDepth = maxDepth(root.left);}</li>
 *           <li>递归计算其右子树的最大深度：{@code int rightDepth = maxDepth(root.right);}</li>
 *           <li>当前节点的深度等于 {@code 1} (当前节点自身) 加上其左右子树最大深度中的较大者。
 *             {@code return 1 + Math.max(leftDepth, rightDepth);}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次 (作为递归函数的参数)。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树，所有节点都在一条线上），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log_2 N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int maxDepth(TreeNode root) {
    // 基本情况：如果当前节点为空，则其深度为 0
    if (root == null) {
        return 0;
    }
    // 递归计算左子树的最大深度
    int leftDepth = maxDepth(root.left);
    // 递归计算右子树的最大深度
    int rightDepth = maxDepth(root.right);
    // 当前节点的深度是 1 (自身) 加上左右子树深度中的较大者
    return 1 + Math.max(leftDepth, rightDepth);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代（广度优先）]
/**
 * <p>此方法解决“二叉树的最大深度”问题，采用<strong>迭代 (Iteration)</strong> 的方式，
 * 本质上是广度优先搜索 (BFS) 或层序遍历。</p>
 * <p>核心思想：通过逐层遍历二叉树，每遍历完一层，深度计数器加一，直到所有节点遍历完毕。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>特殊情况：</strong>
 *     <ul>
 *       <li>如果 {@code root} 为 {@code null}，意味着是空树，直接返回 {@code 0}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个队列 {@code Queue<TreeNode> queue} (推荐使用 {@code LinkedList} 或 {@code ArrayDeque}) 用于存储待访问的节点。</li>
 *       <li>将根节点 {@code root} 加入队列：{@code queue.offer(root);}。</li>
 *       <li>初始化深度计数器 {@code depth = 0;}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环 (层序遍历)：</strong> {@code while (!queue.isEmpty())}
 *     <ul>
 *       <li>每进入一层（即内层 {@code for} 循环开始前），深度 {@code depth} 加一：{@code depth++;}。</li>
 *       <li>获取当前队列中节点的数量 {@code int levelSize = queue.size();}。这个变量很重要，它代表当前层有多少个节点，我们需要在这一轮循环中全部处理掉它们，然后才能进入下一层。</li>
 *       <li><strong>遍历当前层的所有节点：</strong> {@code for (int i = 0; i < levelSize; i++)}
 *         <ul>
 *           <li>从队列中取出一个节点：{@code TreeNode node = queue.poll();}。</li>
 *           <li>如果该节点有左子节点，将其加入队列，准备在下一层处理：{@code if (node.left != null) { queue.offer(node.left); }}。</li>
 *           <li>如果该节点有右子节点，将其加入队列，准备在下一层处理：{@code if (node.right != null) { queue.offer(node.right); }}。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当主循环结束时 (队列为空)，所有节点都已访问，{@code depth} 存储的就是最大深度，返回 {@code depth}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被加入队列一次，并从队列中取出一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(W)}。
 *     <ul>
 *       <li>其中 {@code W} 是二叉树的最大宽度（即在同一层中节点最多的数量）。这是队列在最坏情况下需要存储的节点数量。</li>
 *       <li>在最坏情况（例如，完全平衡树的最后一层，或者满二叉树的倒数第二层），{@code W} 可以达到 {@code N/2}，所以空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，倾斜树），{@code W = 1}，空间复杂度为 {@code O(1)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int maxDepth(TreeNode root) {
    // 基本情况：如果根节点为空，则深度为 0
    if (root == null) {
        return 0;
    }
    // 使用队列进行广度优先搜索 (BFS)
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root); // 将根节点加入队列
    int depth = 0; // 初始化深度
    // 当队列不为空时，继续层序遍历
    while (!queue.isEmpty()) {
        depth++; // 每一层开始时，深度加 1
        int levelSize = queue.size(); // 获取当前层的节点数量
        // 遍历当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll(); // 取出当前层的节点
            // 将当前节点的左右子节点（如果存在）加入队列，为下一层做准备
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
    return depth; // 返回最大深度
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 翻转二叉树

::: code-group

```java [递归 + 深度优先]
/**
 * <p>此方法解决“翻转二叉树”问题，采用<strong>递归 (Recursion)</strong> 的方式，
 * 本质上是深度优先搜索 (DFS)。</p>
 * <p>核心思想：对于每个节点，递归地翻转其左子树和右子树，然后交换当前节点的左右子节点。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>函数定义 {@code invertTree(root)}：</strong>
 *     <ul>
 *       <li>这是一个递归函数，它接收一个 {@code TreeNode} (当前节点) 作为参数，并返回翻转后的子树的根节点。</li>
 *     </ul>
 *   </li>
 *   <li><strong>基本情况 (Base Case / 递归终止条件)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 为 {@code null}：
 *         <ul>
 *           <li>这意味着我们到达了叶子节点下方，或者处理的是一个空树。空节点无需翻转，直接返回 {@code null}。</li>
 *           <li>{@code if (root == null) { return null; }}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>递归关系 (Recursive Step)：</strong>
 *     <ul>
 *       <li>如果当前节点 {@code root} 不为 {@code null}：
 *         <ul>
 *           <li><strong>1. 递归翻转左子树：</strong>{@code TreeNode leftInverted = invertTree(root.left);}。这会返回 {@code root} 原来左子树的翻转版本。</li>
 *           <li><strong>2. 递归翻转右子树：</strong>{@code TreeNode rightInverted = invertTree(root.right);}。这会返回 {@code root} 原来右子树的翻转版本。</li>
 *           <li><strong>3. 交换当前节点的左右子节点：</strong>
 *             <ul>
 *               <li>将 {@code root} 的左指针指向 {@code rightInverted} ({@code root.left = rightInverted;})。</li>
 *               <li>将 {@code root} 的右指针指向 {@code leftInverted} ({@code root.right = leftInverted;})。</li>
 *             </ul>
 *           </li>
 *           <li><strong>4. 返回当前节点：</strong>{@code return root;}。返回这个已经翻转了其子树，并交换了左右子节点的根节点。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次，并对其子节点进行操作。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log_2 N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public TreeNode invertTree(TreeNode root) {
    // 基本情况：如果当前节点为空，直接返回 null
    if (root == null) {
        return null;
    }
    // 递归翻转左子树，得到翻转后的左子树根节点
    TreeNode leftInverted = invertTree(root.left);
    // 递归翻转右子树，得到翻转后的右子树根节点
    TreeNode rightInverted = invertTree(root.right);
    // 交换当前节点的左右子节点
    // 原来的 root.left 现在指向翻转后的右子树
    root.left = rightInverted;
    // 原来的 root.right 现在指向翻转后的左子树
    root.right = leftInverted;
    // 返回当前节点，作为其父节点的新子树
    return root;
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代 + 广度优先]
/**
 * <p>此方法解决“翻转二叉树”问题，采用<strong>迭代 (Iteration)</strong> 的方式，
 * 本质上是广度优先搜索 (BFS) 或层序遍历。</p>
 * <p>核心思想：逐层遍历二叉树。在每一层，对当前节点执行左右子节点交换操作，然后将其子节点加入队列，以便在下一层进行同样的处理。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>特殊情况：</strong>
 *     <ul>
 *       <li>如果 {@code root} 为 {@code null}，意味着是空树，直接返回 {@code null}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个队列 {@code Queue<TreeNode> queue} (推荐使用 {@code LinkedList} 或 {@code ArrayDeque}) 用于存储待访问的节点。</li>
 *       <li>将根节点 {@code root} 加入队列：{@code queue.offer(root);}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环 (层序遍历)：</strong> {@code while (!queue.isEmpty())}
 *     <ul>
 *       <li>从队列中取出一个节点：{@code TreeNode node = queue.poll();}。</li>
 *       <li><strong>对当前节点进行翻转操作：</strong>
 *         <ul>
 *           <li>使用一个临时变量 {@code temp} 存储 {@code node.left}。</li>
 *           <li>将 {@code node.left} 指向 {@code node.right}。</li>
 *           <li>将 {@code node.right} 指向 {@code temp}。</li>
 *         </ul>
 *       </li>
 *       <li><strong>将交换后的子节点（如果非空）加入队列，准备在下一层处理：</strong>
 *         <ul>
 *           <li>{@code if (node.left != null) { queue.offer(node.left); }} (注意这里是新的 {@code node.left})</li>
 *           <li>{@code if (node.right != null) { queue.offer(node.right); }} (注意这里是新的 {@code node.right})</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>当主循环结束时 (队列为空)，所有节点都已处理完毕，返回原始的 {@code root} 引用 (因为根节点本身没有变化，只是其内部结构被翻转了)。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被加入队列一次，从队列中取出一次，并进行一次左右子节点交换。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(W)}。
 *     <ul>
 *       <li>其中 {@code W} 是二叉树的最大宽度（即在同一层中节点最多的数量）。这是队列在最坏情况下需要存储的节点数量。</li>
 *       <li>在最坏情况（例如，完全平衡树的最后一层），{@code W} 可以达到 {@code N/2}，所以空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，倾斜树），{@code W = 1}，空间复杂度为 {@code O(1)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public TreeNode invertTree(TreeNode root) {
    // 基本情况：如果根节点为空，直接返回 null
    if (root == null) {
        return null;
    }
    // 使用队列进行广度优先搜索 (BFS)
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root); // 将根节点加入队列
    // 当队列不为空时，继续层序遍历
    while (!queue.isEmpty()) {
        // 从队列中取出一个节点
        TreeNode node = queue.poll();
        // 交换当前节点的左右子节点
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
        // 将交换后的左子节点（如果存在）加入队列，为下一层做准备
        if (node.left != null) {
            queue.offer(node.left);
        }
        // 将交换后的右子节点（如果存在）加入队列，为下一层做准备
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    return root; // 返回根节点，此时整个树已翻转
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 对称二叉树

::: code-group

```java [递归 + 深度优先]
/**
 * <p>此方法解决“对称二叉树”问题，采用<strong>递归 (Recursion)</strong> 的方式，
 * 本质上是深度优先搜索 (DFS)。</p>
 * <p>核心思想：判断一棵树是否是对称的，等价于判断其左子树和右子树是否互为镜像。</p>
 * <p>为此，我们定义一个辅助函数 {@code isMirror} 来判断两棵树是否互为镜像。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>主函数 {@code isSymmetric(root)}：</strong>
 *     <ul>
 *       <li><strong>特殊情况：</strong> 如果 {@code root} 为 {@code null}，空树被认为是轴对称的，返回 {@code true}。</li>
 *       <li>否则，调用辅助函数 {@code isMirror(root.left, root.right)} 来判断根节点的左子树和右子树是否互为镜像。</li>
 *     </ul>
 *   </li>
 *   <li><strong>辅助函数 {@code isMirror(node1, node2)}：</strong>
 *     <ul>
 *       <li>这是一个递归函数，接收两个 {@code TreeNode} 作为参数，判断它们是否互为镜像。</li>
 *       <li><strong>基本情况 (Base Cases / 递归终止条件)：</strong>
 *         <ul>
 *           <li><strong>情况 1: 两者都为空：</strong> {@code if (node1 == null && node2 == null)}。如果两个节点都为 {@code null}，它们当然是对称的，返回 {@code true}。</li>
 *           <li><strong>情况 2: 其中一个为空：</strong> {@code if (node1 == null || node2 == null)}。如果其中一个为 {@code null} 而另一个不为 {@code null}，它们不对称，返回 {@code false}。</li>
 *           <li><strong>情况 3: 值不相等：</strong> {@code if (node1.val != node2.val)}。如果两个节点的值不相等，它们不对称，返回 {@code false}。</li>
 *         </ul>
 *       </li>
 *       <li><strong>递归关系 (Recursive Step)：</strong>
 *         <ul>
 *           <li>如果上述基本情况都不满足（即 {@code node1} 和 {@code node2} 都非空且值相等），则需要进一步递归检查：
 *             <ul>
 *               <li>{@code node1} 的左子节点 ({@code node1.left}) 必须与 {@code node2} 的右子节点 ({@code node2.right}) 互为镜像。</li>
 *               <li>{@code node1} 的右子节点 ({@code node1.right}) 必须与 {@code node2} 的左子节点 ({@code node2.left}) 互为镜像。</li>
 *             </ul>
 *           </li>
 *           <li>只有当这两对子节点都满足镜像对称条件时，当前 {@code node1} 和 {@code node2} 才能算互为镜像。</li>
 *           <li>{@code return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被 {@code isMirror} 函数访问一次 (作为 {@code node1} 或 {@code node2})。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log_2 N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean isSymmetric(TreeNode root) {
    // 如果根节点为空，根据定义，空树是对称的
    if (root == null) {
        return true;
    }
    // 调用辅助函数检查根节点的左右子树是否互为镜像
    return isMirror(root.left, root.right);
}

/**
 * 辅助函数：判断两个节点（或子树）是否互为镜像
 *
 * @param node1 第一个节点
 * @param node2 第二个节点
 * @return 如果互为镜像则返回 true，否则返回 false
 */
private boolean isMirror(TreeNode node1, TreeNode node2) {
    // 情况 1: 两个节点都为空，它们是对称的
    if (node1 == null && node2 == null) {
        return true;
    }
    // 情况 2: 其中一个节点为空，另一个不为空，它们不对称
    if (node1 == null || node2 == null) {
        return false;
    }
    // 情况 3: 两个节点的值不相等，它们不对称
    if (node1.val != node2.val) {
        return false;
    }
    // 递归检查：
    // node1 的左子节点必须与 node2 的右子节点镜像对称
    // node1 的右子节点必须与 node2 的左子节点镜像对称
    return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java [迭代 + 广度优先]
/**
 * <p>此方法解决“对称二叉树”问题，采用<strong>迭代 (Iteration)</strong> 的方式，
 * 本质上是广度优先搜索 (BFS)。</p>
 * <p>核心思想：使用队列同时进行两个节点（一个在左子树，一个在右子树）的层序遍历，
 * 在每一步都检查它们是否满足镜像条件。如果任何时候不满足，则树不对称。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>特殊情况：</strong>
 *     <ul>
 *       <li>如果 {@code root} 为 {@code null}，空树是对称的，直接返回 {@code true}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>创建一个队列 {@code Queue<TreeNode> queue} (推荐使用 {@code LinkedList} 或 {@code ArrayDeque})。</li>
 *       <li>将根节点的左孩子 {@code root.left} 和右孩子 {@code root.right} <strong>同时</strong>加入队列进行第一次配对。
 *         {@code queue.offer(root.left);}
 *         {@code queue.offer(root.right);}
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>主循环：</strong> {@code while (!queue.isEmpty())}
 *     <ul>
 *       <li>每次循环从队列中取出两个节点进行比较：
 *         <ul>
 *           <li>{@code TreeNode node1 = queue.poll();}</li>
 *           <li>{@code TreeNode node2 = queue.poll();}</li>
 *         </ul>
 *       </li>
 *       <li><strong>比较和判断：</strong>
 *         <ul>
 *           <li><strong>情况 1: 两者都为空：</strong> {@code if (node1 == null && node2 == null)}。这对是合法的镜像，继续下一轮循环 ({@code continue;})。</li>
 *           <li><strong>情况 2: 其中一个为空，或者值不相等：</strong> {@code if (node1 == null || node2 == null || node1.val != node2.val)}。
 *             <ul>
 *               <li>这表示不满足镜像条件（要么结构不对称，要么值不相等），立即返回 {@code false}。</li>
 *             </ul>
 *           </li>
 *           <li><strong>情况 3: 两者都非空且值相等（满足当前层判断）：</strong>
 *             <ul>
 *               <li>将它们“内外侧”的子节点按照镜像配对关系重新加入队列，以便在下一轮循环中进行检查：
 *                 <ul>
 *                   <li>将 {@code node1.left} (左子树的外侧) 和 {@code node2.right} (右子树的外侧) 加入队列：
 *                     {@code queue.offer(node1.left);}
 *                     {@code queue.offer(node2.right);}
 *                   </li>
 *                   <li>将 {@code node1.right} (左子树的内侧) 和 {@code node2.left} (右子树的内侧) 加入队列：
 *                     {@code queue.offer(node1.right);}
 *                     {@code queue.offer(node2.left);}
 *                   </li>
 *                 </ul>
 *               </li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>返回结果：</strong>
 *     <ul>
 *       <li>如果 {@code while} 循环正常结束 (即队列为空且所有节点都通过了镜像检查)，则说明树是对称的，返回 {@code true}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点会被加入队列一次，并从队列中取出一次。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(W)}。
 *     <ul>
 *       <li>其中 {@code W} 是二叉树的最大宽度。队列在最坏情况下需要存储的节点数量。</li>
 *       <li>在最坏情况（例如，完全平衡树的最后一层），{@code W} 可以达到 {@code N/2}，所以空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，倾斜树），{@code W = 1}，空间复杂度为 {@code O(1)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public boolean isSymmetric(TreeNode root) {
    // 如果根节点为空，根据定义，空树是对称的
    if (root == null) {
        return true;
    }
    // 使用队列进行层次遍历 (BFS)
    Queue<TreeNode> queue = new LinkedList<>();
    // 将根节点的左子节点和右子节点一并加入队列进行配对
    queue.offer(root.left);
    queue.offer(root.right);
    // 当队列不为空时，继续检查
    while (!queue.isEmpty()) {
        // 每次从队列中取出两个节点进行比较
        TreeNode node1 = queue.poll();
        TreeNode node2 = queue.poll();
        // 情况 1: 两个节点都为空，它们是对称的，继续下一轮循环
        if (node1 == null && node2 == null) {
            continue;
        }
        // 情况 2: 其中一个节点为空，或者两个节点的值不相等，它们不对称，直接返回 false
        // 注意：因为上面已经排除了两者都为 null 的情况，所以这里只要有一个 null 就意味着不对称
        if (node1 == null || node2 == null || node1.val != node2.val) {
            return false;
        }
        // 如果两个节点都非空且值相等，则将它们的子节点按照镜像关系加入队列
        // 1. node1 的左子节点 和 node2 的右子节点 应该镜像对称
        queue.offer(node1.left);
        queue.offer(node2.right);
        // 2. node1 的右子节点 和 node2 的左子节点 应该镜像对称
        queue.offer(node1.right);
        queue.offer(node2.left);
    }
    // 如果循环结束，所有节点都通过了镜像检查，说明树是对称的
    return true;
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 二叉树的直径

::: code-group

```java []
/**
 * <p>此方法解决“二叉树的直径”问题，采用<strong>递归 (Recursion)</strong> 的方式，
 * 本质上是深度优先搜索 (DFS) 的后序遍历变种。</p>
 * <p>核心思想：二叉树的直径可以理解为：对于树中的<strong>任意一个节点</strong>，穿过该节点的最长路径的长度。
 * 这个“穿过某个节点的最长路径”等于其左子树的最大深度 + 其右子树的最大深度。</p>
 * <p>因此，我们需要一个后序遍历，在处理一个节点时，先计算其左右子树的深度，然后用这两者之和更新全局最大直径。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>全局变量 {@code maxDiameter}：</strong>
 *     <ul>
 *       <li>定义一个类成员变量 {@code int maxDiameter = 0;} 用于存储遍历过程中找到的最大直径。之所以是全局或成员变量，是因为递归函数本身通常返回的是深度，而不是直径，而直径是在计算深度过程中“顺便”计算并更新的。</li>
 *     </ul>
 *   </li>
 *   <li><strong>主函数 {@code diameterOfBinaryTree(root)}：</strong>
 *     <ul>
 *       <li>调用辅助递归函数 {@code dfs(root)}。</li>
 *       <li>返回 {@code maxDiameter}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>辅助递归函数 {@code dfs(node)}：</strong>
 *     <ul>
 *       <li><strong>作用：</strong> 计算以 {@code node} 为根的子树的最大深度，并在此过程中更新 {@code maxDiameter}。</li>
 *       <li><strong>返回值：</strong> 以 {@code node} 为根的子树的最大深度 (注意：不是直径)。</li>
 *       <li><strong>基本情况 (Base Case / 递归终止条件)：</strong>
 *         <ul>
 *           <li>如果当前节点 {@code node} 为 {@code null}，意味着到达叶子节点以下，其深度为 {@code 0}。
 *             {@code if (node == null) { return 0; }}</li>
 *         </ul>
 *       </li>
 *       <li><strong>递归调用：</strong>
 *         <ul>
 *           <li>{@code int leftDepth = dfs(node.left);}：递归计算左子树的最大深度。</li>
 *           <li>{@code int rightDepth = dfs(node.right);}：递归计算右子树的最大深度。</li>
 *         </ul>
 *       </li>
 *       <li><strong>更新 {@code maxDiameter}：</strong>
 *         <ul>
 *           <li>一条通过当前节点 {@code node} 的最长路径的长度（边数）是 {@code leftDepth + rightDepth}。
 *             例如，如果左子树深度为 3，右子树深度为 2，那么经过当前节点的最长路径为 3+2=5 条边。</li>
 *           <li>{@code maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);}</li>
 *         </ul>
 *       </li>
 *       <li><strong>返回当前子树的深度：</strong>
 *         <ul>
 *           <li>以 {@code node} 为根的子树的最大深度是 {@code 1} (当前节点自身) 加上其左右子树深度的较大者。
 *             {@code return 1 + Math.max(leftDepth, rightDepth);}</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(N)}。
 *     <ul>
 *       <li>其中 {@code N} 是二叉树中节点的总数。每个节点都会被访问一次，进行深度计算和直径更新。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(H)}。
 *     <ul>
 *       <li>其中 {@code H} 是二叉树的高度。这是递归调用栈的最大深度。</li>
 *       <li>在最坏情况（例如，倾斜树），{@code H = N}，空间复杂度为 {@code O(N)}。</li>
 *       <li>在最好情况（例如，完全平衡树），{@code H = log_2 N}，空间复杂度为 {@code O(log N)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
// 使用一个类成员变量来存储最大的直径，因为递归函数本身返回的是子树的深度
private int maxDiameter = 0;

public int diameterOfBinaryTree(TreeNode root) {
    // 调用辅助函数启动深度计算和直径更新
    // dfs 函数的返回值是当前子树的深度，这个返回值本身对主函数来说不重要，
    // 重要的是在遍历过程中更新了 maxDiameter
    dfs(root);
    return maxDiameter;
}

/**
 * 辅助递归函数，计算以当前节点为根的子树的最大深度，并在此过程中更新全局最大直径。
 *
 * @param node 当前要处理的节点
 * @return 以当前节点为根的子树的最大深度（不是直径）
 */
private int dfs(TreeNode node) {
    // 基本情况：如果节点为空，则其深度为 0
    if (node == null) {
        return 0;
    }
    // 递归计算左子树的最大深度
    int leftDepth = dfs(node.left);
    // 递归计算右子树的最大深度
    int rightDepth = dfs(node.right);
    // 在当前节点处，一条“穿过”该节点的最长路径长度
    // 等于其左子树深度 + 右子树深度（边数）
    // 这个路径长度可能就是当前或全局的最大直径
    maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);
    // 返回以当前节点为根的子树的最大深度
    // 1 代表当前节点，然后加上左右子树中较大的深度
    return 1 + Math.max(leftDepth, rightDepth);
}

// TreeNode 类的定义 (通常是题目提供的)
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

:::

## 二叉树的层序遍历

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 将有序数组转换为二叉搜索树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 验证二叉搜索树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉搜索树中第 K 小的元素

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的右视图

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树展开为链表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 从前序与中序遍历序列构造二叉树

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 路径总和 III

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树的最近公共祖先

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 二叉树中的最大路径和

::: code-group

```java []
/**
 * TODO
 */
```

:::
