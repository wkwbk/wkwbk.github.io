# 普通数组

## 最大子数组和

::: code-group

```java [动态规划]
/**
 * <p>此方法使用动态规划来找到数组中具有最大和的连续子数组。</p>
 * <p>核心思想是：遍历数组，对于每个元素 {@code nums[i]}，我们有两个选择来构建以 {@code nums[i]} 结尾的子数组：</p>
 * <ol>
 *   <li>将 {@code nums[i]} 添加到前面子数组的最大和中（如果这个和是正的）。</li>
 *   <li>重新开始一个新的子数组，只包含 {@code nums[i]}。</li>
 * </ol>
 * <p>我们选择能使当前子数组和更大的那个选项，并不断更新全局的最大和。</p>
 *
 * <h3>算法思路：</h3>
 * <ol>
 *   <li><strong>初始化变量：</strong>
 *     <ul>
 *       <li>{@code maxSum}：用于存储到目前为止找到的全局最大子数组和，初始化为数组的第一个元素 {@code nums[0]}。</li>
 *       <li>{@code currentSum}：用于存储以当前遍历到的元素 {@code nums[i]} 结尾的最大子数组和，初始化为数组的第一个元素 {@code nums[0]}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>遍历数组：</strong>
 *     <ul>
 *       <li>从数组的第二个元素开始（索引 {@code i = 1}）遍历到数组的最后一个元素。</li>
 *       <li>对于每个元素 {@code nums[i]}：
 *         <ul>
 *           <li>更新 {@code currentSum}：比较两个值：
 *             <ul>
 *               <li>{@code nums[i]}：表示以 {@code nums[i]} 开始的新子数组。</li>
 *               <li>{@code currentSum + nums[i]}：表示将 {@code nums[i]} 加入到以 {@code nums[i-1]} 结尾的最大子数组中。</li>
 *             </ul>
 *             选择这两者中较大的一个作为新的 {@code currentSum}。
 *             等价于：{@code currentSum = Math.max(nums[i], currentSum + nums[i])}。
 *           </li>
 *           <li>更新 {@code maxSum}：比较当前的 {@code currentSum} 和全局的 {@code maxSum}，将较大的值赋给 {@code maxSum}。
 *             等价于：{@code maxSum = Math.max(maxSum, currentSum)}。
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li>遍历结束后，返回 {@code maxSum}。</li>
 * </ol>
 *
 * <h3>动态规划状态转移方程：</h3>
 * <p>定义 {@code dp[i]} 为以 {@code nums[i]} 结尾的最大连续子数组和。</p>
 * <p>{@code dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0)}</p>
 * <p>或者更简洁地：{@code dp[i] = Math.max(nums[i], dp[i-1] + nums[i])}</p>
 * <p>最终结果是所有 {@code dp[i]} 中的最大值。</p>
 * <p>在实际实现中，我们不需要一个完整的 {@code dp} 数组，只需要一个变量 {@code currentSum} 来表示 {@code dp[i-1]}，从而将空间复杂度优化到 {@code O(1)}。</p>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n)}。
 *     <ul>
 *       <li>我们只遍历数组一次。</li>
 *       <li>每次迭代中的操作（比较和加法）都是 {@code O(1)}。</li>
 *       <li>因此，总时间复杂度为 {@code O(n)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>除了存储输入数组所需的空间外，只使用了常数个额外变量 ({@code maxSum}, {@code currentSum})。</li>
 *     </ul>
 *   </li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 * @return 数组中具有最大和的连续子数组的最大和。
 */
public int maxSubArray(int[] nums) {
    // maxSum 存储全局最大子数组和
    int maxSum = nums[0];
    // currentSum 存储以当前元素结尾的最大子数组和
    int currentSum = nums[0];

    // 从数组的第二个元素开始遍历
    for (int i = 1; i < nums.length; i++) {
        // 对于当前元素 nums[i]，以它结尾的最大子数组和有两种可能：
        // 1. 包含 nums[i-1] 之前的所有元素，即 currentSum + nums[i]
        // 2. 只包含 nums[i] 自己，形成一个新的子数组
        // 我们选择其中较大的一个作为新的 currentSum
        currentSum = Math.max(nums[i], currentSum + nums[i]);

        // 更新全局最大子数组和
        maxSum = Math.max(maxSum, currentSum);
    }

    return maxSum;
}
```

:::

## 合并区间

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 轮转数组

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 除自身以外数组的乘积

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 缺失的第一个正数

::: code-group

```java []
/**
 * TODO
 */
```

:::
