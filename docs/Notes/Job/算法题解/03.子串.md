# 子串

## 和为 K 的子数组

::: code-group

```java [暴力枚举]
/**
 * <p>此方法使用暴力枚举所有可能的子数组，然后检查它们的和是否等于 {@code k}。</p>
 * <p>一个子数组由其起始索引和结束索引唯一确定。</p>
 *
 * <h3>算法思路：</h3>
 * <ol>
 *   <li>初始化计数器 {@code count = 0}，用于记录和为 {@code k} 的子数组个数。</li>
 *   <li>使用外层循环 {@code i} 从 {@code 0} 遍历到 {@code n-1}，表示子数组的起始索引。</li>
 *   <li>使用内层循环 {@code j} 从 {@code i} 遍历到 {@code n-1}，表示子数组的结束索引。
 *     <ul>
 *       <li>在内层循环中，维护一个变量 {@code currentSum}，它表示从 {@code nums[i]} 到 {@code nums[j]} 的子数组的和。</li>
 *       <li>每次 {@code j} 递增时，将 {@code nums[j]} 添加到 {@code currentSum} 中。</li>
 *       <li>如果 {@code currentSum == k}，则说明找到了一个符合条件的子数组，将 {@code count} 递增 1。</li>
 *     </ul>
 *   </li>
 *   <li>循环结束后，返回 {@code count}。</li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n^2)}。
 *     <ul>
 *       <li>外层循环执行 {@code n} 次。</li>
 *       <li>内层循环在最坏情况下也执行 {@code n} 次。</li>
 *       <li>每次内层循环中的操作（加法和比较）都是 {@code O(1)}。</li>
 *       <li>因此，总时间复杂度为 {@code O(n * n) = O(n^2)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(1)}。
 *     <ul>
 *       <li>除了存储输入数组和返回结果所需的空间外，只使用了常数个额外变量。</li>
 *     </ul>
 *   </li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 * @param k    目标和。
 * @return 数组中和为 {@code k} 的子数组的个数。
 */
public int subarraySum(int[] nums, int k) {
    int n = nums.length;
    int count = 0; // 记录和为 k 的子数组个数

    // i 作为子数组的起始索引
    for (int i = 0; i < n; i++) {
        int currentSum = 0; // 当前子数组的和

        // j 作为子数组的结束索引
        // 子数组为 nums[i...j]
        for (int j = i; j < n; j++) {
            currentSum += nums[j]; // 累加当前元素到子数组的和中

            // 如果当前子数组的和等于 k，则找到一个符合条件的子数组
            if (currentSum == k) {
                count++;
            }
        }
    }

    return count;
}
```

```java [前缀和 + 哈希表]
/**
 * <p>此方法利用前缀和和哈希表来高效地解决和为 {@code k} 的子数组问题。</p>
 * <p>核心思想：如果一个子数组 {@code nums[i...j]} 的和为 {@code k}，那么其前缀和 {@code sum[j]} 减去前缀和 {@code sum[i-1]} 应该等于 {@code k}。
 * 即 {@code sum[j] - sum[i-1] = k}，这等价于 {@code sum[i-1] = sum[j] - k}。</p>
 * <p>我们遍历数组，计算每个位置的前缀和，并使用哈希表存储每个前缀和出现的次数。
 * 当计算到当前前缀和 {@code currentSum} 时，我们查询哈希表中是否存在 {@code (currentSum - k)} 这个前缀和。
 * 如果存在，那么所有以 {@code currentSum - k} 结尾的前缀和，它们之后到当前位置 {@code currentSum} 之间形成的子数组的和都为 {@code k}。</p>
 *
 * <h3>算法思路：</h3>
 * <ol>
 *   <li>初始化计数器 {@code count = 0}，用于记录和为 {@code k} 的子数组个数。</li>
 *   <li>初始化当前前缀和 {@code currentSum = 0}。</li>
 *   <li>创建一个哈希表 {@code prefixSumCount = new HashMap<Integer, Integer>()}，用于存储：
 *     <ul>
 *       <li>键：前缀和的值。</li>
 *       <li>值：该前缀和出现的次数。</li>
 *     </ul>
 *   </li>
 *   <li><strong>初始化哈希表：</strong> 将 {@code (0, 1)} 存入 {@code prefixSumCount}。
 *     <ul>
 *       <li>这表示在数组开始之前（索引 -1），前缀和为 0 的情况出现了一次。这对于处理从数组第一个元素开始的子数组 (即 {@code sum[j] - sum[-1] = k} 变成 {@code sum[j] - 0 = k}) 至关重要。</li>
 *     </ul>
 *   </li>
 *   <li>遍历数组 {@code nums} 的每个元素 {@code num} (或通过索引 {@code i})：
 *     <ul>
 *       <li>将 {@code num} 加到 {@code currentSum} 中，更新当前前缀和。</li>
 *       <li>在哈希表中查找是否存在键为 {@code (currentSum - k)} 的项。
 *         <ul>
 *           <li>如果存在，说明之前存在一个前缀和为 {@code (currentSum - k)} 的位置。那么从该位置的下一个元素到当前元素所形成的子数组的和就是 {@code k}。</li>
 *           <li>将 {@code count} 加上 {@code prefixSumCount.get(currentSum - k)} (即符合条件的子数组个数)。</li>
 *         </ul>
 *       </li>
 *       <li>将当前的 {@code currentSum} 及其出现次数存入或更新到 {@code prefixSumCount} 中。
 *         <ul>
 *           <li>{@code prefixSumCount.put(currentSum, prefixSumCount.getOrDefault(currentSum, 0) + 1)}。</li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li>循环结束后，返回 {@code count}。</li>
 * </ol>
 *
 * <h3>核心思想：</h3>
 * <p>如果 {@code sum[j]} 是从 {@code nums[0]} 到 {@code nums[j]} 的和，{@code sum[i-1]} 是从 {@code nums[0]} 到 {@code nums[i-1]} 的和。</p>
 * <p>那么子数组 {@code nums[i...j]} 的和就是 {@code sum[j] - sum[i-1]}。</p>
 * <p>我们想找到 {@code sum[j] - sum[i-1] = k} 的情况。这等价于 {@code sum[i-1] = sum[j] - k}。</p>
 * <p>因此，当我们遍历到 {@code j} 计算出 {@code currentSum = sum[j]} 时，我们只需要检查之前是否有 {@code sum[i-1] = currentSum - k} 出现过，以及出现过多少次。</p>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(n)}。
 *     <ul>
 *       <li>我们只遍历数组一次。</li>
 *       <li>在每次迭代中，哈希表的 {@code put}、{@code get} 和 {@code containsKey} 操作的平均时间复杂度为 {@code O(1)}。</li>
 *       <li>因此，总时间复杂度为 {@code O(n)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(n)}。
 *     <ul>
 *       <li>在最坏情况下（例如，所有前缀和都不同），哈希表中会存储 {@code n} 个不同的前缀和。</li>
 *       <li>因此，空间复杂度为 {@code O(n)}。</li>
 *     </ul>
 *   </li>
 * </ul>
 *
 * @param nums 输入的整数数组。
 * @param k    目标和。
 * @return 数组中和为 {@code k} 的子数组的个数。
 */
public int subarraySum(int[] nums, int k) {
    int count = 0; // 记录和为 k 的子数组个数
    int currentSum = 0; // 记录当前的前缀和

    // 使用哈希表存储前缀和及其出现的次数
    // key: 前缀和的值
    // value: 该前缀和出现的次数
    Map<Integer, Integer> prefixSumCount = new HashMap<>();

    // 初始化：前缀和为 0 的情况出现一次 (对应空前缀，即在数组开始前)
    // 这一步非常关键，因为它允许我们处理从数组第一个元素开始的子数组
    // 例如，如果 nums = [k], k = k，那么 currentSum 第一次就等于 k。
    // 此时我们要找 currentSum - k = 0 的前缀和，如果 0 出现了 1 次，count 就会加 1。
    prefixSumCount.put(0, 1);

    for (int num : nums) {
        currentSum += num; // 更新当前前缀和

        // 如果哈希表中存在 (currentSum - k) 这个前缀和
        // 那么从 (currentSum - k) 对应的位置到当前位置 num 之间形成的子数组的和就是 k
        if (prefixSumCount.containsKey(currentSum - k)) {
            // 将符合条件的子数组的个数累加到 count 中
            count += prefixSumCount.get(currentSum - k);
        }

        // 将当前的 currentSum 及其出现次数存入或更新到哈希表中
        prefixSumCount.put(currentSum, prefixSumCount.getOrDefault(currentSum, 0) + 1);
    }

    return count;
}
```

:::

## 滑动窗口最大值

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 最小覆盖子串

::: code-group

```java []
/**
 * TODO
 */
```

:::
