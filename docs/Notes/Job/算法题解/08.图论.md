# 图论

## 岛屿数量

::: code-group

```java [深度优先]
/**
 * <p>此方法解决“岛屿数量”问题，采用<strong>深度优先搜索 (DFS)</strong> 的方式。</p>
 * <p>核心思想：将每个 '1'（陆地）视为图中的一个节点，相邻的陆地之间有边。
 * 问题转化为计算图中的连通分量数量。
 * 当我们发现一个陆地单元格时，说明我们发现了一个新岛屿。
 * 为了不重复计数这个岛屿的其它部分，我们利用 DFS 遍历这个岛屿的所有陆地单元格，
 * 并将其标记为已访问（通过将其从 '1' 改为 '0'，模拟“淹没”岛屿）。
 * 每当主遍历循环中找到一个未访问的 '1'，就增加岛屿计数器。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>主函数 {@code numIslands(grid)}：</strong>
 *     <ul>
 *       <li><strong>参数：</strong> {@code grid} 二维字符数组，代表网格。</li>
 *       <li><strong>返回：</strong> 岛屿的总数量。</li>
 *       <li><strong>基本情况：</strong>
 *         <ul>
 *           <li>{@code if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;}：
 *             如果网格为空，返回 0。</li>
 *         </ul>
 *       </li>
 *       <li><strong>初始化：</strong>
 *         <ul>
 *           <li>{@code int rows = grid.length;}</li>
 *           <li>{@code int cols = grid[0].length;}</li>
 *           <li>{@code int numIslands = 0;}：初始化岛屿计数器。</li>
 *         </ul>
 *       </li>
 *       <li><strong>遍历网格：</strong>
 *         <ul>
 *           <li>使用嵌套循环 {@code for (int r = 0; r < rows; r++)} 和 {@code for (int c = 0; c < cols; c++)} 遍历每一个单元格。</li>
 *           <li><strong>发现陆地：</strong>
 *             <ul>
 *               <li>{@code if (grid[r][c] == '1')}：如果当前单元格是陆地 (并且之前没有被访问过，因为被访问过的 '1' 会变成 '0')。
 *                 <ul>
 *                   <li>{@code numIslands++;}：增加岛屿计数。</li>
 *                   <li>{@code dfs(grid, r, c);}：从当前单元格启动 DFS，将这个岛屿的所有陆地单元格都标记为 '0'。</li>
 *                 </ul>
 *               </li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *       <li>{@code return numIslands;}：返回最终的岛屿数量。</li>
 *     </ul>
 *   </li>
 *   <li><strong>辅助 DFS 函数 {@code dfs(grid, r, c)}：</strong>
 *     <ul>
 *       <li><strong>参数：</strong> {@code grid} 网格，{@code r} 当前行索引，{@code c} 当前列索引。</li>
 *       <li><strong>返回：</strong> {@code void}。此函数直接修改网格，将其陆地单元格标记为 '0'。</li>
 *       <li><strong>边界条件 (递归终止条件)：</strong>
 *         <ul>
 *           <li>{@code if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == '0')}：
 *             <ul>
 *               <li>如果当前坐标超出网格的有效范围。</li>
 *               <li>或者当前单元格是水（'0'），这包括原始是水和已经被 DFS 访问过的陆地。</li>
 *               <li>满足以上任何一个条件，则停止进一步搜索，直接返回。</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *       <li><strong>核心逻辑：</strong>
 *         <ul>
 *           <li>{@code grid[r][c] = '0';}：将当前陆地单元格标记为水，表示它已经被访问（“淹没”）了。</li>
 *           <li><strong>递归访问相邻单元格：</strong>
 *             <ul>
 *               <li>{@code dfs(grid, r + 1, c);} (向下)</li>
 *               <li>{@code dfs(grid, r - 1, c);} (向上)</li>
 *               <li>{@code dfs(grid, r, c + 1);} (向右)</li>
 *               <li>{@code dfs(grid, r, c - 1);} (向左)</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(R * C)}。
 *     <ul>
 *       <li>其中 {@code R} 是网格的行数，{@code C} 是网格的列数。</li>
 *       <li>主循环会遍历每个单元格一次 (R * C)。</li>
 *       <li>DFS 函数中，每个陆地单元格最多被访问和修改一次。因为一旦被访问，它就会被标记为 '0'，不会再次进入 DFS。</li>
 *       <li>因此，总时间复杂度是 {@code O(R * C)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(R * C)} (最坏情况)。
 *     <ul>
 *       <li>主要是递归调用栈的深度。在最坏情况，整个网格都是陆地，DFS 递归深度可以达到 {@code R * C}。</li>
 *       <li>在最好情况（例如，只有一行或一列），{@code H = min(R, C)}。</li>
 *       <li>在平均情况或其他情况，取决于连通分量的形状。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0 || grid[0].length == 0) {
        return 0; // 空网格，没有岛屿
    }
    int rows = grid.length;
    int cols = grid[0].length;
    int numIslands = 0; // 岛屿计数
    // 遍历整个网格
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            // 如果发现一个陆地单元格 '1'
            if (grid[r][c] == '1') {
                numIslands++; // 岛屿数量加一
                // 从这个陆地单元格开始，使用 DFS 淹没整个岛屿
                // 这样这个岛屿的所有部分都被标记为 '0'，后续不会重复计数
                dfs(grid, r, c);
            }
        }
    }
    return numIslands;
}

/**
 * 深度优先搜索 (DFS) 辅助函数，用于“淹没”一个岛屿。
 * 从 (r, c) 开始，将其及所有相邻的陆地单元格都标记为 '0'。
 *
 * @param grid 网格
 * @param r    当前行索引
 * @param c    当前列索引
 */
private void dfs(char[][] grid, int r, int c) {
    // 边界条件：
    // 1. 坐标超出网格范围
    // 2. 当前单元格是水 ('0') -- 包括原始是水和已经被访问过的陆地
    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == '0') {
        return;
    }
    // 将当前陆地单元格标记为 '0'，表示已访问/已淹没
    grid[r][c] = '0';
    // 递归访问相邻的陆地单元格（上、下、左、右）
    dfs(grid, r + 1, c); // 向下
    dfs(grid, r - 1, c); // 向上
    dfs(grid, r, c + 1); // 向右
    dfs(grid, r, c - 1); // 向左
}
```

:::

## 腐烂的橘子

::: code-group

```java []
/**
 * <p>此方法解决“腐烂的橘子”问题，采用<strong>广度优先搜索 (BFS)</strong> 的方式。</p>
 * <p>核心思想：问题要求计算腐烂所有新鲜橘子所需的最少分钟数，且腐烂过程是同时向四周扩散的，
 * 这正是 BFS 解决最短路径/层序遍历问题的典型场景。这是一个<strong>多源 BFS</strong> 问题，
 * 所有初始的腐烂橘子同时开始扩散，就像洪水从多个源头同时蔓延。</p>
 *
 * <h3>算法步骤：</h3>
 * <ol>
 *   <li><strong>初始化：</strong>
 *     <ul>
 *       <li>{@code rows}, {@code cols}：获取网格的维度。</li>
 *       <li>{@code queue} (Type: {@code Queue<int[]>})：用于存储当前分钟腐烂橘子的坐标 {@code [r, c]}。</li>
 *       <li>{@code freshOranges}：计数器，记录网格中新鲜橘子的初始总数。</li>
 *       <li>遍历整个 {@code grid}：
 *         <ul>
 *           <li>如果遇到 {@code grid[r][c] == 2} (腐烂橘子)，将其坐标 {@code [r, c]} 加入 {@code queue}。</li>
 *           <li>如果遇到 {@code grid[r][c] == 1} (新鲜橘子)，{@code freshOranges++}。</li>
 *         </ul>
 *       </li>
 *       <li><strong>特殊情况处理：</strong> {@code if (freshOranges == 0) return 0;}：如果一开始就没有新鲜橘子，直接返回 0 分钟。</li>
 *     </ul>
 *   </li>
 *   <li><strong>BFS 循环：</strong>
 *     <ul>
 *       <li>{@code minutes = 0;}：初始化分钟计数器。</li>
 *       <li>{@code directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}}：定义四个方向的偏移量。</li>
 *       <li>{@code while (!queue.isEmpty() && freshOranges > 0)}：
 *         <ul>
 *           <li><strong>处理当前层（当前分钟腐烂橘子感染新橘子）：</strong>
 *             <ul>
 *               <li>{@code int size = queue.size();}：获取当前队列中腐烂橘子的数量。这些橘子将在本分钟内进行感染。</li>
 *               <li>{@code for (int i = 0; i < size; i++)}：遍历当前队列中的所有橘子：
 *                 <ul>
 *                   <li>{@code int[] rotten = queue.poll();}：取出队首的一个腐烂橘子。</li>
 *                   <li>对这个橘子的四个相邻方向进行检查：
 *                     <ul>
 *                       <li>{@code int newR = rotten[0] + dr;}</li>
 *                       <li>{@code int newC = rotten[1] + dc;}</li>
 *                       <li><strong>检查有效性：</strong> {@code if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && grid[newR][newC] == 1)}
 *                         <ul>
 *                           <li>如果新坐标合法，并且是新鲜橘子：</li>
 *                           <li>{@code grid[newR][newC] = 2;}：将其标记为腐烂。</li>
 *                           <li>{@code queue.offer(new int[]{newR, newC});}：将新腐烂的橘子加入队列，它将在下一分钟感染其他橘子。</li>
 *                           <li>{@code freshOranges--;}：减少新鲜橘子计数。</li>
 *                         </ul>
 *                       </li>
 *                     </ul>
 *                   </li>
 *                 </ul>
 *               </li>
 *             </ul>
 *           </li>
 *           <li><strong>分钟数递增：</strong>
 *             <ul>
 *               <li>{@code if (freshOranges > 0)}：
 *                 {@code minutes++;}：只有当这一分钟结束后，仍然有新鲜橘子需要腐烂，并且队列里确实有新的腐烂橘子（可以在下一分钟继续感染）时，才增加分钟数。
 *                 这样可以避免当最后一批橘子腐烂后，{@code minutes} 还会多加 1 的情况。</li>
 *             </ul>
 *           </li>
 *         </ul>
 *       </li>
 *     </ul>
 *   </li>
 *   <li><strong>结果判断：</strong>
 *     <ul>
 *       <li>{@code if (freshOranges == 0)}：如果所有新鲜橘子都成功腐烂，返回 {@code minutes}。</li>
 *       <li>{@code else}：如果循环结束后仍有新鲜橘子未腐烂（说明它们是不可达的），返回 {@code -1}。</li>
 *     </ul>
 *   </li>
 * </ol>
 *
 * <h3>性能分析：</h3>
 * <ul>
 *   <li><strong>时间复杂度：</strong> {@code O(R * C)}。
 *     <ul>
 *       <li>其中 {@code R} 是网格的行数，{@code C} 是网格的列数。</li>
 *       <li>每个单元格（橘子或空单元格）最多会被访问一次（在初始化阶段加入队列，或在 BFS 阶段被检查）。</li>
 *       <li>每个新鲜橘子最多会从 {@code 1} 变为 {@code 2} 一次。</li>
 *       <li>每个腐烂橘子最多会被从队列中取出一次，并检查其四个方向的邻居。</li>
 *       <li>因此，总时间复杂度是 {@code O(R * C)}。</li>
 *     </ul>
 *   </li>
 *   <li><strong>空间复杂度：</strong> {@code O(R * C)} (最坏情况)。
 *     <ul>
 *       <li>队列中最多存储所有的腐烂橘子坐标。在最坏情况下，所有陆地在同一分钟内腐烂，队列可能包含 {@code R * C} 个元素。</li>
 *     </ul>
 *   </li>
 * </ul>
 */
public int orangesRotting(int[][] grid) {
    if (grid == null || grid.length == 0 || grid[0].length == 0) {
        return 0; // 空网格，无需腐烂
    }
    int rows = grid.length;
    int cols = grid[0].length;
    int freshOranges = 0; // 新鲜橘子计数
    Queue<int[]> queue = new LinkedList<>(); // BFS 队列，存储腐烂橘子的坐标
    // 第一次遍历网格，初始化队列和新鲜橘子数量
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == 2) {
                queue.offer(new int[]{r, c}); // 初始腐烂的橘子加入队列
            } else if (grid[r][c] == 1) {
                freshOranges++; // 统计新鲜橘子数量
            }
        }
    }
    // 如果没有新鲜橘子，则不需要时间，直接返回 0
    if (freshOranges == 0) {
        return 0;
    }
    int minutes = 0; // 记录经过的分钟数
    // 定义四个方向的偏移量：右、左、下、上
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    // BFS 核心循环：当队列不空且还有新鲜橘子时继续
    // Queue.isEmpty() 负责判断是否所有可达橘子都已处理
    // freshOranges > 0 负责判断是否还有橘子未腐烂（可能不可达）
    while (!queue.isEmpty() && freshOranges > 0) {
        int size = queue.size(); // 获取当前层有多少腐烂橘子，这些橘子将在这一分钟内感染新橘子
        // 处理当前层的所有腐烂橘子
        for (int i = 0; i < size; i++) {
            int[] rotten = queue.poll(); // 取出当前腐烂橘子
            int r = rotten[0];
            int c = rotten[1];
            // 检查其四个方向的相邻单元格
            for (int[] dir : directions) {
                int newR = r + dir[0];
                int newC = c + dir[1];
                // 检查新坐标是否在网格内，并且是一个新鲜橘子
                if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && grid[newR][newC] == 1) {
                    grid[newR][newC] = 2; // 将新鲜橘子标记为腐烂
                    queue.offer(new int[]{newR, newC}); // 新腐烂的橘子加入队列，将在下一分钟感染
                    freshOranges--; // 新鲜橘子数量减一
                }
            }
        }

        // 注意：只有当这一分钟确实有新的橘子被感染并加入队列时（即队列不为空），
        // 且仍有新鲜橘子未腐烂时，才增加分钟数。
        // 否则，如果队列已经空了（表示没有新的橘子可以腐烂了），minutes 不应再增加。
        // 另一种写法是，在内层循环结束后，如果 freshOranges 在本次循环中减少了，
        // 且 outer queue is not empty, minutes++ (更严谨，但本方法中由于 freshOranges>0 检查，
        // 最终会收敛，不额外增加分钟数)
        if (!queue.isEmpty()) { // 这一层感染结束后，如果队列还有元素，说明下一分钟还有橘子要腐烂
            minutes++;
        }
    }
    // 最终判断：如果所有新鲜橘子都腐烂了，返回分钟数
    if (freshOranges == 0) {
        return minutes;
    } else {
        // 否则，说明有新鲜橘子无法被腐烂
        return -1;
    }
}
```

:::

## 课程表

::: code-group

```java []
/**
 * TODO
 */
```

:::

## 实现 Trie (前缀树)

::: code-group

```java []
/**
 * TODO
 */
```

:::
